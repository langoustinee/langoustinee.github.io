I"!<p><br /></p>

<center><img src="/assets/images/baekjoon/18310.png" width="100%" /></center>

<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<p>이번 문제는 <strong>그리디 알고리즘과 정렬</strong>을 알고 있다면 쉽게 풀 수 있는 문제이다.</p>

<p>처음엔 단순히 평균 구해서 평균과 가장 가까운 집을 선택하면 될 것이라 생각했다.
예제 입력 1도 그렇게 해보니 맞길래 그렇게 하니 당연히 틀렸다. 아래와 같은 경우, 평균으로 구하면 6.8 이므로 가장 가까운건 ‘6’이다. 그래서 ‘6’을 골라보면 차이의 합은 14이다. 하지만 실제론 9를 골라야 11로 최소이다. 따라서 평균은 아님을 금방 알 수 있었다.</p>

<p>5
1 6 9 9 9
Copy</p>

<p>그래서 규칙성을 찾아보려고 했는데, 첫번째 지점부터 하나씩 다 들려보면서 생각해봤다. 처음 ‘1’의 위치에 있을 때 차이의 합은 0 + 5 + 8 + 8 + 8 이다. ‘2’의 위치에 있다면 1 + 4 + 7 + 7 + 7 이다. ‘3’의 위치라면 2 + 3 + 6 + 6 + 6 이다. …. ‘7’의 위치에 있다면 6 + 1 + 2 + 2 + 2 이다. 즉, ‘1’부터 쭉 진행해보면 현재 위치보다 좌측 지점의 수만큼 +N이 되고, 현재 위치보다 우측 지점의 수만큼 -M이 되는 식이다. 이 때 어떠한 지점이라도 지정할 수 있다면 더 나은 지점을 찾을 순 있겠지만, 이 문제에서는 집이 위치한 곳에만 설치가 가능하다. 따라서 좌우 갯수가 맞춰지는 지점으로 고르면 된다.</p>

<p>즉, 정렬 후 중간에 위치한 값을 출력해주면 된다. 5개라면 3번째 값, 6개라면 3번째 혹은 4번째 값을 출력하면 되는데, ‘여러 개의 값이 도출될 경우 가장 작은 값’ 이라 했으므로 3번째 값을 출력해야 한다. 인덱스로 따지면 (N-1)/2 인덱스의 값을 출력해주면 된다.</p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p><br /><br /></p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.BufferedReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.BufferedWriter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStreamReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.OutputStreamWriter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.StringTokenizer</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>

        <span class="c1">// 주어지는 집들의 번호가 여러개일 때 항상 중위값에 위치한 집에 안테나를 설정하는 것이 가장 적절합니다.</span>
        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>

        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="c1">// 오름차순 정렬을 실시하여 배열의 중위값을 반환해야합니다</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">);</span>

        <span class="c1">// 중위값은 N이 짝수인지, 홀수인지에 따라 나뉘어지므로 이 부분을 구분하여 답을 출력해야합니다</span>
        <span class="k">if</span><span class="o">(</span><span class="no">N</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="no">N</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="o">]+</span><span class="s">"\n"</span><span class="o">);</span>
        <span class="k">else</span> <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="no">N</span><span class="o">/</span><span class="mi">2</span><span class="o">]+</span><span class="s">"\n"</span><span class="o">);</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>

<ul>
  <li>에라토스테네스의 체를 이용해 소수 배열을 만들어 사용하는 것이 아니라, 소수를 판별하기 위한 방법으로 사용해볼 수 있었다.</li>
  <li>아직 공부가 더 필요하지만, 재귀함수를 이용해 깊이 우선 탐색인 DFS를 구현할 수 있었다.</li>
</ul>

<h3 id="출처">출처</h3>

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/2023">문제 링크</a>에서 참조바랍니다.</li>
</ul>
:ET