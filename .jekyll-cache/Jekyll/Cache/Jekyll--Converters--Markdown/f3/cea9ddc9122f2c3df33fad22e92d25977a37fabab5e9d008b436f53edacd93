I"Z<p><br /></p>

<center><img src="/assets/images/baekjoon/2023_attach01.png" width="100%" /></center>
<center><img src="/assets/images/baekjoon/2023_attach02.png" width="100%" /></center>

<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />
<p>이번 <code class="language-plaintext highlighter-rouge">신기한 소수</code> 문제는 소수를 구하는 방법과 재귀를 잘 고려해야 한다. <br />
소수 판별에 에라토스테네스의 체를 이용하였고, 각 자리수별로 소수인지를 알아내기 위해서 DFS를 사용하였다. <br /></p>

<h4 id="에라토스테네스의-체">에라토스테네스의 체</h4>

<p><br />
<img src="/assets/images/baekjoon/2023_attach03.gif" width="60%" />
<br /></p>

<p>에라토스테네스의 체는 <code class="language-plaintext highlighter-rouge">소수가 되는 수의 배수를 지우면 남은 건 소수가 된다.</code>라는 원리의 알고리즘이라고 보면 된다. <br />
그래서, 소수가 무엇인지 찾을 필요가 없으며 2부터 자기 자신을 제외한 배수를 지우면 된다.</p>

<p><br /></p>

<h4 id="에라토스테네스의-체를-이용한-소수-배열을-만들-경우-메모리-초과-발생">에라토스테네스의 체를 이용한 소수 배열을 만들 경우 메모리 초과 발생</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
<span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="nc">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
<span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="nc">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="no">N</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

<span class="kt">boolean</span><span class="o">[]</span> <span class="n">prime_arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">end</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
<span class="n">prime_arr</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">prime_arr</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="nc">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">end</span><span class="o">);</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">prime_arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">+=</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">prime_arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>​위처럼 에라토스네테스의 체를 이용해 소수 배열을 만들어 두고 문제를 풀려했으나 <strong>메모리 초과가 발생</strong>하였다.</p>

<p>이 문제는 <strong>메모리 제한이 4MB</strong>밖에 되지 않기 때문에 에라토스테네스의 체 알고리즘을 이용해서 배열에 <strong>소수 판별을 저장한 배열을 사용한</strong>다면 N이 8까지 주어질 수 있어, <strong>천만 자리수까지 고려해야 하기에 메모리 초과가 발생</strong>하게 되었다고 판단하였다. 또한, 위 코드는 시간 복잡도가 <strong>O(NloglogN)</strong>으로, 지금처럼 n이 매우 큰 경우라면 시간초과가 추가적으로 발생할 우려가 있었다.</p>

<p>결국, N이 10^8인 경우라면, 이는 4초가 걸려 2초 안에 해결할 수 없을 뿐더러, 애초에 처음부터 배열 선언시에 메모리 초과가 뜰것이다.</p>

<p>그래서 에라토스테네스의 체를 소수 배열을 만드는 것에 이용하는 것이 아니라 <strong>재귀함수를 이용해 모든 수를 탐색하며 소수 판별을 하는데 이용</strong>해야 한다.</p>

<p><br /></p>

<h4 id="문제-분석-및-아이디어-도출">문제 분석 및 아이디어 도출</h4>

<p>이 문제의 핵심은 자릿수를 하나씩 덧붙여가는 과정에서 수 대부분을 쉽게 가지 칠 수 있다는 점이다.</p>
<ul>
  <li>몇 자리수가 됐든, 소수가 되려면 <strong>왼쪽부터 1자리 수가 소수</strong>여야만 한다. 즉 신기한 소수의 <strong>첫째 자리 수는 소수인 <code class="language-plaintext highlighter-rouge">2,3,5,7</code> 중의 하나이고 이 경우에만 다음 자릿수를 붙여가면 된다.</strong></li>
</ul>

<p>첫째 자리 수부터 살펴보자.</p>

<p>소수인 2에 0~9까지 다음 자릿수를 붙여준다면 <code class="language-plaintext highlighter-rouge">23</code>과 <code class="language-plaintext highlighter-rouge">29</code>를 제외한 <code class="language-plaintext highlighter-rouge">20,21,22,24,25,26,27,28</code> 는 소수가 아니기 때문에 걸러낼 수 있다. 이렇게 <strong>소수가 아니라면 다음 자리수를 붙일 필요가 없다.</strong> 결국, 소수가 되는 <code class="language-plaintext highlighter-rouge">23</code>과 <code class="language-plaintext highlighter-rouge">29</code>의 경우에만 다음 자릿수를 붙여가면 된다.</p>

<p>주어진 예제와 같이 N이 4일 경우를 살펴보자.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="rouge-code"><pre>// N = 4
// 1000 ~ 9999 까지 중에서 모든 신기한 소수를 출력해야 한다.
1
2 -&gt; 소수
    20
    21
    22
    23 -&gt; 소수
        230
        231
        232
        233 -&gt; 소수
            2330
            2331
            2332
            2333 -&gt; 신기한 소수(length = 4 = N)
            ...
        ...
    24
    25
    26
    27
    28
    29 -&gt; 소수
3 -&gt; 소수
    30
    ...
4
5 -&gt; 소수
    50
    ...
6
7 -&gt; 소수
    70
    ...
8
9
</pre></td></tr></tbody></table></code></pre></div></div>

<p>2가 아닌 나머지 3,5,7의 경우에도 동일하게 진행하면 된다.
그렇게 이 과정을 반복하며 N의 자리까지 자릿수를 붙여가며 만들어진 수가 <strong>N만큼의 길이를 가졌을 때 그 수가 소수라면 앞에서 자리수 별로 소수 여부를 판별하고 지나왔기에 신기한 소수일 수밖에 없는 것</strong>이다.</p>

<p><br /></p>

<p>위에서 짠 아이디어를 토대로 코드를 작성해보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="no">N</span><span class="o">;</span>
    <span class="o">...</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>먼저 입력받을 N을 재귀 메소드에서 사용하기 위해 static 키워드를 붙여서 Main 클래스의 모든 메소드에서 사용할 수 있도록 선언하였다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
    <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
    <span class="n">recursion</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
    <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>main 메소드에서는 N을 입력받고 recursion이라는 재귀메소드를 호출하였다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="c1">// 재귀를 통해 N만큼 자리수를 붙여가기</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">recursion</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">isPrime</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">str</span> <span class="o">+</span> <span class="n">i</span><span class="o">)))</span> <span class="o">{</span>
            <span class="n">recursion</span><span class="o">(</span><span class="n">str</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>recursion 재귀 메소드를 살펴보자.</p>

<p>str 변수에 <code class="language-plaintext highlighter-rouge">""</code>과 같은 빈 문자열을 받아와서 실행되며, 1부터 9까지의 문자를 이 str 문자열 변수에 붙여가는데, <strong>str 변수에 1부터 9까지 붙여가면서 해당 문자열이 소수인지를 검증</strong>한다. <br />
만약 소수라면 str+i 라는 수가 소수이기에 str+i라는 문자열을 파라미터로 함수를 재귀 호출한다. 이 과정을 반복하면서 <strong>str의 길이가 N만큼 채워졌다면 신기한 소수가 된 것이기에 출력하고 재귀를 종료</strong>한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="c1">// 에라토스테네스의 체로 소수 판별하기</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isPrime</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">sqrt</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="nc">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">sqrt</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>마지막으로 소수를 판별하는 로직이다. 앞서 말했듯 에라토스테네스의 체를 이용해 소수를 판별하도록 하였다.
1은 소수가 아니기에 false를 반환하고, 2부터 i의 제곱근까지 순회하면서 소수인 수를 걸러낸다.</p>

<blockquote>
  <p>이 떄, 여기서 i를 제곱근까지만 반복하는 이유는 <strong>i의 제곱이 n보다 크면, i와 n/i 중 하나는 반드시 n의 제곱근보다 작기 때문</strong>이다.
예를 들어, 121의 약수를 구하려면 1부터 11까지 모두 확인해야 하는데, 11보다 큰 약수는 이미 11보다 작은 약수를 통해 구할 수 있기 때문에 11까지만 확인하면 된다. 따라서, i를 제곱근까지만 반복하면, n의 제곱근보다 큰 약수는 확인할 필요가 없어지므로, 반복 횟수를 줄여 연산 속도를 향상시킬 수 있는 것이다.</p>
</blockquote>

<p><br /><br /></p>

<h3 id="작성코드">작성코드</h3>
<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.BufferedReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStreamReader</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="no">N</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="n">recursion</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// 재귀를 통해 N만큼 자리수를 붙여가기</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">recursion</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span><span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
			<span class="k">return</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="k">if</span><span class="o">(</span><span class="n">isPrime</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">str</span> <span class="o">+</span> <span class="n">i</span><span class="o">)))</span> <span class="o">{</span>
				<span class="n">recursion</span><span class="o">(</span><span class="n">str</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
			<span class="o">}</span>
		<span class="o">}</span>
	<span class="o">}</span>

    <span class="c1">// 에라토스테네스의 체로 소수 판별하기</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isPrime</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sqrt</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="nc">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">sqrt</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<ul>
  <li>에라토스테네스의 체를 이용해 소수 배열만을 만들어 사용하는 것이 아니라, 소수를 판별하기 위한 방법으로 사용해볼 수 있었다.</li>
  <li>아직 공부가 더 필요하지만, 재귀함수를 이용해 깊이 우선 탐색인 DFS를 구현할 수 있었다.</li>
</ul>

<h3 id="출처">출처</h3>
<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/2023">문제 링크</a>에서 참조바랍니다.</li>
</ul>
:ET