I"^S<p><br /></p>

<center><img src="/assets/images/baekjoon/18353-attach01.png" width="100%" /></center>
<center><img src="/assets/images/baekjoon/18353-attach02.png" width="100%" /></center>

<p><br /><br /></p>

<h3 id="문제-분석">문제 분석</h3>

<hr />

<p>이번 문제는 내림차순으로 병사를 배치하기 위해서 내림차순 순서가 맞지 않는 병사들을 제외시켜야 한다.</p>

<p>이 때 LIS라는 최장 증가 부분 수열 알고리즘을 이용하여 정답을 구할 수 있다. 이 LIS를 구하기 위해 DP와 이분탐색 2가지 풀이 방법으로 문제를 풀어보겠다.</p>

<h4 id="lis란">LIS란?</h4>

<p><strong>LIS(Longest Increasing Subsequenc)</strong>란 최장 증가 부분 수열이라고 한다. 즉 가장 긴 증가하는 부분 수열이라는 뜻이다.</p>

<p>LIS는 원소가 N개인 배열의 일부 원소를 골라내서 만든 부분 수열 중에서 각 원소가 이전 원소보다 크다는 조건을 만족하고, 그 길이가 최대인 부분 수열을 최장 증가 부분 수열이라고 한다. 바로 <strong>오름차순으로 증가하는 형태의 부분 수열이며, 해당 수열의 길이가 가장 긴 수열</strong>을 뜻한다.</p>

<center><img src="https://velog.velcdn.com/images%2Fkimdukbae%2Fpost%2Feaade731-0699-437b-a5bd-faf3341487d2%2Fimage.png" width="80%" /></center>

<p>예를 들어, <code class="language-plaintext highlighter-rouge">{10, 21, 1, 10, 20, 30, 40, 50, 60}</code> 이라는 배열이 있을 경우, LIS는 <strong><code class="language-plaintext highlighter-rouge">{1, 10, 20, 30, 40, 50, 60}</code></strong>이다. <code class="language-plaintext highlighter-rouge">{1, 10, 20}</code>, <code class="language-plaintext highlighter-rouge">{1, 10, 20, 30, 40}</code>과 같이 증가하는 부분 수열은 많지만 그 중에서 가장 긴 수열이 LIS가 되기 때문에 <code class="language-plaintext highlighter-rouge">{1, 10, 20, 30, 40, 50, 60}</code>가 되는 것이다.</p>

<p>이러한 LIS, 즉 최장 증가 부분 수열의 길이를 구하는 것은 일반적으로 <strong>DP(동적계획법)</strong>을 이용한다.</p>

<p><br /><br /></p>

<h3 id="dp를-활용한-풀이">DP를 활용한 풀이</h3>

<hr />

<p>자, 이제 DP를 이용해 LIS의 길이를 구해서 제외해야할 병사의 수를 구하는 코드를 작성해보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">seq</span><span class="o">;</span>
<span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span><span class="o">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>주어진 병사의 전투력을 담을 int 배열 seq와 dp를 static 키워드로 선언하여 main 메소드 바깥에서도 사용할 수 있도록 선언하였다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
<span class="n">seq</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
<span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>첫번째 줄에서 병사의 수 N을 입력받은 후, seq 배열과 dp 배열을 N과 같은 크기로 초기화한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">seq</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>두번째 줄에서 병사의 전투력을 공백 기준으로 입력받게 되는데 StringTokenizer를 이용해 seq 배열에 병사의 전투력을 입력순으로 저장한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
<span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="no">LIS</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<p>그리고 0부터 N-1 만큼 탐색하면서 <strong>0부터 N-1 까지의 i를 인수로 LIS 메소드를 호출</strong>한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">LIS</span><span class="o">(</span><span class="kt">int</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 만약 탐색하지 않았던 위치의 경우</span>
    <span class="k">if</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">dp</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">// N부터 0까지 중에서 N보다 큰 값들을 찾으면서 재귀 호출하기</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">seq</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">seq</span><span class="o">[</span><span class="no">N</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">dp</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="no">N</span><span class="o">],</span> <span class="no">LIS</span><span class="o">(</span><span class="n">i</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>LIS 메소드가 호출되었을 때는 탐색하려는 인덱스(위치)에 대해서 이전 위치들을 찾아나가면서 해당 값보다 클 경우 재귀호출을 통해 탐색해나가면 되지 않을까?</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="no">N</span> <span class="o">-</span> <span class="n">max</span> <span class="o">+</span> <span class="s">"\n"</span><span class="o">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><br /></p>

<h3 id="이분-탐색읋-활용한-풀이">이분 탐색읋 활용한 풀이</h3>

<hr />

<p>앞에서 살펴본 DP를 통해 LIS를 구하는 방법의 시간복잡도는 <strong>O(n^2)</strong>가 되는데, 이는 굉장이 비효율적이다. 그래서 시간복잡도를 줄이기 위해 <strong>이분 탐색</strong>을 활용해보려 한다.</p>

<blockquote>
  <p><em>입력 값이 백만 개 정도만 되어도 O(n^2)의 알고리즘은 실행시간이 10초 이상 소요된다고 알려져 있다.</em></p>
</blockquote>

<p>LIS의 형태를 유지하기 위해 주어진 배열의 인덱스를 하나씩 살펴보면서 그 숫자가 들어갈 위치를 이분탐색으로 탐색해서 넣는다.
이분탐색은 일반적으로 시간복잡도가 O(logn)으로 알려져 있으므로, 위의 문제를 O(blogs)의 시간복잡도로 해결할 수 있게 된다.</p>

<p><br /></p>

<h3 id="작성코드---dp">작성코드 - DP</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.BufferedReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.BufferedWriter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStreamReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.OutputStreamWriter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.StringTokenizer</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">seq</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>

        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>

        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">seq</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="no">LIS</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="no">N</span> <span class="o">-</span> <span class="n">max</span> <span class="o">+</span> <span class="s">"\n"</span><span class="o">);</span>
        <span class="n">bw</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">LIS</span><span class="o">(</span><span class="kt">int</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 만약 탐색하지 않았던 위치의 경우</span>
        <span class="k">if</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">dp</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="c1">// System.out.println(Arrays.toString(dp));</span>
            <span class="c1">// N부터 0까지 중에서 N보다 큰 값들을 찾으면서 재귀 호출하기</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
                <span class="c1">// System.out.println(i + " " + seq[i] + " " + seq[N]);</span>
                <span class="k">if</span><span class="o">(</span><span class="n">seq</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">seq</span><span class="o">[</span><span class="no">N</span><span class="o">])</span> <span class="o">{</span>
                    <span class="n">dp</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="no">N</span><span class="o">],</span> <span class="no">LIS</span><span class="o">(</span><span class="n">i</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">dp</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="작성코드---이분-탐색">작성코드 - 이분 탐색</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>

<hr />

<p>-</p>
<ul>
  <li>
    <p>dp 배열을 Integer 배열로 선언할 수 도 있었는데, 이유는 DP를 통해 반복을 하며 dp배열의 원소가 null일 때를 비교해야 하기 때문이다. 이 때, int 배열에서도 0으로 비교하면 되겠지만, Collections.max() 메소드로 LIS의 최대 길이를 구하기 위해 dp 배열을 List로 변환해야 하는데, int배열은 List로 변환되지 않기 때문이다.</p>
  </li>
  <li>
    <p>int 배열이 List로 변환되지 않는 이유는 int[] 배열은 기본 자료형(primitive type)의 배열이기에 Arrays.asList() 메소드를 통해 List로 변환할 수 없다. 이는 Arrays.asList() 메소드가 매개변수로 전달된 객체를 배열이 아닌 컬렉션(Collection) 형태로 반환하기 때문이다.</p>
  </li>
</ul>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/18353">문제 링크</a>에서 참조바랍니다.</li>
  <li><a href="https://velog.io/@kimdukbae/BOJ-11053-%EA%B0%80%EC%9E%A5-%EA%B8%B4-%EC%A6%9D%EA%B0%80%ED%95%98%EB%8A%94-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4-Python">LIS 이미지 출처</a></li>
</ul>
:ET