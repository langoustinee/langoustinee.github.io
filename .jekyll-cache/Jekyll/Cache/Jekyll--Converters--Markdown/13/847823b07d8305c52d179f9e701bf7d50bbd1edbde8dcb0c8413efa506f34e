I"(<p><br /></p>

<center><img src="/assets/images/baekjoon/18310.png" width="100%" /></center>

<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<p>이번 문제는 <strong>그리디 알고리즘과 정렬</strong>을 알고 있다면 쉽게 풀 수 있는 문제이다.</p>

<h3 id="문제-분석">문제 분석</h3>

<p>처음엔 단순히 집들의 평균거리를 구해서 평균과 가장 가까운 집을 선택하면 될 것이라 생각했지만 아니었다. <br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>N = 5
1 6 9 9 9
</pre></td></tr></tbody></table></code></pre></div></div>

<p>위 예제를 보면 평균을 구하면 6.8이므로 가장 가까운 건 <code class="language-plaintext highlighter-rouge">6</code>이지만, 6의 거리 차이의 합은 <code class="language-plaintext highlighter-rouge">14</code>이고 9의 거리의 차이는 실제로 <code class="language-plaintext highlighter-rouge">11</code>이기에 <code class="language-plaintext highlighter-rouge">6</code>이 아닌 <code class="language-plaintext highlighter-rouge">9</code>일 때 최소 거리의 합이 충족된다.
따라서 평균 값으로 구하면 안된다는 것을 알 수 있었다.</p>

<ul>
  <li>처음 <code class="language-plaintext highlighter-rouge">1</code>의 위치에 있을 때 차이의 합은 <code class="language-plaintext highlighter-rouge">29(0+5+8+8+8)</code> 이다.</li>
  <li><code class="language-plaintext highlighter-rouge">2</code>의 위치에 있다면 <code class="language-plaintext highlighter-rouge">26(1+4+7+7+7)</code> 이다.</li>
  <li><code class="language-plaintext highlighter-rouge">3</code>의 위치라면 <code class="language-plaintext highlighter-rouge">23(2+3+6+6+6)</code> 이다.</li>
  <li><code class="language-plaintext highlighter-rouge">4</code>의 위치라면 <code class="language-plaintext highlighter-rouge">20(3+2+5+5+5)</code> 이다.</li>
  <li><code class="language-plaintext highlighter-rouge">5</code>의 위치라면 <code class="language-plaintext highlighter-rouge">17(4+1+4+4+4)</code> 이다.</li>
  <li><code class="language-plaintext highlighter-rouge">6</code>의 위치라면 <code class="language-plaintext highlighter-rouge">14(5+0+3+3+3)</code> 이다.</li>
  <li><code class="language-plaintext highlighter-rouge">7</code>의 위치에 있다면 <code class="language-plaintext highlighter-rouge">13(6+1+2+2+2)</code> 이다.</li>
  <li><code class="language-plaintext highlighter-rouge">8</code>의 위치에 있다면 <code class="language-plaintext highlighter-rouge">12(7+2+1+1+1)</code>이다.</li>
  <li><code class="language-plaintext highlighter-rouge">9</code>의 위치라면 <code class="language-plaintext highlighter-rouge">11(8+3+0+0+0)</code> 이다.</li>
</ul>

<p>즉,<code class="language-plaintext highlighter-rouge">1</code>부터 순회하면 현재 위치보다 좌측 지점의 수만큼 <code class="language-plaintext highlighter-rouge">+N</code>이 되고, 현재 위치보다 우측 지점의 수만큼 <code class="language-plaintext highlighter-rouge">-M</code>이 되는 식이다. <br />
그런데 문제에서 요구하는 것은 집이 위치한 곳에만 안테나 설치가 가능하다. 따라서 좌우 갯수가 맞춰지는 지점으로 고르면 된다.</p>

<p>즉, 정렬 후 중간에 위치한 값을 출력해주면 된다. 5개라면 3번째 값, 6개라면 3번째 혹은 4번째 값을 출력하면 되는데, ‘여러 개의 값이 도출될 경우 가장 작은 값’ 이라 했으므로 3번째 값을 출력해야 한다. 인덱스로 따지면 (N-1)/2 인덱스의 값을 출력해주면 된다.</p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p><br /><br /></p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.BufferedReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.BufferedWriter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStreamReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.OutputStreamWriter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.StringTokenizer</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>

        <span class="c1">// 주어지는 집들의 번호가 여러개일 때 항상 중위값에 위치한 집에 안테나를 설정하는 것이 가장 적절합니다.</span>
        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>

        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="c1">// 오름차순 정렬을 실시하여 배열의 중위값을 반환해야합니다</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">);</span>

        <span class="c1">// 중위값은 N이 짝수인지, 홀수인지에 따라 나뉘어지므로 이 부분을 구분하여 답을 출력해야합니다</span>
        <span class="k">if</span><span class="o">(</span><span class="no">N</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="no">N</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="o">]+</span><span class="s">"\n"</span><span class="o">);</span>
        <span class="k">else</span> <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="no">N</span><span class="o">/</span><span class="mi">2</span><span class="o">]+</span><span class="s">"\n"</span><span class="o">);</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>

<ul>
  <li>에라토스테네스의 체를 이용해 소수 배열을 만들어 사용하는 것이 아니라, 소수를 판별하기 위한 방법으로 사용해볼 수 있었다.</li>
  <li>아직 공부가 더 필요하지만, 재귀함수를 이용해 깊이 우선 탐색인 DFS를 구현할 수 있었다.</li>
</ul>

<h3 id="출처">출처</h3>

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/2023">문제 링크</a>에서 참조바랍니다.</li>
</ul>
:ET