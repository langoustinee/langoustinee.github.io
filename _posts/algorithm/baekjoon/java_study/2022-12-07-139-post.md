--- 
title: "[Java] 백준(브론즈-1) 11050번 - 이항 계수 1"
excerpt: "11050번 - 이항 계수 1"

categories: 
- Java

tags:
- [blog, algorithm, study, java, baekjoon]

toc: true
toc_sticky: true

date: 2022-12-07
---

<br>

<center><img src="/assets/images/baekjoon/11050.png" width="100%"></center>

<br><br>

### 문제 풀이
---
문제 풀이에 앞서 이항 계수가 무엇인지 알아보자. <br>

> **이항계수**란? <br>
위키백과를 보면 조합론에서 이항 계수(inomial coefficient)는 이항식을 이항 정리로 전개했을 때 각 항의 계수이며, 주어진 크기의 (순서 없는) 조합의 가짓수라고 한다.

전체 집합에서 원소개의 개수 n에 대해 k개의 아이템을 뽑는 이항계수(조합의 수)는 다음과 같다.
<img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/af575850eec19a2efa2ac71d38c3a4c7af88bf5d" width="300px">

이항식 `(x+y)^2` 을 이항정리로 전개한다면 `(x+y)^2 = x^2 + 2xy + y^2` 인데, 이 때의 각 항의 계수인 **[1,2,1]**이 이항계수이다.

그리고 이항계수는 조합을 통해 구할 수 있는데, 단순하게 위 공식을 이용하면 5개의 집합 중에서 2개를 순서없이 고르는 이항계수는 `5! / (2! * 3!)`이며 5!는 120이고, 2!는 2, 3!는 6이다. 120/12가 되어 답은 10이된다.

<br>

**파스칼의 삼각형** <br>
이항계수를 구하는 방법 중에 **파스칼의 삼각형**이 있다. 파스칼의 삼각형은 아래의 그림과 같은 관계가 성립한다.

<br>
<center><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbtKRHE%2FbtqDEG4glgs%2FvVU4LKVx4pY5KurS70E3Dk%2Fimg.png" width="80%" ></center>
<center><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fbsc0El%2FbtqDEY4Gn0z%2FVym2MLS3hKxplUV9vMWj81%2Fimg.png" width="30%"></center>
<br>


<br>

#### 아이디어 도출 - 팩토리얼
- 특별한 아이디어 없이 위에서 본 점화식을 그대로 팩토리얼로 구현하면 된다.

바로 코드를 작성해보자.
```java
StringTokenizer st = new StringTokenizer(br.readLine());
int N = Integer.parseInt(st.nextToken());
int K = Integer.parseInt(st.nextToken());

bw.write(factorial(N) / (factorial(K) * factorial(N-K)) + "\n");
```

N과 K를 입력받고 이항계수 공식대로 `N! / K! * (N-K)!` 를 factorial 함수로 표현한다. <br>
factorial 함수 코드의 내용은 다음과 같다.

```java
public static int factorial(int N) {
    if(N == 0) return 1;
    return N * factorial(N - 1);
}
```

팩토리얼을 사용한 무난한 이항계수 알고리즘이다. <br>
팩토리얼을 통해 구현할 떄 주의할 점은 factorial 함수가 **‘0!’ 일 경우 1을 반환**하도록 해야한다.

팩토리얼을 구현하여 제출하면 정답을 낼 수는 있지만 문제에서 요구하는 N과 K의 범위가 작기 때문이라고 생각이 들었다. <br>
팩토리얼을 통한 풀이는 기본적으로 시간복잡도가 크기에 수의 범위가 작은 이번 문제에서나 가능한 접근방식인 것 같다.


#### 아이디어 도출 - 재귀
- 이항계수 알고리즘을 점화식 그대로 재귀로 구현한다.

바로 코드를 작성해보자.

```java
public static int binomial(int n, int k) {
    if(k == 0 || n == k) return 1;
    return binomial(n - 1, k - 1) + binomial(n - 1, k);
}
```
재귀로 구현한 방식인데 이 방식의 경우 N의 범위가 커질수록 **O(n!)의 시간복잡도를 가지기에 제한시간이 빠듯하다면 시간초과가 발생할 가능성이 매우 높다.**


#### 아아디어 도출 -  동적계획법 풀이(DP)
파스칼의 삼각형을 통해 알 수 있었는데, 이항계수를 구하는 알고리즘은 **중복 부분문제와 최적 부분구조를 만족하므로 동적계획법으로 이항계수를 구할 수 있다.**

위의 코드에서 dp 라는 배열을 선언하여 각 단계에서 구한 이항계수의 값을 저장해 놓고 다음 이항계수를 구할 때 사용하고 있습니다. 

 

동적 계획법으로 이항계수 알고리즘을 구현한 경우 아래의 반복문을 이용한 동적 계획법의 구현처럼 
O(n^2)
 의 시간복잡도로 문제를 해결 할 수 있음을 알 수 있습니다. 



<br><br>

### 작성코드
---
#### 작성코드 - 팩토리얼
```java
import java.io.*;
import java.util.*;

class Main {
    public static void main(String[] args) throws IOException {
        
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        StringTokenizer st = new StringTokenizer(br.readLine());
        int N = Integer.parseInt(st.nextToken());
        int K = Integer.parseInt(st.nextToken());

        bw.write(factorial(N) / (factorial(K) * factorial(N-K)) + "\n");

        bw.flush();
        bw.close();
        br.close();
    }
    public static int factorial(int N) {
        if(N == 0) return 1;
        return N * factorial(N - 1);
    }
}
```

#### 작성코드 - 재귀
```java
import java.io.*;
import java.util.*;

class Main {
    public static void main(String[] args) throws IOException {
        
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        StringTokenizer st = new StringTokenizer(br.readLine());
        int N = Integer.parseInt(st.nextToken());
        int K = Integer.parseInt(st.nextToken());

        bw.write(binomial(N, K)+"\n");

        bw.flush();
        bw.close();
        br.close();
    }

    public static int binomial(int n, int k) {
        if(k == 0 || n == k) return 1;
	    return binomial(n - 1, k - 1) + binomial(n - 1, k);
    }
}
```

### 회고
- 

### 출처
- 해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 [문제 링크](https://www.acmicpc.net/problem/11050)에서 참조바랍니다.
- 파스칼의 삼각형 첨부 [이미지 출처](https://rh-tn.tistory.com/32)