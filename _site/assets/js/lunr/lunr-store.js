var store = [{
        "title": "벡엔드 개발자란?(작성중)",
        "excerpt":"나는 왜 백엔드 개발자가 되려고 하는걸까?  ","categories": [],
        "tags": ["Blog","Github","Backend","developer"],
        "url": "/first-post/",
        "teaser": null
      },{
        "title": "[Python] 백준 2588번",
        "excerpt":"백준 알고리즘 스터디 시작! 코딩테스트 준비를 위해 백준에서 알고리즘 공부를 시작했다. 1단계 사칙연산 풀이의 마지막 문제인 2588번 곱셈문제 풀이를 기록한다. (1)과 (2)위치에 들어갈 세 자리 자연수가 주어질 때 (3), (4), (5), (6)위치에 들어갈 값을 구하는 프로그램을 작성하시오. 문제: 입력받은 세자리수의 인덱스를 찾아서 곱해줘야 하는데 어떻게 인덱싱을 하여 곱해줄지가 문제였다. 해결:...","categories": ["Python"],
        "tags": ["Blog","algorithm","study","python","baekjoon"],
        "url": "/python/second-post/",
        "teaser": null
      },{
        "title": "[Python] 백준 2884번",
        "excerpt":"2884번 조건문을 활용한 알람시계 문제 첫째 줄에 두 정수 H와 M이 주어진다. (0 ≤ H ≤ 23, 0 ≤ M ≤ 59) 그리고 이것은 현재 상근이가 설정한 놓은 알람 시간 H시 M분을 의미한다. 입력 시간은 24시간 표현을 사용한다. 24시간 표현에서 하루의 시작은 0:0(자정)이고, 끝은 23:59(다음날 자정 1분 전)이다. 시간을 나타낼...","categories": ["Python"],
        "tags": ["Blog","algorithm","study","python","baekjoon"],
        "url": "/python/3-post/",
        "teaser": null
      },{
        "title": "[Python] 백준 2525번",
        "excerpt":"2525번 오븐시계 첫째 줄에는 현재 시각이 나온다. 현재 시각은 시 A (0 ≤ A ≤ 23) 와 분 B (0 ≤ B ≤ 59)가 정수로 빈칸을 사이에 두고 순서대로 주어진다. 두 번째 줄에는 요리하는 데 필요한 시간 C (0 ≤ C ≤ 1,000)가 분 단위로 주어진다. 첫째 줄에 종료되는 시각의...","categories": ["Python"],
        "tags": ["Blog","algorithm","study","python","baekjoon"],
        "url": "/python/4-post/",
        "teaser": null
      },{
        "title": "[Python] 백준 2480번",
        "excerpt":"2480번 주사위 세개 1에서부터 6까지의 눈을 가진 3개의 주사위를 던져서 다음과 같은 규칙에 따라 상금을 받는 게임이 있다. 같은 눈이 3개가 나오면 10,000원+(같은 눈)×1,000원의 상금을 받게 된다. 같은 눈이 2개만 나오는 경우에는 1,000원+(같은 눈)×100원의 상금을 받게 된다. 모두 다른 눈이 나오는 경우에는 (그 중 가장 큰 눈)×100원의 상금을 받게 된다....","categories": ["Python"],
        "tags": ["Blog","algorithm","study","python","baekjoon"],
        "url": "/python/5-post/",
        "teaser": null
      },{
        "title": "[Python] 백준 11021번",
        "excerpt":"11021번 A+B-7 두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오. 첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. (0 &lt; A, B &lt; 10) Input) 5 1 1 2 3 3 4 9 8 5 2 Output)...","categories": ["Python"],
        "tags": ["Blog","algorithm","study","python","baekjoon"],
        "url": "/python/6-post/",
        "teaser": null
      },{
        "title": "[Python] 백준 1110번",
        "excerpt":"1110번 더하기 사이클 0보다 크거나 같고, 99보다 작거나 같은 정수가 주어질 때 다음과 같은 연산을 할 수 있다. 먼저 주어진 수가 10보다 작다면 앞에 0을 붙여 두 자리 수로 만들고, 각 자리의 숫자를 더한다. 그 다음, 주어진 수의 가장 오른쪽 자리 수와 앞에서 구한 합의 가장 오른쪽 자리 수를 이어...","categories": ["Python"],
        "tags": ["Blog","algorithm","study","python","baekjoon"],
        "url": "/python/7-post/",
        "teaser": null
      },{
        "title": "[JS] 괄호 문자열 검증",
        "excerpt":"괄호 문자열 검증 ’(‘, ‘)’, ‘{‘, ‘}’, ‘[’ 및 ‘]’ 만 포함하는 문자열이 주어지면 입력 문자열이 유효한지 확인하자. 다음과 같은 경우 입력 문자열이 유효합니다. 열린 괄호와 동일한 유형의 괄호로 닫아야 합니다. 열린 괄호는 올바른 순서로 닫아야 합니다. 유효하면 true, 아니면 false를 리턴합니다. Input) () Output) true Input) ()[]{} Output) true...","categories": ["JavaScript"],
        "tags": ["Blog","algorithm","study","js"],
        "url": "/javascript/8-post/",
        "teaser": null
      },{
        "title": "[Python] 백준 4673번",
        "excerpt":"셀프 넘버 셀프 넘버는 1949년 인도 수학자 D.R. Kaprekar가 이름 붙였다. 양의 정수 n에 대해서 d(n)을 n과 n의 각 자리수를 더하는 함수라고 정의하자. 예를 들어, d(75) = 75+7+5 = 87이다. 양의 정수 n이 주어졌을 때, 이 수를 시작해서 n, d(n), d(d(n)), d(d(d(n))), …과 같은 무한 수열을 만들 수 있다. 예를...","categories": ["Python"],
        "tags": ["Blog","algorithm","study","python","baekjoon"],
        "url": "/python/9-post/",
        "teaser": null
      },{
        "title": "[Python] 백준 1157번",
        "excerpt":"단어 공부 알파벳 대소문자로 된 단어가 주어지면, 이 단어에서 가장 많이 사용된 알파벳이 무엇인지 알아내는 프로그램을 작성하시오. 단, 대문자와 소문자를 구분하지 않는다. Input-1) Mississipi Output-1) ? Input-2) bbaaac Output-2) A 접근 방식 입력 배열의 알파벳 중복을 제거한 뒤 사용된 알파벳의 갯수를 세어 빈 배열에 저장한다. 1번에서 저장한 배열의 최대값 개수가...","categories": ["Python"],
        "tags": ["Blog","algorithm","study","python","baekjoon"],
        "url": "/python/10-post/",
        "teaser": null
      },{
        "title": "[Python] 백준 2941번",
        "excerpt":"크로아티아 알파벳 ljes=njak은 크로아티아 알파벳 6개(lj, e, š, nj, a, k)로 이루어져 있다. 단어가 주어졌을 때, 몇 개의 크로아티아 알파벳으로 이루어져 있는지 출력한다. dž는 무조건 하나의 알파벳으로 쓰이고, d와 ž가 분리된 것으로 보지 않는다. lj와 nj도 마찬가지이다. 위 목록에 없는 알파벳은 한 글자씩 센다. Input-1) ljes=njak Output-1) 6 Input-2) ddz=z=...","categories": ["Python"],
        "tags": ["Blog","algorithm","study","python","baekjoon"],
        "url": "/python/11-post/",
        "teaser": null
      },{
        "title": "[Python] 백준 1316번",
        "excerpt":"그룹 단어 체커 그룹 단어란 단어에 존재하는 모든 문자에 대해서, 각 문자가 연속해서 나타나는 경우만을 말한다. 예를 들면, ccazzzzbb는 c, a, z, b가 모두 연속해서 나타나고, kin도 k, i, n이 연속해서 나타나기 때문에 그룹 단어이지만, aabbbccb는 b가 떨어져서 나타나기 때문에 그룹 단어가 아니다. 단어 N개를 입력으로 받아 그룹 단어의 개수를...","categories": ["Python"],
        "tags": ["Blog","algorithm","study","python","baekjoon"],
        "url": "/python/12-post/",
        "teaser": null
      },{
        "title": "[Java] 백준 10951번",
        "excerpt":"A+B - 4 두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오. 입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. (0 &lt; A, B &lt; 10) Input-1) 1 1 2 3 3 4 9 8 5 2 Output-1)...","categories": ["Java"],
        "tags": ["Blog","algorithm","study","java","baekjoon"],
        "url": "/java/13-post/",
        "teaser": null
      },{
        "title": "[Java] 백준 1110번",
        "excerpt":"Input-1) 26 Output-1) 4 Input-2) 55 Output-2) 3 접근 방식 주어진 수를 N, 새로운 수를 T라고 가정하자. N의 일의 자리가 T의 십의 자리수가 되고, N을 합한 수의 일의 자리가 T의 일의 자리수가 된다. N[0] + N[1] = T[ N[1] + (N[0]+N[1])[1] ] N과 T의 자리수를 파악할 수 있게 2칸 크기의...","categories": ["Java"],
        "tags": ["Blog","algorithm","study","java","baekjoon"],
        "url": "/java/14-post/",
        "teaser": null
      },{
        "title": "[Java] 백준 2577번",
        "excerpt":"Input-1) 150 266 427 Output-1) 3 1 0 2 0 0 0 2 0 0 접근 방식 a, b, c를 곱한 값을 arr(배열)로 가지고 있다고 하면, 0부터 9까지의 인덱스가 arr의 값과 중복되는지를 검증하여 세면 될 것이라 생각했다. 먼저 a, b, c를 곱하여 arr이라는 배열로 파싱한다. 1 2 // 세 수를...","categories": ["Java"],
        "tags": ["Blog","algorithm","study","java","baekjoon"],
        "url": "/java/15-post/",
        "teaser": null
      },{
        "title": "[Java] 백준 8958번",
        "excerpt":"Input-1) 5 OOXXOXXOOO OOXXOOXXOO OXOXOXOXOXOXOX OOOOOOOOOO OOOOXOOOOXOOOOX Output-1) 10 9 7 55 30 접근 방식 OX 퀴즈 결과 문자열을 순회하며 아래의 조건을 통해 점수를 계산하였다. 1) O인 경우 점수를 1 증가시킨다. 2) X인 경우 점수를 증가시키지 않는다. 3) 점수가 계산될 떄마다 해당 점수를 합한다. 하나의 OX퀴즈 문자열 점수 계산이 끝나고...","categories": ["Java"],
        "tags": ["Blog","algorithm","study","java","baekjoon"],
        "url": "/java/16-post/",
        "teaser": null
      },{
        "title": "[Java] 백준 4673번",
        "excerpt":"Output 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 1 3 5 7 9 20 31 42 53 64 | | &lt;-- a lot more numbers | 9903 9914 9925 9927 9938 9949 9960 9971...","categories": ["Java"],
        "tags": ["Blog","algorithm","study","java","baekjoon"],
        "url": "/java/17-post/",
        "teaser": null
      },{
        "title": "[Java] 백준 1065번",
        "excerpt":"Input-1 110 Output-1 99 Input-2 210 Output-2 105 Input-3 1000 Output-3 144 문제 풀이 문제 풀이에 앞서 한수가 무엇인지 이해가 잘 되지 않았다. 한수를 알려면 등차수열에 대해서도 알아야 한다. 한수란? 어떤 정수 A의 각 자리수가 등차수열을 이루는 수이다. 등차수열이란? 연속된 두 개의 수의 차이가 일정한 수열을 말한다. 그러면 1부터 9까지는...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/18-post/",
        "teaser": null
      },{
        "title": "[Java] 백준 2675번",
        "excerpt":"Input 2 3 ABC 5 /HTP Output AAABBBCCC /////HHHHHTTTTTPPPPP 문제 풀이 테스트케이스의 수를 T, T별로 반복할 횟수를 R, 주어진 문자열을 S, 새로운 문자열을 P라고 해보자. 여기서 테스트케이스만큼 입력받는 동안 S의 각 문자를 R번 반복한 P로 만들어 출력하면 된다. 먼저 T를 입력받고 T만큼 반복하며 입력받은 줄에서 R과 S를 추려낸다. 그리고 S의...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/19-post/",
        "teaser": null
      },{
        "title": "[Java] 백준 1157번",
        "excerpt":"Input-1 Mississipi Output-1 ? Input-2 zZa Output-2 Z Input-3 baaa Output-3 A 문제 풀이 알파벳 대소문자로된 단어가 주어지면 해당 단어의 범위는 아래와 같다. a~z 또는 A~Z 이 문제의 핵심은 문자의 인코딩 값을 다루는 것이다. 먼저 각 알파벳 별로 사용된 빈도수를 측정하기 위한 배열을 선언한다. 1 int[] alph_list = new int[26];...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/20-post/",
        "teaser": null
      },{
        "title": "[Java] 백준 2941번",
        "excerpt":"Input-1 ljes=njak Output-1 6 Input-2 ddz=z= Output-2 3 Input-3 nljj Output-3 3 문제 풀이 주어진 단어배열의 인덱스로 접근하는 방식과 주어진 단어에서 크로아티아 알파벳을 찾아 치환하는 방식 2가지로 문제를 풀어보았다. 배열의 인덱스로 접근하는 방식 배열의 인덱스별로 크로아티아 알파벳의 첫 문자와 같다면 그 다음문자도 같은 방식으로 검증해보자. 주어진 알파벳 단어를 S라 하고...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/21-post/",
        "teaser": null
      },{
        "title": "[Java] 백준 1316번",
        "excerpt":"Input-1 3 happy new year Output-1 3 Input-2 4 aba abab abcabc a Output-2 1 Input-3 5 ab aa aca ba bb Output-3 4 문제 풀이 주어진 단어를 순회하며 문자별로 그룹단어인지 검증하기 위해서는 아래의 조건이 검증되어야 한다. 문자가 중복으로 입력되었을 경우(단, 연속된 문자는 예외) 상기 조건이 충족되는 경우 그룹단어가 아닌...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/22-post/",
        "teaser": null
      },{
        "title": "[Java] 백준 1712번",
        "excerpt":"Input-1 1000 70 170 Output-1 11 Input-2 3 2 1 Output-2 -1 Input-3 2100000000 9 10 Output-3 2100000001 문제 풀이 이 문제에서 중요하게 봐야할 핵심은 아래와 같다. 주어진 수가 21억 이하의 자연수이기에 int형을 사용하면 안된다. 손익분기점이 존재하지 않으면 -1를 출력한다. 실행 속도가 0.35초 이내여야 한다. 먼저 int형의 경우 -2,147,483,648 ~...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/23-post/",
        "teaser": null
      },{
        "title": "[Java] 백준 2292번",
        "excerpt":"Input-1 13 Output-1 3 문제 풀이 이 문제는 특정 로직을 잘 파악하여 패턴을 나열하며 풀어야 한다. 먼저 1부터 N까지의 최소 루트를 구하는 것이니 N이 1일 경우엔 1이면 된다. N이 2이상일 경우에는 아래와 같은 패턴을 유추해볼 수 있다. N의 범위 벌집의 개수 최소 루트 2 ~ 7 6 2 8 ~...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/26-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level1) - 두 개 뽑아서 더하기",
        "excerpt":"Input-1 [2,1,3,4,1] Output-1 [2,3,4,5,6,7] Input-2 [5,0,2,7] Output-2 [2,5,7,9,12] 문제 풀이 이 문제를 풀때 주의할 점은 아래와 같다. 배열의 인덱스별로 더할 때 본인 인덱스와는 더할 필요가 없다. 배열의 인덱스별로 더하여 배열에 담을 때 중복값이 없어야 한다. 담은 배열을 오름차순으로 정렬해야 한다. 중첩 반복문으로 인덱스 별로 더한 값을 알 수 있는데, 본인...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/24-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level1) - 행렬의 덧셈",
        "excerpt":"Input-1 1 2 arr1 = [[1,2],[2,3]] arr2 = [[3,4],[5,6]] Output-1 1 answer = [[4,6],[7,9]] // arr1 + arr2 문제 풀이 2차원 배열을 활용해 행렬의 같은 행과 같은 열의 값을 더한 행렬을 구해야 한다. 더해질 두 행렬은 행과 열의 크기가 같기에 중첩 반복문을 활용해 행과 열만큼 반복하여 더하는 방식으로 접근하자. 바깥...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/25-post/",
        "teaser": null
      },{
        "title": "[Java] 백준 1193번",
        "excerpt":"Input-1 1 Output-1 1/1 Input-2 2 Output-2 1/2 Input-3 5 Output-3 2/2 Input-4 9 Output-4 3/2 문제 풀이 먼저 배열의 행들을 대각선으로 바라보고 접근하면 더욱 이해가 빠를 것이다. 본인은 문제를 이해하는 데도 상당히 오래 걸렸다.. 입력받은 수를 X라 하면 특정 패턴을 통해 X번째의 분수값을 찾아야 한다. X가 몇번째 행인지(몇번째 대각선...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/27-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level1) - 최대공약수와 최소공배수",
        "excerpt":"Input-1 1 n = 3, m = 12 Output-1 1 [3, 12] Input-2 1 n = 2, m = 5 Output-2 1 [1, 10] 문제 풀이 최대공약수와 최소공배수를 구하는 문제이다. 최대공약수(Greatest Common Divisor)란? 0이 아닌 두개이 상의 정수의 공통된 약수중 가장 큰 수이다. 일반적으로 푸는 방식과 유클리드 호제법을 통해 푸는...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/28-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level1) - 이상한 문자 만들기",
        "excerpt":"Input-1 “try hello world” Output-1 “TrY HeLlO WoRlD” Input-2 “ABC aBc abC “ Output-2 “Abc Abc Abc “ 문제 풀이 문제 설명을 보면 주어진 문자열은 한개 이상의 단어로 구성되어 있으며, 각 단어는 하나 이상의 공백문자로 구분된다고 한다. 각 단어별로 짝수번째 인덱스의 단어는 대문자로, 홀수번째 인덱스의 단어는 소문자로 변경된 문자열을 반환해야...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/29-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level1) - 시저 암호",
        "excerpt":"Input-1 “AB” Output-1 “BC” Input-2 “a B z” Output-2 “b C a” 문제 풀이 주어진 문자열에서 대소문자 알파벳을 하나씩 앞으로 밀어낸 알파벳을 찾아야 한다. 먼저 아래의 조건을 검증해보자. 주어진 문자열 중에서 공백값은 밀어내지 않고 그대로 담는다. 주어진 문자열 중에서 대소문자를 구분한다. // ascii code의 경우 65~90이 대문자, 97~122가 소문자 대문자...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/30-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level1) - 소수 찾기",
        "excerpt":"Input-1 10 Output-1 4 Input-2 5 Output-2 3 문제 풀이 먼저 n까지의 수 중 소수를 찾아야 한다. 소수란? 2, 3, 5, 7, 11, 13, 17 … 약수가 1과 자신 뿐인 수이다. 어떻게 소수를 구할 수 있을까? n까지의 수중에서 n보다 작은 수를 나눠지는 수가 있다면 소수가 아니다. 즉, 어떤 수의 배수이면...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/31-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level1) - 문자열 내 마음대로 정렬하기",
        "excerpt":"Input-1 strings = [sun, bed, car] n = 1 Output-1 [car, bed, sun] Input-2 strings = [abce, abcd, cdx] n = 2 Output-2 [abcd, abce, cdx] 문제 풀이 기준 문자열의 인덱스를 순서대로 본 문자열을 정렬해야 한다. 나는 소문자 전체를 돌며 검증하는 방식으로 풀었는데 다른 분의 풀이를 보고 부족함을 많이 느꼈다.....","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/32-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level1) - 가운데 글자 가져오기",
        "excerpt":"Input-1 abced Output-1 c Input-2 abcd Output-2 bc 문제 풀이 주어진 문자열의 길이가 홀수냐 짝수냐에 따라 검증방식을 다르게 접근해야 한다. 홀수일 경우 가운데 문자를 반환한다. 문자열을 순회하며 주어진 문자열의 길이를 반으로 나눈 수와 같은 수를 찾으면 된다. 짝수일 경우 가운데 2개의 문자를 반환한다. 문자열을 반으로 나눈 수의 인덱스와 인덱스+1의 수를...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/33-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level1) - 예산",
        "excerpt":"Input-1 d = [1, 3, 2, 5, 4] budget = 9 Output-1 3 Input-2 d = [2, 2, 3, 3] budget = 10 Output-2 4 문제 풀이 부서별 신청금액 배열(d)의 원소별로 예산(budget)을 어떻게 나눠줄 수 있을까? budget에서 d의 원소별로 뺼셈하여 양수인지 음수인지를 검증하면 된다. 먼저 budget에서 d 중의 작은 수부터...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/34-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level1) - 다트 게임",
        "excerpt":"문제 요구사항 1 2 3 4 5 6 7 8 9 10 1. 다트 게임은 총 3번의 기회로 구성된다. 2. 각 기회마다 얻을 수 있는 점수는 0점에서 10점까지이다. 3. 점수와 함께 Single(S), Double(D), Triple(T) 영역이 존재하고 각 영역 당첨 시 점수에서 1제곱, 2제곱, 3제곱 (점수1 , 점수2 , 점수3 )으로...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/35-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level1) - 비밀 지도",
        "excerpt":"입출력 예제 문제 풀이 두개의 배열은 모두 주어진 n만큼의 길이를 가지고 있다. 두개의 배열을 순회하며 arr1, arr2의 원소마다 2진수로 변환하면 되는데 2진수로 변환하고 다시 10진수로 변환하는 과정을 잘 고려하며 접근해야 한다. 먼저 반복문에서 두 배열의 원소를 2진수로 변환하여 합쳐보자. 1 2 3 4 5 for(int i=0; i&lt;n; i++) { String...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/36-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level1) - 체육복",
        "excerpt":"Input-1 n=5, lost=[2,4], reserve=[1,3,5] Output-1 5 Input-2 n=5, lost=[2,4], reserve=[3] Output-2 4 문제 풀이 이 문제의 경우 그리디 알고리즘을 활용하여 접근하였다. 그리디 알고리즘이란? 가장 직관적인 알고리즘 설계 패러타임 중 하나이며, 매번 단계에서 선택할 때마다 가장 좋은 답을 선택하는 기법이다. 지금 선택한 것을 앞으로의 남은 선택에 영향을 끼칠지 고려하지 않는다는 전제이며,...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/37-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level1) - 모의고사",
        "excerpt":"입출력 예시 Input-1 [1,2,3,4,5] Output-1 [1] Input-2 [1,3,2,4,2] Output-2 [1,2,3] 문제 풀이 해당 문제는 완전 탐색 알고리즘으로 접근해야 한다. 먼저 완전 탐색 알고리즘이 뭔지 알아보자. 완전탐색(브루트포스)이란? 간단히 가능한 모든 경우의 수를 다 체크해서 정답을 찾는 방법이다. 무식하게 가능한 거 다 해보겠다는 방법을 의미하며 브루트포스(Brute Force)라고도 부른다. 이 방법은 직관적이어서 이해하기...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/38-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level1) - K번째수",
        "excerpt":"입출력 예시 Input array = [1, 5, 2, 6, 3, 7, 4] commands = [[2, 5, 3], [4, 4, 1], [1, 7, 3]] Output [5, 6, 3] 문제 풀이 주어진 array 배열을 commands 2차원 배열의 각 [i,j,k] 별로 정해진 연산을 행해야 한다. 나름대로 접근방식을 정해보았다. commands 배열의 각 [i,j,k]별로 i부터...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/39-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level1) - 완주하지 못한 선수",
        "excerpt":"입출력 예시 Input-1 participant = [“leo”, “kiki”, “eden”] completion = [“eden”, “kiki”] Output-1 “leo” Input-2 participant = [“marina”, “josipa”, “nikola”, “vinko”, “filipa”] completion = [“josipa”, “filipa”, “marina”, “nikola”] Output-2 “vinko” Input-3 participant = [“mislav”, “stanko”, “mislav”, “ana”] completion = [“stanko”, “ana”, “mislav”] Output-3 “mislav” 문제 풀이 이 문제를 배열을 정렬하여...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/40-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-2) - N개의 최소공배수",
        "excerpt":"입출력 예시 Input-1 [2, 6, 8, 14] Output-1 168 Input-2 [1, 2, 3] Output-2 6 문제 풀이 문제의 핵심은 앞의 두 수를 가지고 구한 최소공배수를 가지고 다음 수와의 최소공배수를 구하는 방식으로 구해나가야 한다는 것이다. 먼저 최소공배수의 경우 두 수의 곱을 두수의 최대공약수로 나누면 된다. 최대공약수의 경우는 유클리드 호제법 함수를 통해...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/41-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-1) - 폰켓몬",
        "excerpt":"제약 사항 nums는 폰켓몬의 종류 번호가 담긴 1차원 배열입니다. nums의 길이(N)는 1 이상 10,000 이하의 자연수이며, 항상 짝수로 주어집니다. 폰켓몬의 종류 번호는 1 이상 200,000 이하의 자연수로 나타냅니다. 가장 많은 종류의 폰켓몬을 선택하는 방법이 여러 가지인 경우에도, 선택할 수 있는 폰켓몬 종류 개수의 최댓값 하나만 return 하면 됩니다. 입출력 예시...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/42-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-1) - 소수 만들기",
        "excerpt":"입출력 예시 Input-1 [1, 2, 3, 4] Output-1 1 Input-2 [1, 2, 7, 6, 4] Output-2 4 문제 풀이 조합을 활용해 nums배열 중 3개의 원소를 뽑아야 한다. 핵심은 뽑은 원소가 중복되면 안되기 때문에 앞에서부터 차례대로 원소를 뽑아보는 것이다. 3개를 뽑는다고 정해놨기 때문에 단순하게 반복문을 3번 돌면 된다. 1 2 3...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/43-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-2) - JadenCase 문자열 만들기",
        "excerpt":"입출력 예시 Input-1 “3people unFollowed me” Output-1 “3people Unfollowed Me” Input-2 “for the last week” Output-2 “For The Last Week” 문제 풀이 주어진 문자열에서 단어의 첫문자를 대문자로 바꾸어 반환해야 한다. 이 때, 첫 문자는 숫자가 아니어야 한다. 그리고 단어 중 첫 문자가 아닌 문자가 대문자일 땐 소문자로 변환해야 한다. 먼저...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/44-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-1) - 크레인 인형뽑기 게임",
        "excerpt":"상세한 문제 내용은 여기에서 확인 바랍니다. 입출력 예시 Input board = [[0,0,0,0,0],[0,0,1,0,3],[0,2,5,0,1],[4,2,4,4,2],[3,5,1,3,1]] moves = [1,5,3,5,1,2,1,4] Output 4 문제 풀이 문제 풀이를 위해 다음과 같은 아이디어를 도출하였다. 주어진 크레인 2차원 배열을 그대로 쓰는 것보단 인형뽑기를 하기 쉽도록 2차원 배열을 회전하여 활용하자. 인형뽑기하여 담는 바구니는 스택을 활용하여 구현하자. 2차원 배열 회전하기 먼저...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/45-post/",
        "teaser": null
      },{
        "title": "[Java] 백준 2869번 - 달팽이는 올라가고 싶다",
        "excerpt":"입출력예제 Input-1 2 1 5 Output-1 4 Input-2 5 1 6 Output-2 2 Input-3 100 99 1000000000 Output-3 999999901 문제 풀이 낮에 A미터를 이동하고 밤에 B미터가 미끄러지며 V미터에 도달하는데 걸리는 일수를 구해야 한다. 먼저 단순한 반복문을 활용해 코드를 작성하였다. up에 A를 더하고 B를 빼가며 목표 V에 도달했을 때의 날짜수(day)를 구하도록...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/48-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-1) - 키패드 누르기",
        "excerpt":"상세한 문제 내용은 여기에서 확인 바랍니다. 입출력 예시 Input-1 numbers = [1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5] hand = “right” Output-1 “LRLLLRLLRRL” Input-2 numbers = [7, 0, 8, 2, 8, 3, 1, 5, 7, 6, 2] hand = “left” Output-2 “LRLLRRLLLRR” Input-3 numbers = [1,...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/46-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-2) - 행렬의 곱셈",
        "excerpt":"입출력 예시 Input-1 arr1 = [[1, 4], [3, 2], [4, 1]] arr2 = [[3, 3], [3, 3]] Output-1 [[15, 15], [15, 15], [15, 15]] Input-2 arr1 = [[2, 3, 2], [4, 2, 4], [3, 1, 4]] arr2 = [[5, 4, 3], [2, 4, 1], [3, 1, 1]] Output-2 [[22, 22,...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/47-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-1) - 숫자 문자열과 영단어",
        "excerpt":"각 숫자에 대응되는 영단어 표 숫자 영단어 0 zero 1 one 2 two 3 three 4 four 5 five 6 six 7 seven 8 eight 9 nine 입출력 예시 Input-1 “one4seveneight” Output-1 1478 Input-2 “23four5six7” Output-2 234567 Input-3 “2three45sixseven” Output-3 234567 Input-4 123 Output-4 123 문제 풀이 이 문제는 두가지...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/49-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-1) - 신규 아이디 추천",
        "excerpt":"입출력 예시 Input-1 “…!@BaT#*..y.abcdefghijklm” Output-1 “bat.y.abcdefghi” Input-2 “z-+.^.” Output-2 “z–“ Input-3 ”=.=” Output-3 “aaa” Input-4 “abcdefghijklmn.p” Output-4 “abcdefghijklmn” 문제 풀이 주어진 입력문자열을 단계별로 검증하고 변경해야 한다. 그럼 단계별로 순차적으로 아이디를 검증해보자. 단계별 풀이 1단계 문자열을 순회하며 대문자가 있을 경우 소문자로 변환하여 저장하자. 1 2 3 4 5 char[] new_id_arr =...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/50-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-2) - 피보나치 수",
        "excerpt":"입출력 예시 Input-1 3 Output-1 2 Input-2 5 Output-2 5 문제 풀이 문제 풀이에 앞서 피보나치 수에 대해서 알아보자. 피보나치(Fibonnaci)란? 피보나치 수열은 0과 1로 시작하며, 앞의 두 수를 더해서 다음 수를 만들어 나가는 수열이다. F(n) = F(n-1) + F(n-2) 라는 식으로 볼 수 있다. EX) 1,1,2,3,5,8,13,12 … 피보나치 수열이 만들어지는...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/51-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-1) - 같은 숫자는 싫어",
        "excerpt":"입출력 예시 Input-1 [1,1,3,3,0,1,1] Output-1 [1,3,0,1] Input-2 [4,4,4,3,3] Output-2 [4,3] 문제 풀이 이 문제는 큐의 FIFO 특성을 활용해 풀어보았다. 주어진 배열의 원소를 순회하며 현재 수와 이전 수가 다를 경우에만 큐에 넣어둔다면 연속으로 나타난 수, 즉 중복을 제거할 수 있다. 한 번 코드로 작성해보자. 1 2 Queue&lt;Integer&gt; qu = new LinkedList&lt;&gt;();...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/52-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-1) - 최소직사각형",
        "excerpt":"입출력 예시 Input-1 [[60, 50], [30, 70], [60, 30], [80, 40]] Output-1 4000 Input-2 [[10, 7], [12, 3], [8, 15], [14, 7], [5, 15]] Output-2 120 Input-3 [[14, 4], [19, 6], [6, 16], [18, 7], [7, 11]] Output-3 133 문제 풀이 주어진 2차원 배열에서 명함의 가로와 세로길이 [w, h]에서 w와...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/53-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-2) - 최댓값과 최솟값",
        "excerpt":"입출력 예시 Input-1 “1 2 3 4” Output-1 “1 4” Input-2 “-1 -2 -3 -4” Output-2 “-4 -1” Input-3 “-1 -1” Output-3 “-1 -1” 문제 풀이 주어진 문자열의 숫자 중에서 최솟값과 최댓값을 찾아야 한다. 문자열을 순회하며 현재 수와 비교하여 가장 크고, 가장 작은 값을 구하면 된다. 한 번 코드로 작성해보자....","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/54-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-1) - 로또의 최고 순위와 최저 순위",
        "excerpt":"제한사항 lottos는 길이 6인 정수 배열입니다. lottos의 모든 원소는 0 이상 45 이하인 정수입니다. 0은 알아볼 수 없는 숫자를 의미합니다. 0을 제외한 다른 숫자들은 lottos에 2개 이상 담겨있지 않습니다. lottos의 원소들은 정렬되어 있지 않을 수도 있습니다. win_nums은 길이 6인 정수 배열입니다. win_nums의 모든 원소는 1 이상 45 이하인 정수입니다. win_nums에는...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/55-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-2) - 이진 변환 반복하기",
        "excerpt":"입출력 예시 Input-1 “110010101001” Output-1 [3, 8] Input-2 “01110” Output-2 [3, 3] Input-3 “1111111” Output-3 [4, 1] 문제 풀이 주어진 문자열이 1이 될 때까지 이진 변환을 반복해야 하기 때문에 재귀함수를 활용하여 풀어보았다. 재귀함수에서 진행해야할 이진 변환 내용을 코드로 작성해보자. 문자열의 모든 0을 제거하기 1 2 3 4 5 StringBuilder sb...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/56-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-2) - 최솟값 만들기",
        "excerpt":"입출력 예시 Input-1 A = [1, 4, 2] B = [5, 4, 4] Output-1 29 Input-2 A = [1, 2] B = [3, 4] Output-2 10 문제 풀이 A와 B 배열에서 두 수 를 뽑아 곱한 값을 누적하여 더할 때, 최소로 되도록 해야한다. 그렇다면 두 수의 차가 클 수록 곱한...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/57-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-2) - 올바른 괄호",
        "excerpt":"입출력 예시 Input-1 ”()()” Output-1 true Input-2 )()( Output-2 false 문제 풀이 이 문제의 경우 스택(Stack)으로 접근하여 푸는 것이 가장 쉽기에 스택을 활용하여 풀어보았다. 괄호만으로 이루어진 문자열을 순회하며 ”(“일 때는 스택에 “(“를 추가하고, “)”일 때는 “(“를 꺼내는 과정을 통해 스택의 empty 유무를 통해 괄호문자열을 검증할 수 있다. 한 번 코드로...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/58-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-1) - 성격 유형 검사하기",
        "excerpt":"상세한 문제 내용은 여기에서 확인 바랍니다. 입출력 예시 Input-1 survey = [“AN”, “CF”, “MJ”, “RT”, “NA”] choices = [5, 3, 2, 7, 5] Output-1 TCMA Input-2 survey = [“AN”, “CF”, “MJ”, “RT”, “NA”] choices = [5, 3, 2, 7, 5] Output-2 RCJA 문제 풀이 이 문제는 HashMap에 지표별 유형과 점수를...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/59-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-2) - 숫자의 표현",
        "excerpt":"입출력 예시 Input-1 15 Output-1 4 문제 풀이 연속된 자연수들의 합으로 n을 만들수 있을 때 몇개의 방법으로 n을 만들 수 있는지를 알아야 한다. 연속된 자연수 합과 비교하기 먼저 중첩 반복문을 활용해 i를 1~15까지 j를 i~15까지 순회하며 j를 누적해서 더한 값이 n이 된다면 연속된 자연수들로 이루어진 합이 된다. 한 번 코드로...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/60-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-2) - 다음 큰 숫자",
        "excerpt":"입출력 예시 Input-1 78 Output-1 83 Input-2 15 Output-2 23 문제 풀이 주어진 n을 2진수로 변환한 후 1의 개수를 cnt라고 하면 n+1, n+2 ••• n+n n보다 큰 수 중 2진수로 변환한 후의 1의 개수가 cnt와 같은 수를 구해야 하며, n보다 크면서 가장 작은 수여야 한다. 백문이 불여일견, 한 번 코드로...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/61-post/",
        "teaser": null
      },{
        "title": "[Java] 백준 11659번 - 구간 합 구하기 4",
        "excerpt":"입출력 예시 Input 5 3 5 4 3 2 1 1 3 2 4 5 5 Output 12 9 1 문제 풀이 이 문제는 구간 합 알고리즘을 활용해 합배열을 만들어서 풀어야 한다. 먼저 n개의 수들의 합배열을 만들어보자. 합배열 만들기 n개의 수를 5,4,3,2,1 라고 한다면, 합배열은 각 수의 합을 더해 나가면...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/62-post/",
        "teaser": null
      },{
        "title": "[Java] 백준 2018번 - 수들의 합 5",
        "excerpt":"입출력 예시 Input 15 Output 4 문제 풀이 이 문제는 주어진 n의 최댓값이 10,000,000이기에 빠른 시간복잡도를 가진 알고리즘으로 풀어야 한다. 연속된 자연수들의 합을 시작 인덱스(start_idx)와 종료 인덱스(end-idx)를 지정하여 표현해보자. 투 포인터 활용(시작인덱스와 종료인덱스) 먼저 입력받을 n과 사용할 변수들을 초기화하자. start_idx와 end_idx의 경우 1부터 n까지 탐색할 것이기에 1로 초기화한다. 그리고 cnt를...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/63-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-2) - 영어 끝말잇기",
        "excerpt":"제한사항 끝말잇기에 참여하는 사람의 수 n은 2 이상 10 이하의 자연수입니다. words는 끝말잇기에 사용한 단어들이 순서대로 들어있는 배열이며, 길이는 n 이상 100 이하입니다. 단어의 길이는 2 이상 50 이하입니다. 모든 단어는 알파벳 소문자로만 이루어져 있습니다. 끝말잇기에 사용되는 단어의 뜻(의미)은 신경 쓰지 않으셔도 됩니다. 정답은 [ 번호, 차례 ] 형태로 return...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/64-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-2) - 카펫",
        "excerpt":"제한사항 갈색 격자의 수 brown은 8 이상 5,000 이하인 자연수입니다. 노란색 격자의 수 yellow는 1 이상 2,000,000 이하인 자연수입니다. 카펫의 가로 길이는 세로 길이와 같거나, 세로 길이보다 깁니다. 입출력 예시 Input-1 brown=10 yellow=2 Output-1 [4,3] Input-2 brown=8 yellow=1 Output-2 [3,3] Input-3 brown=24 yellow=24 Output-3 [8,6] 문제 풀이 brown과 yellow의 약수를...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/65-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-1) - 신고 결과 받기",
        "excerpt":"상세한 문제 내용은 여기에서 확인 바랍니다. 제한사항 2 ≤ id_list의 길이 ≤ 1,000 1 ≤ id_list의 원소 길이 ≤ 10 id_list의 원소는 이용자의 id를 나타내는 문자열이며 알파벳 소문자로만 이루어져 있습니다. id_list에는 같은 아이디가 중복해서 들어있지 않습니다. 1 ≤ report의 길이 ≤ 200,000 3 ≤ report의 원소 길이 ≤ 21 report의...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/66-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-2) 1874번 - 스택 수열",
        "excerpt":"입출력 예시 Input 8 4 3 6 8 7 5 2 1 Output + + + + - - + + - + + - - - - - 문제 풀이 문제 제목에도 나와있듯이, 자료구조중 하나인 스택(Stack)을 활용해야 한다. 입력값마다 스택에 push 및 pop을 하여 수열을 만들 수 있는지 검증해야...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/69-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(브론즈-2) 2750번 - 수 정렬하기",
        "excerpt":"입출력 예시 Input 5 5 2 3 4 1 Output 1 2 3 4 5 문제 풀이 이 문제는 N의 범위가 최대 1,000으로 작기 때문에 버블정렬을 활용해서 풀었다. 버블정렬 풀이 버블정렬이란? 데이터의 인접요소끼리 비교하고 swqp 연산을 수행하여 정렬하는 방식이다. 주어진 배열이 [5,2,3,4,1]일때, 버블정렬을 통해 정렬되는 과정을 알아보자. 1 2 3...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/71-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-2) - 구명보트",
        "excerpt":"입출력 예시 Input-1 people = [70, 50, 80, 50] limit = 100 Output-1 3 Input-2 people = [70, 80, 50] limit = 100 Output-2 3 문제 풀이 먼저, 보트에는 단 2명만 탈 수 있다는 점을 유의해야 한다. 문제를 풀기 위한 아이디어 자체는 간단하다. 초안 아이디어 무게제한/2 을 넘는 사람이면, 한...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/67-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-2) - 멀리 뛰기",
        "excerpt":"입출력 예시 Input-1 4 Output-1 5 Input-2 3 Output-2 3 문제 풀이 나머지연산의 시점 이 문제내용을 잘 보면 “효진이가 끝에 도달하는 방법이 몇 가지인지 알아내, 여기에 1234567를 나눈 나머지를 리턴하는 함수” 를 작성해야 한다고 한다. 구한 정답에서 1234567을 MOD연산하여 반환하는것이 아니라 단계마다 MOD연산을 해야 한다고 알고 있었다. 그러니 문제를 풀어가며...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/68-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(데모) - 나머지 한 점",
        "excerpt":"입출력 예시 Input-1 v = [[1, 4], [3, 4], [3, 10]] Output-1 [1, 10] Input-2 v = [[1, 1], [2, 2], [1, 2]] Output-2 [2, 1] 문제 풀이 이 문제는 직사각형에서 3개의 좌표를 가지고 나머지 한 좌표를 구해야 한다. 조건문 및 비트연산자를 활용하여 풀어봤다. 1. 조건문 활용 조건문을 활용한 풀이는...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/70-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-2) - H-index",
        "excerpt":"입출력 예시 Input-1 citations = [3, 0, 6, 1, 5] Output-1 3 문제 풀이 문제 풀이에 앞서 H-index가 뭔지 짚고 넘어가자. h-index란? 위키피디아에 기재된 내용을 보면 “h-index는 주어진 저자/저널이 각각 최소 h회 인용된 최소 h개의 논문을 출판 한 h의 최대값으로 정의됩니다.” 라고 한다. 위키피디아 내용을 보면 내림차순으로 정렬된 배열이 있어야...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/72-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-2) - 전화번호 목록",
        "excerpt":"입출력 예시 Input-1 phone_book = [“119”, “97674223”, “1195524421”] Output-1 false Input-2 phone_book = [“123”,”456”,”789”] Output-2 true Input-1 phone_book = [“12”,”123”,”1235”,”567”,”88”] Output-1 false 문제 풀이 이 문제는 처음엔 이중 반복문으로 풀어봤는데 효율성 테스트에서 시간초과가 발생되어 반복문을 한 번만 돌려서 해결해야 했다. 또한 phone_book의 각 원소들의 접두사 포함여부를 검증하기 위해 contains나 indexOf를...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/73-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(브론즈-2) 10250번 - ACM 호텔",
        "excerpt":"입출력 예시 Input 2 6 12 10 30 50 72 Output 402 1203 문제 풀이 이 문제는 조건식을 잘 세워야 한다. 호텔의 방을 배정할 조건을 정해보자. 엘리베이터에서 가까운 순으로 방을 배정한다. 거리가 같다면, 낮은 층수부터 방을 배정한다. 아래 예시를 보면 빠르게 이해할 수 있다. 방 번호의 경우 YYX 또는 YYXX...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/74-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(브론즈-1) 2275번 - 부녀회장이 될테야",
        "excerpt":"제한 사항 1 ≤ k, n ≤ 14 입출력 예시 Input 2 1 3 2 3 Output 6 10 문제 풀이 이 문제는 주어진 k,n을 가지고 k층에 n호에 몇명이 거주하는지 구해야 한다. 0층에는 i호에 i명이 거주함을 보고 0층부터 k층의 n호까지 구해나가야 함을 알 수 있다. k층의 n호는 전층 즉, k-1층의...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/75-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-2) - 예상 대진표",
        "excerpt":"입출력 예시 Input N=8, A=4, B=7 Output 3 문제 풀이 이 문제는 토너먼트에서 경쟁자인 a와 b가 몇번째 라운드에서 만나는지 구해야 한다. 2명씩 대전해가며 특정 라운드에서 서로 만나려면 a가 b보다 1크거나, 1작아야 한다. 어떤 상황에서 a가 b보다 1이 작거나, 1이 클수가 있을까? a가 짝수라면 a-1의 수가 b이어야 한다. a가 홀수라면 a+1의...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/76-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-4) 2839번 - 설탕 배달",
        "excerpt":"입출력 예시 Input-1 18 Output-1 4 Input-2 6 Output-2 2 Input-3 11 Output-3 3 문제 풀이 이 문제는 반복문과 조건문을 활용한 두 가지 방식으로 풀어보았다. 이 문제의 핵심은 N이 5의 배수로 이루어질 때 봉지의 수가 최소가 된다는 점이다. 그리고 N이 4일 때와 7일 때는 애초에 봉지의 개수를 구할 수 없기에...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/77-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(브론즈-5) 10757번 - 큰 수 A+B",
        "excerpt":"입출력 예시 Input 9223372036854775807 9223372036854775808 Output 18446744073709551615 문제 풀이 이 문제에서 주어지는 입력값의 경우 최대 10의 10000승으로 일반적으로 큰 값에 활욛되는 long 타입의 범위를 초과한다. 문자열을 입력받아 직접 덧셈을 구현하는 방식과 BigInteger 클래스를 활용하는 방식 두가지로 풀어보았다. BigInteger 활용 보통 정수는 int를 많이 사용하고, int의 표현 범위를 넘어서면 long형을 사용해야...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/78-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-5) 1978번 - 소수 찾기",
        "excerpt":"입출력 예시 Input 4 1 3 5 7 Output 3 문제 풀이 이 문제는 주어진 N개 수중에서 소수의 개수를 구해야 한다. 소수 자체를 찾는건 어느 정도 공부하였으니, 각 N마다 소수인지를 판별하면 된다. 소수는 1과 자기 자신만을 약수로 가지기 때문에, N이 1과 자기 자신으로만 나누어 떨어지면 소수이다. 그렇다면 코드를 작성해보자. 1...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/80-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-2) - 점프와 순간 이동",
        "excerpt":"입출력 예시 Input-1 5 Output-1 2 Input-2 6 Output-2 2 Input-3 5000 Output-3 5 문제 풀이 이 문제는 N의 범위가 최대 10억이기에 효율성을 잘 고려해야 한다. n을 2로 나눠가며 건전지 카운트를 세는 방식과 n을 2진수로 변환한 후 1의 개수를 세는 두가지 방식으로 풀어보았다. 먼저 문제에서 순간이동하고 K번 점프하는 패턴을 살펴보자....","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/79-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-2) - 캐시",
        "excerpt":"입출력 예시 Input-1 cacheSize=3, cities=[“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”, “Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”] Output-1 50 Input-2 cacheSize=3, cities=[“Jeju”, “Pangyo”, “Seoul”, “Jeju”, “Pangyo”, “Seoul”, “Jeju”, “Pangyo”, “Seoul”] Output-2 21 Input-3 cacheSize=0, cities=[“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”] Output-3 25 문제 풀이 문제를 풀기에 앞서 캐시와 캐시 교체 정책에 대해서 알아보자. 캐시란?...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/81-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-5) 2581번 - 소수",
        "excerpt":"입출력 예시 Input-1 60 100 Output-1 620 61 Input-2 64 65 Output-2 -1 문제 풀이 이 문제는 간단하게 M부터 N까지의 수중에서 소수를 찾아, 소수 중 최소값과 소수들의 합을 구하면 된다. ArrayList를 활용하여 소수들을 찾아 담아 최소값과 소수의 합을 구할 수 있다. 코드를 작성해보자. 1 2 3 4 int M =...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/82-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(브론즈-1) 11653번 - 소인수분해",
        "excerpt":"입출력 예시 Input-1 72 Output-1 2 2 2 3 3 Input-2 9991 Output-2 97 103 문제 풀이 문제를 풀기 앞서 소인수분해가 뭔지 알아보자. 소인수분해란? 1보다 큰 자연수를 소인수(소수인 인수)들만의 곱으로 나타내는 것 또는 합성수를 소수의 곱으로 나타내는 방법을 말한다. 쉽게 말하자면 소수들의 곱으로 어떠한 수를 표현하는 것이다. 1 2 3...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/83-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-3) 1929번 - 소수 구하기",
        "excerpt":"입출력 예시 Input 3 16 Output 3 5 7 11 13 문제 풀이 이 문제에서는 M과 N의 범위(최대 1,000,000) 및 제한 시간(2초)을 생각했을 때 완전탐색을 활용해 2부터 하나하나 나눠보는 것은 O(N^2)의 시간복잡도를 기지므로 시간초과가 발생하게 된다. 완전탐색 보다는 소수를 구할 때 효울적인 ‘에라토스테네스의 체’ 알고리즘을 활용해야 한다. 에라토스테네스의 체를 활용해...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/84-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-3) 4948번 - 베르트랑 공준",
        "excerpt":"입출력 예시 Input 1 10 13 100 1000 10000 100000 0 Output 1 4 3 21 135 1033 8392 문제 풀이 먼저 베르트랑 공준이 무엇인지 궁금하여 찾아보았다. 베르트랑 공준이란? 2 이상의 임의의 정수 n에 대해서 아래 식을 만족하는 소수 p는 항상 존재한다. 1 n &lt; p &lt; 2n 문제에서는 베르트랑...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/85-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-2) 9020번 - 골드바흐의 추측",
        "excerpt":"입출력 예시 Input 3 8 10 16 Output 3 5 5 5 5 11 문제 풀이 골드바흐의 추측이 뭔지 위키를 찾아보았다. 골드바흐의 추측이란? 이전부터 알려진 정수론의 미해결 문제로, 2보다 큰 모든 짝수는 두 개의 소수의 합으로 표시할 수 있다는 것이다. 이때 하나의 소수를 두 번 사용하는 것을 허용한다. 골드바흐의 강한...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/86-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-5) 2751번 - 수 정렬하기 2",
        "excerpt":"입출력 예시 Input 5 5 4 3 2 1 Output 1 2 3 4 5 문제 풀이 이 문제는 sort() 메소드를 이용해 오름차순 정렬을 해야 한다. 먼저 단순하게 Arrays.sort() 메소드를 이용해 문제를 풀어보니, 정답 처리가 되었다. Arrays.sort()의 정답처리? 이전의 백준에서는 Java, Java(Open JDK), Java11로 언어 분류가 나뉘어 있었는데, 최근에 Java가...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/87-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(브론즈-1) 10989번 - 수 정렬하기 3",
        "excerpt":"입출력 예시 Input 10 5 2 3 1 4 2 3 5 1 7 Output 1 1 2 2 3 3 4 5 5 7 문제 풀이 문제에서 요구하는 시간제한은 3초이다. Arrays.sort() 메소드를 이용해도 풀 수 있지만, 시간 제한은 마지노선으로 보인다. 그래서 정렬 알고리즘 중에서 O(n)으로 가장 빠른 시간복잡도를 가지는...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/88-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(브론즈-2) 25305번 - 커트라인",
        "excerpt":"입출력 예시 Input 5 2 100 76 85 93 98 Output 98 문제 풀이 문제의 요구사항을 잘 보면 주어진 점수들을 내림차순으로 정렬한 후 k번째 점수를 구해야 한다. 여기서 주어진 점수들을 내림차순으로 정렬하는 것이 핵심이다. 내림차순으로 정렬하는 다양한 방식 중에서 int 배열을 이용한 방식과 Integer 배열을 이용한 방식 두가지로 풀어보았다. int...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/89-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-3) 2108번 - 통계학",
        "excerpt":"입출력 예시 Input-1 5 1 3 8 -2 2 Output-1 2 2 1 10 Input-2 5 -1 -2 -3 -1 -2 Output-2 -2 -2 -1 2 문제 풀이 N개의 수들을 입력받아 산술평균, 중앙값, 최빈값, 범위 총 4가지를 구해야한다. 위 4가지 연산결과를 구하기 위해 N개의 수를 배열에 저장해두자. 유의할 점은 N개의...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/90-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-5) 1427번 - 소트인사이드",
        "excerpt":"문제 풀이 이 문제는 쉽게 풀 수 있었다. 단순하게 주어진 N의 각 자리수별로 저장한 후 내림차순으로 정렬하면 된다. 생각해낸 아이디어는 다음과 같다. charAt() 메서드를 활용하여 N의 자리수별로 접근하자. 자리수별로 int 형으로 형변환하여 별도의 배열에 저장한다. N의 자리수별로 저장된 배열을 내림차순으로 정렬한다. 그럼 코드를 작성해보자. 1 2 3 4 5 6...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/91-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-5) 11650번 - 좌표 정렬하기",
        "excerpt":"문제 풀이 문제를 보고 먼저 2차원 배열을 이용할 수 있다고 느꼈다. 그런데 2차원 배열을 정렬할 때 Arrays.sort() 로는 정렬할 수 없기에 다른 방법을 찾아야 했다. 2차원 배열을 정렬하는 방법을 찾아보니, Arrays.sort() 메서드를 확장하여 람다식을 이용해야 함을 알게되었다. 람다식이란? 람다 함수라고도 불리는 람다식은 프로그래밍 언어에서 사용되는 개념으로 익명 함수(Anonymous functions)를 지칭하는...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/92-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-5) 11651번 - 좌표 정렬하기 2",
        "excerpt":"문제 풀이 이 문제는 이전 문제인 11650번 좌표 정렬하기 문제를 조금 변형하여 풀 수 있다. 11650번 문제는 x, y 좌표가 있을 때 x좌표를 기준으로 오름차순 정렬하였지만, 이 문제는 y좌표를 기준으로 오름차순 정렬을 해야한다. 동일하게 Arrays.sort() 메서드를 확장하여 Comparator 메서드를 람다식으로 표현하여 작성하는데, 두 원소를 비교할 때 첫번째 원소 기준이 아닌...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/93-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-5) 1181번 - 단어 정렬",
        "excerpt":"문제 풀이 이 문제를 풀기 위해 생각한 아이디어는 다음과 같다. 길이가 짧은 순 정렬 -&gt; 같은 길이의 단어는 사전 순 정렬 -&gt; 중복 제거 -&gt; 출력 Arrays.sort() 함수는 두 객체를 비교하여 위치 정렬을 하는데, 특정 규칙을 만들어 비교하기 위해서 앞서 많이 사용하였던 Comparator를 활용하려 한다. 입력받은 단어들을 String 배열에 담아서...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/94-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-5) 10814번 - 나이순 정렬",
        "excerpt":"문제 풀이 나이 순으로 정렬하면서 나이가 같은 사람일 경우 먼저 입력받은 순으로 정렬해야 한다. 여기서 주의 할 점은 나이가 같을 때 입력받은 순으로 정렬해야 한다는 점이다. 이 문제는 2차원 배열을 이용하여 정렬하는 방법과 클래스 객체를 통해 정렬하는 방법 두가지 방식으로 풀어보았다. 두 풀이 모두 Arrays.sort() 함수를 확장하여 Comparator의 compare 메소드를...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/95-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-2) 18870번 - 좌표 압축",
        "excerpt":"문제 풀이 좌표 압축이라고 해서 문제 내용을 이해하는데 시간이 좀 걸렸지만, 테스트케이스를 보고서 유추를 할 수 있었다. 바로 원소들의 순위를 매겨 정해진 순위를 출력하는 것이다. 예시를 들어서 보면 이해하기 아주 쉽다. 1 2 3 4 5 6 arr = [2,4,-10,4,-9] -10: 0순위 -9: 1순위 2: 2순위 4: 3순위 4: 3순위...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/96-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(브론즈-5) 10872번 - 팩토리얼",
        "excerpt":"문제 풀이 이 문제는 재귀 알고리즘으로 접근해야 한다. 재귀란? 자신을 정의할 때 자기 자신을 다시 참조하는 방식을 재귀라고 한다. 재귀를 구현하며 유의할 점 재귀가 반복적으로 호출되면 자바에서는 Stack OverFlow 에러가 발생하게 된다. 재귀함수는 반복적으로 호출하는 만큼 메모리를 차지하기 때문에 매우 느리기 때문에 재귀함수는 평상시 자주 쓰이지는 않는다. 재귀 함수의 종료...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/97-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-4) 24060번 - 병합정렬 1",
        "excerpt":"문제 풀이 문제 풀기에 앞서 병합정렬에 대해서 알아보자. 병합정렬이란? 기본적으로 분할 정복 알고리즘을 기반하여 정렬하는 방식으로 문제를 분할하고, 분할한 문제를 정복하여 병합하는 과정이다. 원소가 저장되어 있는 배열을 계속 쪼개서 길이가 1인 배열을 만들고, 이후 정렬하면서 합치는 알고리즘이다. 병합정렬 과정 주어진 배열을 절반으로 분할한다. 즉 부분배열로 나눈다. 부분배열의 길이가 1이 될...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/100-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(브론즈-2) 10870번 - 피보나치 수 5",
        "excerpt":"문제 풀이 피보나치 수란 첫번째 항 0과 두번째 항 1부터 시작하여 앞 두수의 합으로 다음 수를 만들어 나가는 수열이다. 이번 피보나치 수 5 문제도 재귀함수 및 반복문을 활용하여 두가지 방식으로 풀어보았다. 피보나치 수에 대한 내용은 이전에 풀었던 피보나치 수 문제 에서 확인할수 있다. 재귀함수 활용하기 피보나치 수는 첫번째 항과 두번째...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/98-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(브론즈-2) 25501번 - 재귀의 귀재",
        "excerpt":"문제 풀이 이 문제는 팰린드롬은 앞에서부터 읽었을 때, 뒤에서부터 읽었을 때가 같은 문자열인데, 주어진 테스트케이스마다 문자열이 팰린드롬인지 확인하고, 팰린드롬인지 판별하는 함수가 몇번 호출되었는지를 구해야 한다. 문제 힌트로 함수 코드를 제공하기 때문에 단순하게 팰린드롬 판별 함수인 recursion 함수의 호출 횟수만 구하면 된다. recursion 함수 호출 횟수를 구하기 위해선 함수가 실행될 때마다...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/99-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-1) 11729번 - 하노이의 탑 이동 순서",
        "excerpt":"문제 풀이 하노이의 탑에서 원판을 이동시키는 원리는 워낙 유명했지만 잘 기억이 안나서 다시 찾아보았다. 하노이의 탑 원판 이동 조건 하노이의 탑은 위 그림과 같이 크기 가 다른 원반이 한 기둥에 놓여져 있고 원반을 모두 왼쪽에서 오른쪽으로 옮겨야 한다. 원반은 큰 것이 아래로 가게 쌓아야 하며 작은 원반 위에 큰 원반이...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/101-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-1) 2447번 - 별 찍기 - 10",
        "excerpt":"문제 풀이 *로 이루어진 사각형의 패턴이 무엇인지 파악해보자. N이 3이라면 가운데 한칸이 공백인 사각형을 나타냄을 알 수 있다. 1 2 3 4 N=3 *** * * *** 그러면 N이 3보다 큰 거듭제곱일 경우는 어떨까? N이 9일 경우와 27일 경우에 별이 출력되는 패턴을 살펴보자. (보기 편하도록 * 사이에 공백을 추가한 사진을...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/102-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-1) - 삼총사",
        "excerpt":"문제 풀이 int형 배열 numbers에서 3개의 원소를 뽑아 합이 0일 경우에만 카운트를 하면 되는 문제이다. 간단한 조합공식을 활용해서 3개의 수를 뽑을 수 있다. 조합을 활용해 접근할 수 있는 아이디어를 생각해보자. 문제에서 3개의 수를 뽑는다고 정해놨기 때문에 단순하게 반복문을 3번 돌면 된다. 뽑은 수를 또 뽑으면 안되니(중복되면 안됨) 앞에서부터 차례대로 뽑으면...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/103-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-1) - 숫자 짝꿍",
        "excerpt":"문제 풀이 주어진 X와 Y 문자열에서 공통되는 문자들을 찾아 가장 큰 수로 만들어야 한다. 초기 아이디어 도출 X와 Y를 각각 순회하며 동일한 값들을 별도로 저장한다. 이 때, 연속으로 같은 수가 올 수 있음을 염두해야 한다. 별도로 저장한 문자들을 가장 큰 수, 즉 내림차순으로 만들어 반환한다. 먼저 X와 Y에서 동일한 문자를...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/104-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(브론즈-2) 2798번 - 블랙잭",
        "excerpt":"문제 풀이 이 문제는 브루트포스, 즉 완전탐색 알고리즘을 활용하여 푸는 대표적인 문제라고 한다. 완전탐색 알고리즘은 가능한 모든 경우의 수를 다 체크해서 정답을 찾는 방법이다. 아이디어 도출 N개의 카드중에서 3장을 택하여 M과 같거나 가장 가까운 수를 만들어야 한다. M과 같거나 근접한 수를 만들기 위해 생각한 아이디어는 다음과 같다. N개의 카드들 중에서...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/105-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(브론즈-2) 2231번 - 분해합",
        "excerpt":"문제 풀이 이 문제는 완전탐색 알고리즘을 활용하여 N의 생성자가 되는 모든 경우를 탐색해야 한다. N까지의 수들 중에서 [자기 자신 + 자기 자신의 각 자리수의 합] 이 N이 되는 수를 찾으면 된다. 아이디어 도출 N의 범위는 1부터 1,000,000 이기에 1부터 N까지 순회하며 분해합을 통해 N을 만들 수 있는 수를 찾는다. N의...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/106-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-5) 7568번 - 덩치",
        "excerpt":"문제 풀이 이 문제는 N명의 키와 몸무게를 통해 덩치 순위를 구해야한다. 처음엔 HashMap으로 풀다가, 문제 요구사항을 보니 같은 키와 같은 몸무게를 가진 사람도 입력으로 받을 수 있어 같은 키를 가질 수 없는 HashMap이 아닌 2차원 배열을 활용하여 풀었다. 아이디어 도출 2차원 배열에서 N명의 키와 몸무게를 통해 덩치를 구하는 아이디어를 생각해보았다....","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/107-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-4) 1018번 - 체스판 다시 칠하기",
        "excerpt":"자세한 테스트케이스 데이터는 문제링크를 참고하자. 문제 풀이 이 문제는 이해하는 것부터 어려움이 있었다. 8X8 크기의 정사각형을 아무데서나 골라서 가장 적게 칠해야할 횟수를 구해야 하는데 잘 생각해보니 결국 NXM 크기의 정사각형에서 8X8 크기의 정삭각형 범위만큼 탐색해야 했다. 모든 8X8 정사각형을 탐색하면서 블랙체스판일 때 칠해야할 횟수와 화이트체스판일 때 칠해야할 횟수를 비교하여 더...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/108-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-4) 1436번 - 영화감독 숌",
        "excerpt":"문제 풀이 이 문제는 단순하게 생각하면 더 쉽게 풀 수 있다. 먼저 N의 범위는 1&lt;=N&lt;=10000이며 N번째로 큰 “666”이 포함되는 수를 찾아야 한다. 초기 아이디어 완전탐색 알고리즘을 활용한다. N 번만큼 반복하며 666부터 1씩 증가시키며, “666”이 포함되는 수를 찾는다. 이제 코드를 작성해보자. 1 2 3 4 5 6 7 int N =...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/109-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-1) - 콜라 문제",
        "excerpt":"자세한 문제 내용은 콜라 문제 링크를 참고하자. 문제 풀이 이 문제는 나눗셈과 나머지연산을 잘 활용하면 쉽게 풀 수 있다. 먼저 어떤 패턴으로 답을 요구하는지 알아보자. 문제의 이미지를 보면 20병을 가져가서 10병을, 10병을 가져가서 5병을, 5병을 가져가서 2병을(나머지 1병이 남음), 2병을 가져가서 1병을 가져와 남은 1병과 함께 다시 1병을 받아온다. 잘...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/110-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-5) 10815번 - 숫자 카드",
        "excerpt":"문제 풀이 M개의 확인해야할 카드 중에서 N개의 카드들이 존재하는지 확인해야 한다. 나는 O(1)의 시간복잡도를 가지는 HashSet을 활용하여 N개의 카드중에 M개의 카드 각각이 존재하는지 여부를 따져서 정답을 낼 수 있었다. 이 문제는 선형탐색을 이용하면 시간복잡도가 O(n) 이기에 시간초과가 발생한다고 한다. 그렇기에 시간복잡도가 O(nlogn)인 이분탐색을 활용해야 한다고 한다. 그래서 이번 문제는 HashSet과...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/111-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-3) 14425번 - 문자열 집합",
        "excerpt":"문제 풀이 이 문제는 문자열 배열과 HashMap을 활용하는 두 가지 방식으로 풀어보았다. 요구되는 아이디어는 단순한 편이라고 생각이 들었다. 아이디어 도출 N개의 문자열을 별도의 집합 S로 저장한다. M개의 문자열을 입력받으며 집합 S에 포함되는지 확인한다. 문자열 배열 활용 먼저 단순하게 N개의 문자열을 입력받아 집합 S를 만들고 M개의 문자열을 입력받으며 S에 존재하는지 확인하면...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/112-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-4) 1620번 - 나는야 포켓몬 마스터 이다솜",
        "excerpt":"문제 풀이 이번 문제는 입력받은 포켓문 문자열과 포켓몬 번호가 쌍으로 존재해야 한다. 여기선 HashMap을 활용하면 포켓몬 이름과 번호를 쉽게 쌍으로 연결지어 만들 수 있다. 아이디어 도출 시간제한은 2초, N의 범위는 최대 10만개, M의 범위도 최대 10만개로 이중 for문을 사용할 경우 시간제한이 발생할 가능성이 높다. N개의 포켓몬 문자열을 입력받으며 포켓몬 이름...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/113-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-4) 10816번 - 숫자 카드 2",
        "excerpt":"문제 풀이 이번 문제는 이전에 풀었던 숫자 카드 문제에서 확장된 문제이다. 이분탐색을 활용해 푸는 대표적 방법도 있겠지만, 아직 이분 탐색에 대해서 제대로 공부가 되지 않아 HashMap을 활용해 풀어보았다. 아이디어 도출 입력으로 받는 N개의 숫자 카드를 나온 횟수별로 HashMap에 숫자카드를 key값으로, 횟수를 value값으로 쌓는다. M개의 숫자 카드를 입력받으며 HashMap에 존재하는 값이라면...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/114-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-4) 1764번 - 듣보잡",
        "excerpt":"문제 풀이 이번 문제는 N명의 듣도 못한 사람과 M명의 보도 못한 사람 중에서 중복되는 사람의 명수와 사람을 나열해서 출력해야 한다. 입출력 테스트케이스를 유심히 보면 첫째줄엔 듣보잡의 수와 명단을 사전순으로 출력해야 함을 주의해야 한다. 아이디어 도출 이분탐색을 활용하여 N명과 M명의 사람중에서 중복된 사람을 찾는다. 중복된 사람을 별도의 리스트로 저장해두고, 오름차순(사전순)으로 정렬한다....","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/115-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-4) 1269번 - 대칭 차집합",
        "excerpt":"문제 풀이 이번 문제는 집합과 맵 카테고리인만큼, HashMap을 활용한다면 손쉽게 풀 수 있다. 두 집합 A, B를 HashMap으로 받아서 서로의 중복원소를 카운트하면 대칭 차집합 원소 개수를 구할 수 있다. 아이디어 도출 두개의 A와 B 집합을 HashMap으로 만든다. (key값은 입력값, value값은 0) A에서 B를, B에서 A를 비교하여 중복원소를 카운트하여 value값을 카운트한다....","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/116-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-3) 11478번 - 서로 다른 부분 문자열의 개수",
        "excerpt":"문제 풀이 주어진 문자열에서 부분 문자열을 탐색해가며 서로 다른 부분 문자열의 개수만 세어야 한다. 서로 다른 부분 문자열만 센다는 것은 중복되는 부분 문자열은 세지 않는다는 것과 동일하다. 아이디어 도출 주어진 문자열 S의 모든 부분 문자열이 만들어지는 경우를 탐색하며 부분 문자열을 구한다. 구한 부분 문자열을 HashSet에 저장해가며 중복을 제거한다. 이중 for문...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/117-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(브론즈-2) 2587번 - 대표값2",
        "excerpt":"문제 풀이 문제의 요구사항은 주어진 5개의 값들의 평균값과 중앙값을 구하는 것이다. 값들을 더해 평균을 구하고 값들이 정렬된 상태에서 중앙값을 구하는 것은 크게 어렵지 않다. 아이디어 도출 주어진 5개의 값들을 배열로 만든다. 5개의 값들을 더하고, 5로 나누어 평균값을 구한다. 5개의 값이 들어있는 배열을 오름차순으로 정렬하고, 세번째 인덱스로 접근하여 중앙값을 구한다. 아이디어는...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/118-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(브론즈-5) 2738번 - 행렬 덧셈",
        "excerpt":"문제 풀이 2차원 배열 분야가 부족한 것 같아 2차원 배열 카테고리의 문제를 풀어보기로 하였다. 이번 문제는 2차원 배열을 활용해 A 행렬과 B 행렬의 덧셈 연산을 하면 된다. 아이디어 도출 공백 기준으로 입력받은 A 행렬과 B 행렬의 값을 각각 2차원 배열로 만들어 저장한다. 이중 for문을 통해 A, B 행렬을 순회하며 각...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/119-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(브론즈-3) 2566번 - 최댓값",
        "excerpt":"문제 풀이 9X9 격자판 크기에 주어지는 값들 중 최댓값을 찾고, 최댓값이 어느 행, 어느 열에 위치하는지를 구해야 한다. 중첩 반복문으로 2차원 배열을 활용해 접근하면 손쉽게 알아낼 수 있다. 아이디어 도출 격자판에 주어지는 9X9 크기의 입력값들을 2차원 배열에 저장한다. 위에서 만든 2차원 배열을 순회하며 최댓값을 찾는다. 아이디어대로 코드를 작성해보자. 1 2...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/120-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-5) 2563번 - 색종이",
        "excerpt":"문제 풀이 이 문제는 최대한 단순하게 풀기 위한 아이디어를 생각해야 한다. 처음엔 주어진 x와 y 좌표마다 +10을 한 후 뺄셈한 결과가 10 이상이어야 하는 등 복잡한 조건을 걸어야 한다고 생각했지만, 더 쉽게 풀 수 있는 방법이 있었다. 바로 100X100 크기의 도화지에서 색종이가 붙여진 자리마다 마킹을 하여 마킹한 자리의 갯수를 세면...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/121-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-1) - 푸드 파이트 대회",
        "excerpt":"문제 풀이 문재의 지문은 어려워 보이지만 테스트케이스를 잘 보면 쉽게 풀 수 있다. 요구하는 내용을 잘 살펴보면 1번, 2번, 3번 음식을 몇 번 먹었는지를 ‘데칼코마니’처럼 “0”을 사이에 두고 출력하면 된다. 아이디어 도출 food 배열의 1번째 음식인 1번째 원소부터 2명이서 나누어 먹을 수 있는지를 확인하며 남는 음식은 신경쓰지 않고 2명에게 분배한다....","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/122-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-1) - 옹알이 (2)",
        "excerpt":"문제 풀이 이 문제는 주어진 옹알이 단어중에서 “aya”, “ye”, “woo”, “ma” 4가지 조합의 발음만을 하는지를 검증해야 한다. 위의 4가지 발음이 연속으로 조합된다거나, 단어 사이에 조합된다면 올바른 발음이 되지 않음을 유의해야 한다. 최초 아이디어 도출 옹알이 단어 배열을 두어, 주어진 발음에서 옹알이 단어가 나오는지 확인한다. 또한, 연속으로 옹알이 단어가 나오는지 확인하기...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/123-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-4) 10828번 - 스택",
        "excerpt":"자세한 입출력 테스트케이스는 문제 링크를 참고하자. 문제 풀이 이 문제는 스택의 각종 기능을 활용해 스택에 데이터를 삽입 및 추출하면 된다. 복잡한 로직 없이 순수한 스택의 기능만으로 쉽게 구현이 가능하다. 아이디어 도출 주어지는 명령어대로 스택을 처리하면 된다. 명령어에 “push” 문자열이 있다면 “push [num]”의 num 값을 스택에 삽입한다. 이 때 별도로 출력할...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/124-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-4) 10773번 - 제로",
        "excerpt":"자세한 입출력 테스트케이스는 문제 링크를 참고하자. 문제 풀이 이번 문제는 스택의 후입 선출(LIFO) 구조를 활용하면 손쉽게 풀 수 있다. K개의 주어지는 정수가 0 이상이면 스택에 저장하고, 0이라면 맨 위 값을 추출하면 된다. 아이디어 도출 주어지는 정수가 0보다 크면 스택에 삽입한다.(push연산) 주어지는 정수가 0이라면 스택에서 추출한다.(pop연산) 모든 정수 입력이 끝나면 스택에...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/125-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-4) 9012번 - 괄호",
        "excerpt":"자세한 입출력 테스트케이스는 문제 링크를 참고하자. 문제 풀이 이번 문제는 주어지는 괄호문자열의 짝이 맞는지를 확인해야 한다. 스택을 활용하면 단일 괄호 문자열의 짝이 맞는지 쉽게 구할 수 있다. 아이디어 도출 주어지는 괄호 문자열을 순회하며 여는 괄호 “(“가 주어지면 스택에 삽입하고 닫는 괄호 “)”가 주어지면 스택에서 추출한다. 이 때, 닫는 괄호가 나오면...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/126-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-4) 4949번 - 균형잡힌 세상",
        "excerpt":"문제 풀이 이번 문제는 괄호 문자열에서 괄호 종류가 “(“와 “[“로 두가지이다. 단일 괄호 문자열과 비교하면 서로 다른 괄호의 짝이 맞는지를 검증해야한다. 아이디어 도출 ”(“는 “)”를 value값으로, “[“는 “]”를 value값으로 가지는 Map을 미리 만들어둔다. 개행 기준으로 주어지는 문자열에서 “(“나 “[“가 나온다면 스택에 삽입한다. ”)”가 나온다면 현재 닫혀야할 괄호가 “)”가 맞는지, “]”가...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/127-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-4) 18258번 - 큐 2",
        "excerpt":"문제 풀이 이제 큐,덱 카테고리 문제를 풀기 시작했다. 스택과 더불어 큐 문제 풀 때는 구현과정이 직관적(?)으로 느껴져 재밌게 풀고 있는 것 같다. 이번 문제는 시간 제한이 1초로 빡센 편이니 Scanner보다는 BufferedReader 및 BufferedWriter를 활용하는게 시간 단축에 조금이나마 도움이 되지 않을까 생각한다. 일단 큐(Queue)에 대한 원리를 어느 정도 알고 있어야 한다....","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/128-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-4) 2164번 - 카드2",
        "excerpt":"문제 풀이 이번 문제는 큐의 선입선출(FIFO) 기능을 알고 활용할 줄 알면 쉽게 풀 수 있다. 아이디어 도출 N을 입력받으면 1부터 N까지의 수를 Queue에 삽입한다. 큐의 삽입된 값이 1개가 될 때까지 아래 작업을 수행한다. front(맨앞의 수)를 하나 삭제한다. front(새로운 맨앞의 수)를 추출하여 새로 삽입한다. 위 과정을 반복하며 큐의 값이 1개가 된다면...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/129-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(브론즈-1) 1257번 - 팰린드롬수",
        "excerpt":"문제 풀이 이 문제는 주어지는 문자열 수들을 데칼코마니 방식으로 접근하면 쉽게 풀 수 있다. 말 그대로 첫번째 인덱스 문자와 마지막 인덱스 문자를 비교하고 그 다음 인덱스들을 비교하는 방식으로 검증하며 이 인덱스가 다르면 팰린드롬 수가 아니라고 판단하면 된다. 아이디어 도출 “0”을 입력받으면 입력을 종료한다. 첫번째 인덱스와 마지막 인덱스부터 비교하기 위해 주어진...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/130-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(브론즈-2) 2920번 - 음계",
        "excerpt":"문제 풀이 이 문제는 ascending 계열과 descending 계열 두가지 패턴으로 주어졌을 때만 고려하면 된다. 아이디어 도출 ascending 계열 [1,2,3,4,5,6,7,8]과 descending 계열 [8,7,6,5,4,3,2,1] 두 가지 방식을 공백없는 문자열로 생성한다. 주어진 문자열과 ascending 문자열을, descending 문자열을 비교한다. 두 문자열과 다르다면 mixed를 출력하고 ascending 문자열과 같다면 ascending을, descending 문자열과 같다면 descending을 출력한다. 1...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/131-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-4) 1920번 - 수 찾기",
        "excerpt":"문제 풀이 이번 문제는 시간 제한이 1초이고, 주어지는 정수의 범위가 2의 31승 정도로 굉장히 크다. 그렇기에 중첩반복문을 사용하게 되면 시간 초과가 발생할 것이기에 O(lonN)의 시간복잡도를 가지는 이분 탐색을 활용해야 한다. 이분(이진)탐색이란? 이진 탐색(이분 탐색) 알고리즘은 정렬되어 있는 리스트에서 탐색 범위를 절반씩 좁혀가며 데이터를 탐색하는 방법이다. 변수 3개(start, end, mid)를 사용하여...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/132-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(브론즈-1) 2609번 - 최대공약수와 최소공배수",
        "excerpt":"문제 풀이 이번 문제는 최대공약수를 구하는 것이 관건이다. 최대공약수를 구하는데 특정 수의 약수가 매우 많다면, 인수분해 및 두수를 비교하여 곱하는 과정에서 많은 시간이 소요된다. 그래서 유클리드 호제법을 활용하여 최대공약수를 구해야 한다. 유클리드 호제법을 활용한 풀이는 최대공약수와 최소공배수 문제에서 자세히 다루었으니 참고하자. 아이디어 도출 두 수를 입력받고 두 수 중 큰수와...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/133-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-4) 15828번 - Router",
        "excerpt":"자세한 테스트케이스 데이터는 문제링크를 참고하자. 문제 풀이 이번 문제는 큐의 개념을 잘 알고 있다면 쉽게 풀 수 있는 문제이다. 아이디어 도출 양수가 주어졌을 때 큐의 크기가 버퍼 크기(N)보다 작다면 양수를 큐에 삽입한다. 0이 주어졌을 때 큐에서 값을 추출(삭제)한다. -1이 주어졌을 때 큐를 확인하여 큐가 비어있다면 “empty”를, 비어있지 않다면 큐의 원소를...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/134-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(브론즈-3) 4153번 - 직각삼각형",
        "excerpt":"문제 풀이 이번 문제는 피타고라스 정리의 개념만 알고 있다면 큰 문제없이 풀 수 있을 것이다. 피타고라스의 정리란? 직각을 낀 두변의 길이를 a, b라고 하고, 빗변의 길이를 c라고 했을 때 a^2 + b^2 = c^2가 성립된다. 문제에서 유의할 점은 a, b, c의 위치가 특정되지 않았기에 별도로 정렬을 해야한다. 아이디어 도출 공백을...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/135-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-4) 10845번 - 큐",
        "excerpt":"문제 풀이 이번 문제는 Queue를 활용하는데, 일반적으로 Queue 인터페이스를 LinkedList로 구현하는 방식이 아닌 Deque와 LinkedList를 활용해 풀어보았다. Deque 인터페이스나 LinkedList 라이브러리는 앞에서 말한 일반적인 Queue 구현 방식보다 맨 앞과 맨 뒤의 값을 쉽게 가져올 수 있기 때문에 별도로 맨 뒤(back) 값을 구할 필요가 없다. 또한, 백준 10845번 문제와 로직 자체는...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/136-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-4) 10866번 - 덱",
        "excerpt":"문제 풀이 이번 문제는 문제에서도 나와있듯이 Deque(덱)을 이용해서 큐의 양쪽에서 삽입/삭제를 진행할 수 있기에 쉽게 풀 수 있다. 아이디어 도출 N개의 명령어를 입력받으며 다음을 수행한다. push_X [N] 명령어를 받으면 N을 큐에 삽입한다. push_front 명령어라면 N을 큐의 맨 앞에 삽입한다. push_back 명령어라면 N을 큐의 맨 뒤에 삽입한다. pop_X 명령어를 받으면 큐가...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/137-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-4) 11866번 - 요세푸스 문제 0",
        "excerpt":"문제 풀이 1부터 N까지 나열된 수에서 K번째 수마다 차례대로 뽑아낸 수열을 출력하면 되는데, 큐를 이용하면 쉽게 풀 수 있다. 예제를 살펴보면 다음과 같다. 1 2 3 4 5 6 7 8 N=7, K=3 [1,2,[3],4,5,6,7] -&gt; [3] [1,2,4,5,[6],7] -&gt; [3,6] [1,[2],4,5,7] -&gt; [3,6,2] [1,4,5,[7]] -&gt; [3,6,2,7] [1,4,[5]] -&gt; [3,6,2,7,5] [[1],4] -&gt;...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/138-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(브론즈-1) 11050번 - 이항 계수 1",
        "excerpt":"문제 풀이 문제 풀이에 앞서 이항 계수가 무엇인지 알아보자. 이항계수란? 위키백과를 보면 조합론에서 이항 계수(inomial coefficient)는 이항식을 이항 정리로 전개했을 때 각 항의 계수이며, 주어진 크기의 (순서 없는) 조합의 가짓수라고 한다. 전체 집합에서 원소개의 개수 n에 대해 k개의 아이템을 뽑는 이항계수(조합의 수)는 다음과 같다. 이항식 (x+y)^2 을 이항정리로 전개한다면 (x+y)^2...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/139-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(브론즈-3) 1085번 - 직사각형에서 탈출",
        "excerpt":"문제 풀이 이번 문제는 따로 특정한 알고리즘을 활용할 필요가 없을 정도로 쉽다. 위 이미지와 같이 현재 한수의 위치 (X,Y)에서 직사각형을 벗어나기 위한 최소거리를 구하면 된다. 상, 하, 좌, 우로 움직여 직사각형을 벗어날 수 있는데, 결국 X, W-X, Y, H-Y 중에서 가장 작은 수가 최소거리가 된다. 아이디어 도출 X, Y, W,...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/140-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-2) 1654번 - 랜선 자르기",
        "excerpt":"문제 풀이 이번 문제는 이분 탐색을 적절히 응용할 줄 알아야 한다. 먼저 문제의 패턴부터 살펴보자. 먼저 K개의 랜선을 동일한 길이의 N개의 랜선으로 잘라 만들어야 하는데, 이 때 최대로 가질 수 있는 길이를 구해야 한다. 예제와 같이 K=4, N=11이라고 한다면 4개의 랜선을 11개로 만들 수 있을 때 최대로 가질 수 있는...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/141-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(브론즈-3) 10810번 - 공 넣기",
        "excerpt":"문제 풀이 공 넣기문제는 정해진 배열에 값을 넣기만 하면 되는 간단한 문제이다. 아이디어 도출 N개의 바구니에 M번만큼 공을 집어 넣을 수 있고, 연속된 바구니에 같은 번호가 적힌 공을 집어넣어야 한다. 예제 테스트케이스처럼 N개의 바구니가 준비되어 있고, i부터 j번째 바구니까지 k번호가 적힌 공을 M번만큼 집어넣으면 된다. 이 솔루션을 1차원 배열로 풀어내면...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/142-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(브론즈-2) 10813번 - 공 바꾸기",
        "excerpt":"문제 풀이 공 바꾸기 문제는 배열의 원소를 교체하는 메커니즘을 이용하면 쉽게 풀 수 있다. 이번 문제는 배열 내에서 2개의 원소를 교체하는 방식을 구현하면 된다. 아이디어 도출 N개의 바구니에 M번만큼 공을 바꾸게 되는데, 바구니에는 이미 바구니와 같은 번호의 공이 들어가 있음을 윺의해야 한다. 즉, 배열의 초기값을 [인덱스+1] 값으로 고정시켜놓아야 한다는 것이다....","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/144-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-1) - 크기가 작은 부분 문자열",
        "excerpt":"문제 풀이 이번 문제는 부분 문자열을 잘 활용하는 것이 핵심이다. 아이디어 도출 t에서 p의 길이만큼 잘라가며 부분 문자열(result)을 만든다. 위에서 만든 부분 문자열(result)가 p를 정수로 변환한 값보다 작거나 같은지를 확인하여 카운트를 세면 된다. 바로 코드를 작성해보자. 1 2 3 4 int answer = 0; int len = p.length(); int result...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/143-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-1) - 가장 가까운 같은 글자",
        "excerpt":"문제 풀이 이번 문제는 HashMap을 활용한다면 간단하게 풀 수 있다. 아이디어 도출 주어진 s의 각 문자별로 HashMap에 존재여부를 검증하도록 구현하면 된다. HashMap에 존재하지 않는 문자라면, HashMap에 현재 문자와 인덱스 값을 집어넣고 answer 배열에 -1을 삽입한다. HashMap에 존재하는 문자라면, 가장 가까운 글자의 인덱스가 HashMap에 삽입되어 있을 테니 [현재 문자의 인덱스 -...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/145-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-1) - 과일 장수",
        "excerpt":"문제 풀이 이번 과일 장수 문제는 주어진 배열을 역순으로 그룹지어 접근하는 것이 핵심이다. 한 마디로 배열을 잘 다룰 줄 알아야 한다는 것이다. 아이디어 도출 처음엔 ArrayList를 활용하여 주어진 score 배열만큼 담은 다음 별도의 ArrayList에 add하고 remove하는 방식으로 접근하려 했으나 성능 이슈가 발생할 것 같아 그만두고 배열 자체를 잘 활용해보기로 하였다....","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/146-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-1) - 명예의 전당 (1)",
        "excerpt":"문제 풀이 이번 명예의 전당(1) 문제의 경우 많은 분들이 우선순위 큐를 많이들 사용하는 것 같았는데, 필자는 우선순위 큐에 대한 공부가 부족하여 ArrayList를 활용하여 풀었다. 일단은 ArrayList를 활용한 풀이 위주로 해설을 진행하고 추후 우선순위 큐를 학습한 후 다시 한번 풀어볼 예정이다. 아이디어 도출 주어진 score의 길이가 일차가 되고, score의 원소, 즉...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/147-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(브론즈-2) 10811번 - 바구니 뒤집기",
        "excerpt":"문제 풀이 이번 바구니 뒤집기 문제는 배열의 일정 인덱스의 범위만큼을 담아둘 임시 배열을 활용하여 풀 수 있었다. 아이디어 도출 N만큼의 길이를 가지는 원본 배열에서 주어지는 i와 j만큼의 범위만큼을 잘라서 역순으로 담은 임시배열을 원본 배열에 덮어씌우는 방식을 적용하였다. N과 M을 입력받고 N만큼의 길이를 가지는 배열을 생성한 뒤 1부터 N까지의 값으로 초기화한다....","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/148-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-1) - 기사단원의 무기",
        "excerpt":"문제 풀이 이번 기사단원의 무기 문제는 전반적인 구현까지의 과정은 단순하나 중간에 필요한 약수 개수를 구하는 알고리즘을 잘 구성해야 한다. 아이디어 도출 주어진 number 만큼 1부터 number까지 배열로 만든다. 위에서 만든 배열을 순회하면서 각 요소마다 약수의 개수를 구하고 이를 공격력으로 칭한 변수에 담는다. 약수의 개수를 구하는 로직을 별도의 함수에서 수행한다. 구한...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/149-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-2) - 주식 가격",
        "excerpt":"문제 풀이 이번 주식 가격 문제는 필자의 가독성이 부족한 것인지, 도저히 지문 자체가 이해가 안되어 지문을 이해하는 것이 더 어려웠다. 이 때, 다른 분의 지문 해석 글이 지문을 이해하는데 큰 도움이 되었기 때문에 해당 링크를 공유한다. 해당 글에서는 아래와 같이 지문을 이해하기 쉽게 알려주었다. 문제설명 n초 간의 주가를 초 단위로...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/150-post/",
        "teaser": null
      },{
        "title": "[Java] LeetCode(Easy) - 819. Most Common Word",
        "excerpt":"문제 풀이 이번 819번 문제는 Most Common Word, 즉 가장 흔한 단어를 찾는 문제이다. 문제 풀이의 핵심은 정규식 및 Map을 활용하는 것이다. 아이디어 도출 문제 그대로 주어진 문자열을 토대로 빈도수가 많은 단어를 반환하면 되는데, 먼저 문제에서 요구하는 특정 문자열을 필터링하여 단어 배열을 만드는 것이 중요하다. 단어별로 빈도수를 담기 위해 Map을...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/151-post/",
        "teaser": null
      },{
        "title": "[Java] 2차원 배열 - 달팽이 만들기",
        "excerpt":"문제 아래 와 같은 형태로 데이터를 저장하는 이차원 배열을 생성하세요. 문제 풀이 주어진 문제 보기와 같이 달팽이 모양의 2차원 배열을 만들어야 한다. 여기서 배열을 잘 살펴보면, 안쪽으로 말려 들어가는 달팽이 집과 같은 모양을 보이고 있음을 알 수 있다. 이 원리를 코드로 구현하기 위한 아이디어를 생각해보자. 아이디어 도출 정사각형 형태의 배열이기에...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/152-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-2) - 괄호 회전하기",
        "excerpt":"문제 풀이 이번 괄호 회전하기 문제는 괄호를 검증하는 것이 가장 주요하다고 볼 수 있다. 그런데, 그냥 하나의 소괄호 ()만 검증하는 것이 아니라 중괄호 {}와 대괄호 [] 까지 올바른 괄호대로 포함되어 있는지를 확인해야 한다. 아이디어 도출 먼저 주어진 괄호 문자열을 왼쪽으로 한 문자씩 문자열 길이만큼 회전시킨다. 문자열의 길이와 반복문 인덱스를 활용하여...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/153-post/",
        "teaser": null
      },{
        "title": "[Java] LeetCode(Easy) - 771. Jewels and Stones",
        "excerpt":"문제 풀이 이번 771번 문제는 단순하다. 문제에서 주어지는 문자열의 길이도 50자 이하이기 때문에 굉장히 관대하다. 아이디어 도출 jewels 문자열을 쪼개어 하나씩 보관한다. stones 문자열의 각 문자별로 순회하여 앞서 쪼갠 jewels의 문자가 포함되는지 확인한다. jewels에서 쪼갠 문자가 포함될 경우 카운트를 증가시킨다. 이번 문제에서 사용한 자료구조는 ArrayList, HashMap 2가지와 문자열 순회시 일반...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/154-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(골드-5) 2023번 - 신기한 소수",
        "excerpt":"문제 풀이 이번 신기한 소수 문제는 소수를 구하는 방법과 재귀를 잘 고려해야 한다. 소수를 판별하기 위해 제곱근까지 순회하는 방식을 이용하였고, 각 자리수별로 소수인지를 알아내기 위해서 재귀를 사용하였다. 에라토스테네스의 체 에라토스테네스의 체는 소수가 되는 수의 배수를 지우면 남은 건 소수가 된다.라는 원리의 알고리즘이라고 보면 된다. 그래서, 소수가 무엇인지 찾을 필요가 없으며...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/155-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-3) 18310번 - 안테나",
        "excerpt":"문제 풀이 이번 문제는 그리디 알고리즘과 정렬을 알고 있다면 쉽게 풀 수 있는 문제이다. 그리디 알고리즘이란? 그리디 알고리즘(Greedy Algorithm)은 최적해를 구하는 데 사용되는 방법 중 하나이다. 가장 직관적인 알고리즘 설계 패러타임 중 하나이며, 매번 단계에서 선택할 때마다 가장 좋은 답을 선택하는 기법이다. 지금 선택한 것을 앞으로의 남은 선택에 영향을 끼칠지...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/156-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-2) 18353번 - 병사 배치하기",
        "excerpt":"문제 분석 이번 문제는 내림차순으로 병사를 배치하기 위해서 내림차순 순서가 맞지 않는 병사들을 제외시켜야 한다. 이 때 LIS라는 최장 증가 부분 수열 알고리즘을 이용하여 정답을 구할 수 있다. 이 LIS를 구하기 위해 DP와 이분탐색 2가지 풀이 방법으로 문제를 풀어보겠다. LIS란? LIS(Longest Increasing Subsequenc)란 최장 증가 부분 수열이라고 한다. 즉 가장...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/157-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-2) 24479번 - 알고리즘 수업(깊이 우선 탐색 1)",
        "excerpt":"문제 분석 작성코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/158-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-2) - 숫자 블록",
        "excerpt":"문제 풀이 작성 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/159-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-2) - 튜플",
        "excerpt":"문제 풀이 작성 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/160-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-3) 2559번 - 수열",
        "excerpt":"문제 분석 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 10 5 일경우 6번 반복 // 1 2 3 4 5 // 2 3 4 5 6 // 3 4 5 6 7 // 4 5 6 7 8...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/162-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-2) 1260번 - DFS와 BFS",
        "excerpt":"문제 분석 작성코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/161-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-2) 24480번 - 알고리즘 수업(깊이 우선 탐색 2)",
        "excerpt":"문제 분석 작성코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/162-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-2) 24444번 - 알고리즘 수업(너비 우선 탐색 1)",
        "excerpt":"문제 분석 작성코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/163-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-2) 24445번 - 알고리즘 수업(너비 우선 탐색 2)",
        "excerpt":"문제 분석 작성코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/164-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(브론즈-4) 15439번 - 베라의 패션",
        "excerpt":"문제 분석 작성코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 import java.io.*; import java.util.*; class Main...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/165-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(브론즈-4) 24723번 - 녹색거탑",
        "excerpt":"문제 분석 작성코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import java.io.*; import java.util.*; class Main { public static void main(String[] args) throws IOException { BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/166-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-5) 1010번 - 다리놓기",
        "excerpt":"문제 분석 작성코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import java.io.*; import java.util.*; class Main { static int[][]...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/167-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-2) - 기능개발",
        "excerpt":"문제 풀이 작성 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/168-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(브론즈-5) 24416번 - 알고리즘 수업(피보나치 수 1)",
        "excerpt":"문제 분석 작성코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/169-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-2) 9184번 - 신나는 함수 실행",
        "excerpt":"문제 분석 작성코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/170-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-3) 1904번 - 01타일",
        "excerpt":"문제 분석 작성코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import java.io.*; import java.util.*; class Main { // DP...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/172-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-3) 9461번 - 파도반 수열",
        "excerpt":"문제 분석 작성코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/173-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-1) 1697번 - 숨바꼭질",
        "excerpt":"문제 분석 작성코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/174-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-2) - 할인 행사",
        "excerpt":"문제 풀이 작성 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/171-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-2) - 네트워크",
        "excerpt":"문제 풀이 작성 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/175-post/",
        "teaser": null
      },{
        "title": "[Java] 백준(실버-1) 1303번 - 전쟁 - 전투",
        "excerpt":"문제 분석 작성코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","baekjoon"],
        "url": "/java/177-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-2) - 타겟 넘버",
        "excerpt":"문제 풀이 작성 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import java.util.*; class Solution { // 타겟이 될 경우를 카운트할...","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/176-post/",
        "teaser": null
      },{
        "title": "[Java] 프로그래머스(level-2) - 뉴스 클러스터링",
        "excerpt":"문제 풀이 이 문제는 중복을 허용하는 다중집합을 처리할 수 있어야 한다. 아이디어 도출 HashMap을 사용하여 같은 문자열의 빈도수를 연산한다. 중복 허용 다중집합의 특성을 이용하여 교집합, 합집합 개수를 구한다. 중복을 허용하는 다중집합의 특징은 무엇일까? 중복을 허용하는 다중집합의 특징 2가지 교집합의 개수는 같은 문자열의 빈도 수 중 작은 빈도 수만큼 증가되어야 한다....","categories": ["Java"],
        "tags": ["blog","algorithm","study","java","programmers"],
        "url": "/java/178-post/",
        "teaser": null
      }]
