<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-07-13T11:34:38+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">lango’s DevLog</title><subtitle>developer</subtitle><author><name>lango</name></author><entry><title type="html">[Java] 백준(실버-4) 18110번 - solved.ac</title><link href="http://localhost:4000/java/218-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-4) 18110번 - solved.ac" /><published>2023-07-13T00:00:00+09:00</published><updated>2023-07-13T00:00:00+09:00</updated><id>http://localhost:4000/java/218-post</id><content type="html" xml:base="http://localhost:4000/java/218-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 단순한 <strong>구현</strong> 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>문제에서 요구한 절사평균 30%을 적용하여 높은 값에서부터 15%, 낮은 값에서부터 15%를 제외한 후의 평균을 구하면 된다.</p>

<blockquote>
  <p>또한, 절사평균을 통해 높은 값과 낮은 값에서부터 데이터를 제외해야 한다는 것을 통해 <strong>데이터를 정렬해두고 제외해야 한다는 것</strong>을 꼭 고려해야 한다.</p>
</blockquote>

<p>위 사항만 잘 고려하고, 반올림만 잘 해주면 쉽게 풀 수 있다.</p>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
        
        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        
        <span class="c1">// 절사평균을 구한다.</span>
        <span class="kt">int</span> <span class="n">except</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="nc">Math</span><span class="o">.</span><span class="na">round</span><span class="o">((</span><span class="kt">double</span><span class="o">)</span> <span class="no">N</span> <span class="o">*</span> <span class="mi">15</span> <span class="o">/</span> <span class="mi">100</span><span class="o">);</span>

        <span class="c1">// 입력 배열을 만든다.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="c1">// 테스트케이스 예제 1을 보면 알겠지만 데이터가 오름차순 정렬되어 있어야 한다.</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">);</span>

        <span class="c1">// 총 난이도의 평균을 구할 변수 초기화</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// 절사평균을 통해 제외할 구간만을 순회하여 합을 담는다.</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">except</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">-</span><span class="n">except</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
        
        <span class="c1">// 절사평균을 제외한 나머지의 평균을 구해 반올림한다.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="nc">Math</span><span class="o">.</span><span class="na">round</span><span class="o">((</span><span class="kt">double</span><span class="o">)</span><span class="n">result</span> <span class="o">/</span> <span class="o">(</span><span class="no">N</span> <span class="o">-</span> <span class="o">(</span><span class="n">except</span><span class="o">*</span><span class="mi">2</span><span class="o">)));</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>    

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/18110">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[18110번 - solved.ac]]></summary></entry><entry><title type="html">[Java] 백준(실버-5) 1676번 - 팩토리얼 0의 개수</title><link href="http://localhost:4000/java/216-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-5) 1676번 - 팩토리얼 0의 개수" /><published>2023-07-12T00:00:00+09:00</published><updated>2023-07-12T00:00:00+09:00</updated><id>http://localhost:4000/java/216-post</id><content type="html" xml:base="http://localhost:4000/java/216-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 단순한 <strong>구현</strong> 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>이 문제는 단순히 N!의 값을 팩토리얼 연산을 통해 구해서 0을 구할 수 있지만, 입력값의 범위를 생각하면 출제자의 의도는 다른 것이라는 것을 알 수 있다.</p>

<blockquote>
  <p>최대 500! 까지의 값을 구해야 하는데 BigInteger 클래스를 사용해야만 500! 까지의 값을 구할 수 있다.</p>
</blockquote>

<p>물론, BigInteger 클래스를 사용하여 팩토리얼 연산 후 0의 개수를 셀 수도 있겠지만, 여기서는 출제자가 의도한 0의 개수를 세는 것은 다른 방법을 이용하려고 한다.</p>

<p>N!의 값에서 뒷자리가 0이 나오는 경우를 잘 생각해보면 10으로 나누어 떨어질 때를 생각해볼 수 있다. 이 말은, <strong>소인수분해를 해서 2와 5가 존재할 경우 뒷자리는 0으로 끝난다</strong>고 볼 수 있다.</p>

<p>예시를 한번 들어보자.</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">30 = 2*3*5</code> <br />
<code class="language-plaintext highlighter-rouge">231400 = 23*52*13*89</code></p>
</blockquote>

<p>30과 231400 모두 2와 5가 포함된다. 즉, 소인수분해의 성질을 이용해야 한다는 것이다.</p>

<p>소인수분해의 성질을 통해 살펴보면, 뒷자리가 0이 N개 있다는 것은 2와 5개 N개씩 쌍으로 존재한다는 것을 알 수 있다.</p>

<p>30과 231400이라는 수도 소인수분해값을 보면 30은 2와 5가 1개씩 쌍으로 1개가 있으며, 231400은 2는 3개, 5는 2개가 있어 쌍으로 2ㅐ가 있다. 30의 0의 개수는 1개, 231400의 0의 개수는 2개라고 보면 된다.</p>

<p>그런데, N!의 값을 보면 2는 5보다 작기 때문에 소인수분해시, 2의 개수는 5의 개수보다 많게 된다. 그래서 <strong>5의 개수에 초점</strong>을 두어야 한다.</p>

<p><br /></p>

<p>문제 풀이를 위한 생각한 아이디어는 다음과 같다.</p>

<ul>
  <li>N을 5로 나눠가면서 5로 나눌때마다 카운트를 세면 된다.
    <blockquote>
      <p>N을 5를 나눠가며 갱신할 때마다 카운트를 하는 것이 0의 개수를 세는 것과 같다.</p>
    </blockquote>
  </li>
</ul>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
        
        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        
        <span class="k">while</span><span class="o">(</span><span class="no">N</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="o">)</span> <span class="o">{</span>
            <span class="no">N</span> <span class="o">/=</span> <span class="mi">5</span><span class="o">;</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="no">N</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>    

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/1676">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[1676번 - 팩토리얼 0의 개수]]></summary></entry><entry><title type="html">[Java] 백준(브론즈-2) 15829번 - Hashing</title><link href="http://localhost:4000/java/217-post/" rel="alternate" type="text/html" title="[Java] 백준(브론즈-2) 15829번 - Hashing" /><published>2023-07-12T00:00:00+09:00</published><updated>2023-07-12T00:00:00+09:00</updated><id>http://localhost:4000/java/217-post</id><content type="html" xml:base="http://localhost:4000/java/217-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 단순한 <strong>구현</strong> 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>이번 문제는 서브테스크 유형의 문제라 Small Case를 충족하면 50점, Large Case까지 충족하면 100점을 받을 수 있다.</p>

<p>처음엔 단순하게 생각하여 풀었더니 문자열 길이 50까지의 범위를 고려하지 못해 Small Case만 충족되어 50점을 달성하였다. 어떻게 Large Case까지 충족하여 100점을 받을 수 있을까 고민하고 개선하여 100점을 받았는데 그 아이디어를 살펴보자.</p>

<p>문제풀이를 위한 핵심 아이디어 2가지는 다음과 같다.</p>

<ol>
  <li>모듈러 연산</li>
  <li>수의 범위</li>
</ol>

<p><br /></p>

<h4 id="모듈러-연산">모듈러 연산</h4>

<p>이번 문제에서 100점을 받기 위해서는 <strong>모듈러 연산</strong>의 성질을 잘 이해해야 한다.</p>

<blockquote>
  <ol>
    <li>(A + B) mod C = (A mod C + B mod C) mod C</li>
    <li>(A - B) mod C = (A mod C - B mod C) mod C</li>
    <li>(A * B) mod C = (A mod C * B mod C) mod C</li>
  </ol>
</blockquote>

<p>위 성질을 통해 아래 연산식이 가능하다는 것을 알 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="n">a2r2</span> <span class="n">mod</span> <span class="no">M</span> <span class="o">=</span> <span class="o">(</span><span class="n">a2</span> <span class="n">mod</span> <span class="no">M</span> <span class="o">*</span> <span class="n">r2</span> <span class="n">mod</span> <span class="no">M</span><span class="o">)</span> <span class="n">mod</span> <span class="no">M</span>
<span class="n">r2</span> <span class="n">mod</span> <span class="no">M</span> <span class="o">=</span> <span class="o">(</span><span class="n">r</span> <span class="n">mod</span> <span class="no">M</span> <span class="o">*</span> <span class="n">r</span> <span class="n">mod</span> <span class="no">M</span><span class="o">)</span> <span class="n">mod</span> <span class="no">M</span>
<span class="n">r3</span> <span class="n">mod</span> <span class="no">M</span> <span class="o">=</span> <span class="o">(</span><span class="n">r2</span> <span class="n">mod</span> <span class="o">*</span> <span class="n">r</span> <span class="n">mod</span> <span class="no">M</span><span class="o">)</span> <span class="n">mod</span> <span class="no">M</span>
<span class="n">r4</span> <span class="n">mod</span> <span class="no">M</span> <span class="o">=</span> <span class="o">(</span><span class="n">r3</span> <span class="n">mod</span> <span class="no">M</span> <span class="o">*</span> <span class="n">r</span> <span class="n">mod</span> <span class="no">M</span><span class="o">)</span> <span class="n">mod</span> <span class="no">M</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><br /></p>

<h4 id="수의-범위">수의 범위</h4>
<p>또한, Math.pow() 메서드를 사용하여 31의 제곱수를 곱해주는 방식으로 구현했지만 Math.pow(31, 49)까지 간다면 long형의 범위도 벗어나기 때문에 해당 메소드를 사용하지 않고 <strong>pow를 일일이 곱</strong>해주면서 <strong>모듈러 연산을 통해 문제에서 제시한 M(=1234567891)보다 크기를 줄여</strong>가야 한다.</p>

<blockquote>
  <p>그래서 pow로 사용하는 변수와 해시 함수의 결과값을 더해줄 결과값 변수는 long 형으로 선언해서 사용해야 한다.</p>
</blockquote>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
        
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">hm</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">97</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">123</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">hm</span><span class="o">.</span><span class="na">put</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span><span class="n">i</span><span class="o">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">96</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="no">M</span> <span class="o">=</span> <span class="mi">1234567891</span><span class="o">;</span>

        <span class="kt">int</span> <span class="no">L</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>

        <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">long</span> <span class="n">pow</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Math.pow() 메서드를 사용하면 long형의 범위를 벗어나기 때문에 Large 케이스를 통과할 수 없다.</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">L</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">char</span> <span class="n">alph</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="o">(</span><span class="n">hm</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">alph</span><span class="o">)</span> <span class="o">*</span> <span class="n">pow</span><span class="o">)</span> <span class="o">%</span> <span class="no">M</span><span class="o">;</span>
            <span class="n">pow</span> <span class="o">=</span> <span class="o">(</span><span class="n">pow</span> <span class="o">*</span> <span class="mi">31</span><span class="o">)</span> <span class="o">%</span> <span class="no">M</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">((</span><span class="n">result</span><span class="o">%</span><span class="no">M</span><span class="o">)+</span><span class="s">"\n"</span><span class="o">);</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>    

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/15829">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[15829번 - Hashing]]></summary></entry><entry><title type="html">[Java] 백준(실버-5) 1475번 - 방 번호</title><link href="http://localhost:4000/java/215-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-5) 1475번 - 방 번호" /><published>2023-07-11T00:00:00+09:00</published><updated>2023-07-11T00:00:00+09:00</updated><id>http://localhost:4000/java/215-post</id><content type="html" xml:base="http://localhost:4000/java/215-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 단순한 <strong>구현</strong> 문제로 문제가 요구하는 내용을 잘 파악한다면 쉽게 풀 수 있다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>문제 풀이를 위한 생각한 아이디어는 다음과 같다.</p>

<ol>
  <li>0부터 9까지의 원소의 빈도수를 카운팅하기 위해 <strong>카운팅 배열</strong>을 이용한다.</li>
  <li>주어진 방 번호대로 0부터 9까지 빈도수를 센 후, 6과 9는 뒤집어서 쓸 수 있기 때문에 같은 수로 취급한다. <br />
 2.1 6과 9의 카운트의 합이 짝수이면 6과 9의 빈도수를 각각 반으로 나눠주고, 홀수라면 반으로 나눠준 뒤, 한번 더 사용해야 하기 때문에 1씩 증가시킨다.</li>
  <li>카운팅 배열에 원소 중 가장 많은 빈도수가 필요한 세트 수가 된다.</li>
  <li>오름차순/내림차순 정렬 후 최대값 인덱스 접근이나 반복문을 돌며 최대값을 찾는 방법으로 배열의 최대값을 구하면 된다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
        
        <span class="c1">// 카운팅 배열을 사용한다.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="nc">String</span> <span class="no">N</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="nc">Character</span><span class="o">.</span><span class="na">getNumericValue</span><span class="o">(</span><span class="no">N</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">num</span><span class="o">]++;</span>            
        <span class="o">}</span>

        <span class="cm">/**
         * 6과 9의 경우 바꿔서 사용할 수 있다.
         * 그래서 6과 9의 빈도수를 함께 계산한다.
         * - 짝수라면 각각 반씩 나눈다.
         * - 홀수라면 반씩 나눈 후 1씩을 추가한다.(반씩 나누어도 한 번 더 사용해야 하기 때문)
         */</span>
        <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="mi">6</span><span class="o">]</span> <span class="o">+</span> <span class="n">arr</span><span class="o">[</span><span class="mi">9</span><span class="o">];</span>
        
        <span class="k">if</span><span class="o">(</span><span class="n">temp</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">arr</span><span class="o">[</span><span class="mi">6</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
            <span class="n">arr</span><span class="o">[</span><span class="mi">9</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">arr</span><span class="o">[</span><span class="mi">6</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="n">temp</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="n">arr</span><span class="o">[</span><span class="mi">9</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="n">temp</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="c1">// 필요한 세트 수는 배열의 최댓값이기에 arr 배열을 오름차순 정렬한다.</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">);</span>
        
        <span class="c1">// 배열의 마지막 원소가 필요한 세트 수가 된다.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="mi">9</span><span class="o">];</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>    

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/1475">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[1475번 - 방 번호]]></summary></entry><entry><title type="html">[Java] 프로그래머스(level-2) - 방문 길이</title><link href="http://localhost:4000/java/214-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-2) - 방문 길이" /><published>2023-07-10T00:00:00+09:00</published><updated>2023-07-10T00:00:00+09:00</updated><id>http://localhost:4000/java/214-post</id><content type="html" xml:base="http://localhost:4000/java/214-post/"><![CDATA[<p><br /></p>

<center><img src="/assets/images/programmers/" width="100%" /></center>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />

<p>이 문제는 <strong>HashSet 자료구조</strong> 를 이용해 풀 수 있다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>HashSet 자료구조를 사용해보기 전에는, 단순히 상, 하, 좌, 우로 이동한 횟수를 카운트 했었는데, 이미 다녀온 중복 이동을 고려하기 어려웠다. 이를 HashSet으로 중복을 제거하여 해결할 수 있었다.</p>

<p>문제 풀이를 위한 아이디어는 다음과 같다.</p>

<ol>
  <li>(0,0) 위치부터 dirs 문자열을 순회하여 <code class="language-plaintext highlighter-rouge">U, D, L, R</code> 명령에 따라 1,-1씩 움직인다.</li>
  <li>상, 하, 좌, 우로 움직일 경우를 각각 고려하여 문자열에 위치정보를 담는다.</li>
  <li>움직인 위치가 이동 칸의 범위(최소 -5, 최대 5)를 벗어나지 않았다면 HashSet에 위치정보를 담은 문자열을 삽입하고 현재 위치를 움직인 위치로 갱신한다.</li>
  <li><strong>HashSet의 크기가 곧 이동횟수</strong>가 된다.</li>
</ol>

<p><br /></p>

<h4 id="어떻게-다녀온-위치-중복을-제거하나">어떻게 다녀온 위치 중복을 제거하나?</h4>

<p>HashSet에 삽입하여 중복을 제거하기 위해 String 문자열에 위치를 담아서 중복을 해결했는데 그 절차는 다음과 같다.</p>

<p>상, 우 로 움직일 경우 <code class="language-plaintext highlighter-rouge">[현재x좌표][현재y좌표][다음x좌표][다음y좌표]</code> 형식으로 문자열을 만들고, 
하, 좌 로 움직일 경우 <code class="language-plaintext highlighter-rouge">[다음x좌표][다음y좌표][현재x좌표][현재y좌표]</code> 형식으로 문자열을 만든다.</p>

<blockquote>
  <p>U
<code class="language-plaintext highlighter-rouge">"[현재x좌표][현재y좌표][다음x좌표][다음y좌표]"</code></p>
</blockquote>

<blockquote>
  <p>D
<code class="language-plaintext highlighter-rouge">"[다음x좌표][다음y좌표][현재x좌표][현재y좌표]"</code></p>
</blockquote>

<blockquote>
  <p>R
<code class="language-plaintext highlighter-rouge">"[다음x좌표][다음y좌표][현재x좌표][현재y좌표]"</code></p>
</blockquote>

<blockquote>
  <p>L
<code class="language-plaintext highlighter-rouge">"[현재x좌표][현재y좌표][다음x좌표][다음y좌표]"</code></p>
</blockquote>

<p>이렇게 문자열을 구성하면 이동시 중복되는 위치의 중복을 해결할 수 있게 된다.</p>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
</pre></td><td class="rouge-code"><pre>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="nc">String</span> <span class="n">dirs</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// 방문 위치를 담을 HashSet</span>
        <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        
        <span class="c1">// 11*11 크기의 배열의 중심점 (0,0)</span>
        <span class="kt">int</span> <span class="n">nowX</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">nowY</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">idx</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">idx</span><span class="o">&lt;</span><span class="n">dirs</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">idx</span><span class="o">++)</span> <span class="o">{</span>

            <span class="c1">// 다음으로 이동할 좌표 초기화</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">nowX</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">nowY</span><span class="o">;</span>
            
            <span class="c1">// 위치정보를 문자열 형태로 담기 위한 변수</span>
            <span class="nc">String</span> <span class="n">location</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>

            <span class="cm">/**
             * 상: y좌표+1, [nowX][nowY][nextX][nextY]
             * 하: y좌표-1, [nextX][nextY][nowX][nowY]
             * 좌: x좌표-1, [nextX][nextY][nowX][nowY]
             * 우: x좌표+1, [nowX][nowY][nextX][nextY]
             */</span> 
            <span class="k">switch</span><span class="o">(</span><span class="n">dirs</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">idx</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">case</span> <span class="sc">'U'</span><span class="o">:</span>
                    <span class="n">y</span><span class="o">++;</span>
                    <span class="n">location</span> <span class="o">+=</span> <span class="n">nowX</span><span class="o">;</span>
                    <span class="n">location</span> <span class="o">+=</span> <span class="n">nowY</span><span class="o">;</span>
                    <span class="n">location</span> <span class="o">+=</span> <span class="n">x</span><span class="o">;</span>
                    <span class="n">location</span> <span class="o">+=</span> <span class="n">y</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="k">case</span> <span class="sc">'D'</span><span class="o">:</span>
                    <span class="n">y</span><span class="o">--;</span>
                    <span class="n">location</span> <span class="o">+=</span> <span class="n">x</span><span class="o">;</span>
                    <span class="n">location</span> <span class="o">+=</span> <span class="n">y</span><span class="o">;</span>
                    <span class="n">location</span> <span class="o">+=</span> <span class="n">nowX</span><span class="o">;</span>
                    <span class="n">location</span> <span class="o">+=</span> <span class="n">nowY</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="k">case</span> <span class="sc">'R'</span><span class="o">:</span>
                    <span class="n">x</span><span class="o">++;</span>
                    <span class="n">location</span> <span class="o">+=</span> <span class="n">nowX</span><span class="o">;</span>
                    <span class="n">location</span> <span class="o">+=</span> <span class="n">nowY</span><span class="o">;</span>
                    <span class="n">location</span> <span class="o">+=</span> <span class="n">x</span><span class="o">;</span>
                    <span class="n">location</span> <span class="o">+=</span> <span class="n">y</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="k">case</span> <span class="sc">'L'</span><span class="o">:</span>
                    <span class="n">x</span><span class="o">--;</span>
                    <span class="n">location</span> <span class="o">+=</span> <span class="n">x</span><span class="o">;</span>
                    <span class="n">location</span> <span class="o">+=</span> <span class="n">y</span><span class="o">;</span>
                    <span class="n">location</span> <span class="o">+=</span> <span class="n">nowX</span><span class="o">;</span>
                    <span class="n">location</span> <span class="o">+=</span> <span class="n">nowY</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="k">default</span><span class="o">:</span>
                    <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// 좌표 범위 벗어나면 이동하지 않음</span>
            <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">5</span> <span class="o">||</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="o">||</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">5</span> <span class="o">||</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="n">visited</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">location</span><span class="o">);</span>

            <span class="c1">// 현재 위치를 이동한 위치로 갱신</span>
            <span class="n">nowX</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
            <span class="n">nowY</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>

        <span class="o">}</span>

        <span class="k">return</span> <span class="n">visited</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>

    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        
        <span class="c1">// String dirs = "ULURRDLLU";</span>
        <span class="c1">// String dirs = "LULLLLLLU";</span>
        <span class="c1">// String dirs = "LURDLURDLURDLURDRULD";</span>
        <span class="c1">// String dirs = "RRRRRRRRRRRRRRRRRRRRRUUUUUUUUUUUUULU";</span>
        <span class="c1">// String dirs = "RRRRRLLLLL";</span>
        <span class="nc">String</span> <span class="n">dirs</span> <span class="o">=</span> <span class="s">"UDU"</span><span class="o">;</span>

        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">dirs</span><span class="o">);</span>

    <span class="o">}</span>

<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<ul>
  <li>
    <hr />
  </li>
</ul>

<p><br /></p>

<h3 id="출처">출처</h3>
<p>-
—</p>

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://school.programmers.co.kr/learn/courses/30/lessons/49994">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 2 - 방문 길이]]></summary></entry><entry><title type="html">[Java] LeetCode(Easy) - 1. Two Sum</title><link href="http://localhost:4000/java/213-post/" rel="alternate" type="text/html" title="[Java] LeetCode(Easy) - 1. Two Sum" /><published>2023-07-08T00:00:00+09:00</published><updated>2023-07-08T00:00:00+09:00</updated><id>http://localhost:4000/java/213-post</id><content type="html" xml:base="http://localhost:4000/java/213-post/"><![CDATA[<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />

<p>배열의 원소를 순회하며 두 수의 합이 target이 되는지 판단하면 되는 간단한 문제이다. 필자는 완전탐색과 HashMap 2가지를 이용해서 풀어보았다.</p>

<p><br /></p>

<h4 id="아이디어-도출---완전탐색">아이디어 도출 - 완전탐색</h4>

<p>완전탐색의 경우 문제 요구사항 그대로 구현하면 된다.</p>

<ol>
  <li>nums 배열을 순회하며 자리별로 두 수의 합이 target이 되는 인덱스가 있을 경우 List에 삽입한다.</li>
  <li>삽입된 List를 Array로 반환한다.</li>
</ol>

<blockquote>
  <p>완전탐색을 할 경우, 시간복잡도가 O(n^2)이기에 비효율적이다.</p>
</blockquote>

<p><br /></p>

<h4 id="아이디어-도출---hashmap">아이디어 도출 - HashMap</h4>

<p>HashMap을 이용하면 완전탐색 풀이에 비교하면 O(n)으로 보다 효율적인 성능을 보여준다.</p>

<ol>
  <li>nums 배열을 순회하며 배열의 원소를 key로, 인덱스를 value로 HashMap에 삽입한다.</li>
  <li><code class="language-plaintext highlighter-rouge">target - 원소</code> 값이 HashMap에 존재한다면, 두 수의 합을 만들 수 있다고 가정하여, <code class="language-plaintext highlighter-rouge">target - 원소</code> 값의 인덱스와 현재 원소의 인덱스를 반환한다.</li>
</ol>

<p><br /></p>

<p>위와 같이 2가지 방식으로 문제를 풀어보았다. 문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LeetCode</span> <span class="o">{</span>

    <span class="c1">// 완전탐색의 경우 시간복잡도 O(n^2)의 시간이 걸리기에 비효율적이다.</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum1</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
     
        <span class="c1">// 두 수를 담을 List</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// nums 배열을 순회하면서 두 수의 합이 target이 되는 인덱스를 구한다.</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// List를 Array로 반환한다.</span>
        <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">mapToInt</span><span class="o">(</span><span class="nl">Integer:</span><span class="o">:</span><span class="n">intValue</span><span class="o">).</span><span class="na">toArray</span><span class="o">();</span>

    <span class="o">}</span>

    <span class="c1">// 시간복잡도 O(n)으로 풀기 위해 HashMap을 사용한다.</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum2</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
     
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">hm</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">hm</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="o">{</span>
                <span class="n">answer</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">hm</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                <span class="n">answer</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
                
            <span class="o">}</span>
            <span class="n">hm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>

    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="nc">LeetCode</span> <span class="n">leetCode</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LeetCode</span><span class="o">();</span>

        <span class="kt">int</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>

        <span class="c1">// int[] nums = new int[]{2, 7, 11, 15};</span>
        <span class="c1">// int[] nums = new int[]{11, 7, 15, 2};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        
        <span class="n">leetCode</span><span class="o">.</span><span class="na">twoSum2</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">target</span><span class="o">);</span>

    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<ul>
  <li></li>
</ul>

<h3 id="출처">출처</h3>
<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://leetcode.com/problems/two-sum/">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="leetcode" /><summary type="html"><![CDATA[Easy - 1. Two Sum]]></summary></entry><entry><title type="html">[Java] 백준(골드-5) 15686번 - 치킨 배달</title><link href="http://localhost:4000/java/212-post/" rel="alternate" type="text/html" title="[Java] 백준(골드-5) 15686번 - 치킨 배달" /><published>2023-07-07T00:00:00+09:00</published><updated>2023-07-07T00:00:00+09:00</updated><id>http://localhost:4000/java/212-post</id><content type="html" xml:base="http://localhost:4000/java/212-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 <strong>DFS를 통한 백트래킹</strong>을 이용해 풀 수 있다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>문제 풀이를 위해 생각한 아이디어는 다음과 같다.</p>

<ol>
  <li>집과 치킨집의 위치를 미리 저장한다.</li>
  <li>M개만큼 뽑은 치킨집은 방문 여부를 체크하여 도시의 치킨 거리를 구할 때 사용한다.</li>
  <li>M개의 치킨집을 모두 뽑았다면, 모든 집의 위치에서 최소거리에 있는 치킨집과의 거리을 구한다.</li>
  <li>그렇게 모든 치킨집과의 최소거리를 계산한다면, 모든 도시의 치킨거리 중 최솟값을 구하면 된다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// 방문배열과 입력배열</span>
    <span class="kd">static</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">map</span><span class="o">;</span>
    
    <span class="c1">// 집과 치킨집 좌표를 저장할 List</span>
    <span class="kd">static</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">house</span><span class="o">;</span>
    <span class="kd">static</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">chicken</span><span class="o">;</span>
    
    <span class="c1">// 입력배열의 크기인 N과 깊이 M</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="no">N</span><span class="o">,</span> <span class="no">M</span><span class="o">;</span>

    <span class="c1">// 도시의 치킨거리 최솟값을 저장할 변수</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">result</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
        
        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

        <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">N</span><span class="o">];</span> 
        <span class="n">house</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">chicken</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>


        <span class="cm">/**
         * 위치들을 입력받으며 house, chicken List 초기화
         */</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                
                <span class="c1">// 집의 위치와 치킨집의 위치를 저장</span>
                <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">house</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">});</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">chicken</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">});</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 치킨집 크기만큼 방문 배열을 초기화</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">chicken</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>  
        
        <span class="c1">// 최솟값을 구해야 하므로 result를 Integer.MAX_VALUE 값으로 초기화</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

        <span class="c1">// DFS 재귀함수 호출</span>
        <span class="n">recursion</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 백트래킹을 진행할 DFS 재귀함수
     * depth(깊이)가 M과 같아지면 선택한 치킨집과 집과의 치킨 거리를 구한다.
     * 치킨거리 중 최솟값을 누적시키며, 모든 도시의 치킨 거리 중 최솟값을 구한다.
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">recursion</span><span class="o">(</span><span class="kt">int</span> <span class="n">depth</span><span class="o">,</span> <span class="kt">int</span> <span class="n">at</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="k">if</span><span class="o">(</span><span class="n">depth</span> <span class="o">==</span> <span class="no">M</span><span class="o">)</span> <span class="o">{</span>            
            
            <span class="c1">// 도시의 치킨거리</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">house</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

                <span class="c1">// 집과 치킨 집 중 방문한 치킨집의 모든 거리를 비교하며 최소거리를 구한다.</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">chicken</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
                        <span class="c1">// 해당 집의 치킨 거리 |r1-c1|+|r2-c2|</span>
                        <span class="kt">int</span> <span class="n">distance</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">house</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">chicken</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">)[</span><span class="mi">0</span><span class="o">])</span>
                                    <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">house</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">chicken</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">)[</span><span class="mi">1</span><span class="o">]);</span>
                        <span class="n">min</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">min</span><span class="o">,</span> <span class="n">distance</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">min</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="n">result</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">sum</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>

        <span class="o">}</span>

        <span class="c1">// 백트래킹 탐색 진행</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">at</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">chicken</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// 방문 여부를 통해 가지치기</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="n">recursion</span><span class="o">(</span><span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
                <span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>

        <span class="o">}</span>
        
    <span class="o">}</span>    

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/15686">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[15686번 - 치킨 배달]]></summary></entry><entry><title type="html">[Java] 프로그래머스(level-2) - 땅따먹기</title><link href="http://localhost:4000/java/211-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-2) - 땅따먹기" /><published>2023-07-07T00:00:00+09:00</published><updated>2023-07-07T00:00:00+09:00</updated><id>http://localhost:4000/java/211-post</id><content type="html" xml:base="http://localhost:4000/java/211-post/"><![CDATA[<p><br /></p>

<center><img src="/assets/images/programmers/" width="100%" /></center>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />

<p>이 문제는 <strong>동적 계획법, DP</strong> 를 이용한 방법으로 적은 수의 라인으로 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="그리디-완전탐색">그리디? 완전탐색?</h4>

<p>사실, 문제를 보고 그리디 알고리즘이나 완전탐색으로 접근하려 했으나 두 가지 모두 문제 통과는 어렵다고 판단하였다.</p>

<p>그리디 알고리즘을 적용할 경우 최선의 값을 선택하기에 좋은 솔루션으로 생각할 수도 있겠지만, 문제에서 주어지는 행에서의 최대값을 선택한다고 마지막 행까지의 덧셈을 통해 최댓값이 구해지는 것은 아니다. 아래 예시를 보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span>
<span class="o">[</span><span class="mi">9</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">6</span><span class="o">]</span>
<span class="o">[</span><span class="mi">10</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">]</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>위 배열을 보면 4 -&gt; 9 -&gt; 4 로 최대값을 선택하면서 내려왔다면 값은 17이다.
다만, 4 -&gt; 7-&gt; 10 이나 3 -&gt; 8 -&gt; 10을 선택하면서 내려왔다면 21이라는 최대값을 만들 수 있다.</p>

<blockquote>
  <p>여기서 알 수 있는 점은 <strong>매 행에서 최대값을 선택하는 그리디 알고리즘을 적용하는 것은 적절하지 않다</strong>는 것이다!</p>
</blockquote>

<p>또한 <strong>N의 범위는 최대 100,000이기에 완전 탐색을 이용하기엔 시간초과</strong>가 걸린다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>그렇다면 행마다 한번씩 내려가면서, 최고의 합을 기록하며 내려간다면 어떻게 될까? 위에서 살펴 본 배열을 한 번더 예시로 들어보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span>
<span class="o">[</span><span class="mi">9</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">6</span><span class="o">]</span>
<span class="o">[</span><span class="mi">10</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">]</span>

<span class="c1">// 두번째 행을 최고의 합으로 갱신</span>
<span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span>
<span class="o">[</span><span class="mi">13</span><span class="o">(</span><span class="mi">9</span><span class="o">+</span><span class="mi">4</span><span class="o">),</span> <span class="mi">11</span><span class="o">(</span><span class="mi">8</span><span class="o">+</span><span class="mi">3</span><span class="o">),</span> <span class="mi">11</span><span class="o">(</span><span class="mi">7</span><span class="o">+</span><span class="mi">4</span><span class="o">),</span> <span class="mi">10</span><span class="o">(</span><span class="mi">6</span><span class="o">+</span><span class="mi">4</span><span class="o">)]</span>
<span class="o">[</span><span class="mi">10</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">]</span>

<span class="c1">// 마지막 행을 최고의 합으로 갱신</span>
<span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span>
<span class="o">[</span><span class="mi">13</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">10</span><span class="o">]</span>
<span class="o">[</span><span class="mi">21</span><span class="o">(</span><span class="mi">10</span><span class="o">+</span><span class="mi">11</span><span class="o">),</span> <span class="mi">17</span><span class="o">(</span><span class="mi">4</span><span class="o">+</span><span class="mi">13</span><span class="o">),</span> <span class="mi">15</span><span class="o">(</span><span class="mi">2</span><span class="o">+</span><span class="mi">13</span><span class="o">),</span> <span class="mi">14</span><span class="o">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">13</span><span class="o">)]</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>위와 같이 내려오면서 land 배열의 각 자리마다 이전 행의 최대값을 더해주면서 내려온다면 마지막 행에서 21이라는 최대값을 반환하기만 된다는 것을 알 수 있다.</p>

<p>결국, 위와 같은 방법으로 <strong>배열의 각 자리를 갱신하면서 마지막 행에서 가장 큰 값을 가진 값을 반환</strong>하면 된다!</p>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre></td><td class="rouge-code"><pre>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">land</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">land</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="cm">/**
         * 행을 한번씩 내려가면서, 내려올때의 최고의 합을 land에 기록해나간다.
         * 
         * 배열의 2번째 행부터 현재 칸과 이전 행의 최댓값을 더한 값으로 갱신해나간다.
         * 이때, 이전에 최댓값이 된 칸의 경우 같은 칸을 더하지 않도록 한다.
         */</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">+=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">],</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">2</span><span class="o">],</span> <span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">3</span><span class="o">]));</span>
            <span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">+=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">2</span><span class="o">],</span> <span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">3</span><span class="o">]));</span>
            <span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">2</span><span class="o">]</span> <span class="o">+=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">],</span> <span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">3</span><span class="o">]));</span>
            <span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">3</span><span class="o">]</span> <span class="o">+=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">],</span> <span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">2</span><span class="o">]));</span>
        <span class="o">}</span>

        <span class="c1">// 마지막 행 중 최대값을 구하여 반환한다.</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">land</span><span class="o">[</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">answer</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">answer</span><span class="o">,</span> <span class="n">num</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        
        <span class="c1">// int[][] land = new int[][]{{1,2,3,5},</span>
        <span class="c1">//                         {5,6,7,8},</span>
        <span class="c1">//                         {4,3,2,1}};</span>

        <span class="c1">// int[][] land = new int[][]{{1,1,1,1},</span>
        <span class="c1">//                             {2,2,2,3},</span>
        <span class="c1">//                             {3,3,3,6},</span>
        <span class="c1">//                             {4,4,4,7}};</span>

        <span class="kt">int</span><span class="o">[][]</span> <span class="n">land</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[][]{{</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">},</span>
                                    <span class="o">{</span><span class="mi">9</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">6</span><span class="o">},</span>
                                    <span class="o">{</span><span class="mi">10</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">}};</span>

        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">land</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<ul>
  <li>
    <hr />
  </li>
</ul>

<p><br /></p>

<h3 id="출처">출처</h3>
<p>-
—</p>

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://school.programmers.co.kr/learn/courses/30/lessons/12913">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 2 - 땅따먹기]]></summary></entry><entry><title type="html">[Java] 백준(골드-4) 2110번 - 공유기 설치</title><link href="http://localhost:4000/java/210-post/" rel="alternate" type="text/html" title="[Java] 백준(골드-4) 2110번 - 공유기 설치" /><published>2023-07-06T00:00:00+09:00</published><updated>2023-07-06T00:00:00+09:00</updated><id>http://localhost:4000/java/210-post</id><content type="html" xml:base="http://localhost:4000/java/210-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 <strong>이분 탐색</strong>를 잘 응용한다면 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>이분 탐색 구현도 구현이지만, N개의 집 좌표들에서 C개의 공유기를 설치하는데 최대한 설치되는 집의 거리를 벌려야 한다.</p>

<blockquote>
  <p>이 때, 중요한 점은 <strong>설치된 집과 설치될 집간의 최소거리</strong>를 잘 고려해야 한다.</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>1(집) 2 3 4 5(집) 6 7 8(집) 9 10 ...
</pre></td></tr></tbody></table></code></pre></div></div>

<p>위와 같이 <code class="language-plaintext highlighter-rouge">1, 5, 8</code> 위치에 집이 있을 경우 공유기를 1 위치인 집에 먼저 설치했다고 가정하자.</p>

<ul>
  <li>두번 째 집의 위치는 5로 첫번째 집과 4만큼 거리가 떨어져 있다.</li>
  <li>세번 째 집의 위치는 8로 두번째 집과 3만큼 거리가 떨어져 있다.</li>
</ul>

<p>이를 보면 왜 최소거리가 이 문제에서 중요한지 알 수 있을 것이다. 바로 <strong>직전에 공유기가 설치되었던 집과의 거리를 비교하며 최소 거리보다 먼 위치에 있는 집에 공유기를 설치</strong>해야 문제에서 요구하는 집 간의 거리를 벌릴 수 있게 되는 것이다.</p>

<blockquote>
  <p><strong>직전에 공유기를 설치한(가장 최근에 설치한) 집과 현재 집과의 거리를 기준</strong>으로 판단해야 한다.</p>
</blockquote>

<p>결국, 첫번째 집부터 공유기를 설치한 후, 첫번째 집부터 두번째 집에서 구해진 최초의 최소 거리를 기준으로 나머지 집들을 비교해가며 <strong>설치 해야할 공유기 대수(C)</strong>만큼 설치해나가면 되는 것이다.</p>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
        
        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="kt">int</span> <span class="no">C</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

        <span class="c1">// 집들의 위치를 담을 배열</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="o">}</span>
        
        <span class="c1">// 이분 탐색을 하기 위해 사전 정렬</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">);</span>

        <span class="c1">// 최소거리가 가지는 최소값</span>
        <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">// 최소거리가 가지는 최대값</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="no">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Upper Bound 형식으로 이분탐색 진행</span>
        <span class="k">while</span><span class="o">(</span><span class="n">min</span> <span class="o">&lt;</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>

            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">min</span> <span class="o">+</span> <span class="n">max</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="cm">/**
             * mid 거리에 대해서 설치 가능한 공유기 대수가 C개 미만일 경우
             * 거리를 좁혀야 하기 때문에 max를 mid로 갱신하여 줄인다.
             * 
             * 반대로, 설치 가능한 공유기 대수가 C개 초과일 경우
             * 거리를 벌리면서 최소거리가 가질 수 있는 최대거리를 찾아야 하기 때문에 min을 mid+1 값으로 늘린다.
             */</span>
            <span class="k">if</span><span class="o">(</span><span class="n">ableInstall</span><span class="o">(</span><span class="n">mid</span><span class="o">)</span> <span class="o">&lt;</span> <span class="no">C</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">max</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span> 
            <span class="k">else</span> <span class="o">{</span>
                <span class="n">min</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>

        <span class="o">}</span>
        
        <span class="c1">// Upper Bound를 통해 탐색 값을 초과하기에 1을 뺀다.</span>
        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">((</span><span class="n">min</span><span class="o">-</span><span class="mi">1</span><span class="o">)+</span><span class="s">"\n"</span><span class="o">);</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">int</span> <span class="nf">ableInstall</span><span class="o">(</span><span class="kt">int</span> <span class="n">distance</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// 첫번째 집은 무조건 설치하는 것을 가정한다.</span>
        <span class="kt">int</span> <span class="n">installCnt</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// 직전에 설치한 집의 위치(최초는 첫번째 집)</span>
        <span class="kt">int</span> <span class="n">lastPos</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>

            <span class="c1">// 현재 탐색하는 집의 위치</span>
            <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>

            <span class="cm">/**
             * 현재 탐색하는 집의 위치가 직전에 설치한 집의 위치와의 거리가 최소거리(distance)보다 크거나 같을 경우
             * 1. 현재 집에 공유기를 설치할 수 있으므로 installCnt를 1 늘려준다.
             * 2. 직전에 설치한 집의 위치인 lastPos를 갱신한다.
             */</span>
            <span class="k">if</span><span class="o">(</span><span class="n">pos</span> <span class="o">-</span> <span class="n">lastPos</span> <span class="o">&gt;=</span> <span class="n">distance</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">installCnt</span><span class="o">++;</span>
                <span class="n">lastPos</span> <span class="o">=</span> <span class="n">pos</span><span class="o">;</span>
            <span class="o">}</span>
            
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">installCnt</span><span class="o">;</span>

    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/2110">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[2110번 - 공유기 설치]]></summary></entry><entry><title type="html">[Java] 백준(브론즈-2) 5585번 - 거스름돈</title><link href="http://localhost:4000/java/208-post/" rel="alternate" type="text/html" title="[Java] 백준(브론즈-2) 5585번 - 거스름돈" /><published>2023-07-04T00:00:00+09:00</published><updated>2023-07-04T00:00:00+09:00</updated><id>http://localhost:4000/java/208-post</id><content type="html" xml:base="http://localhost:4000/java/208-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이 문제는 <strong>그리디 알고리즘</strong>를 이용해 푸는 대표적인 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>이 문제를 풀 수 있는 솔루션은 다음과 같다.</p>

<ol>
  <li>500, 100, 50, 10, 5, 1엔으로 이루어진 동전 목록을 선언한다.</li>
  <li>타로가 지불할 돈인 입력 값을 1000에서 뺄셈하여 반환할 거스름돈을 구한다.</li>
  <li>500엔부터 1엔까지 순서대로 동전 목록을 순회하며 해당 동전으로 거스름돈을 나눈 몫이 동전 개수가 된다.</li>
  <li>동전 개수를 구할 때마다 거스름돈을 빼주고, 총 동전개수에 더해준다.</li>
</ol>

<blockquote>
  <p>500엔부터 1엔까지 내림차순으로 순회하는 이유는 <strong>거스름돈 동전 개수를 최소화</strong>하기 위함이다.</p>
</blockquote>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
        
        <span class="c1">// 거스름돈으로 반환할 500, 100, 50, 10, 5, 1엔 동전 목록</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">coinList</span><span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">coinList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">500</span><span class="o">);</span>
        <span class="n">coinList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
        <span class="n">coinList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">50</span><span class="o">);</span>
        <span class="n">coinList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
        <span class="n">coinList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
        <span class="n">coinList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>

        <span class="c1">// 입력한 가격을 1000원에서 뺄셈하여 거스름돈 준비</span>
        <span class="kt">int</span> <span class="n">price</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">-</span><span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        
        <span class="c1">// 거스름돈으로 반환할 모든 동전의 개수</span>
        <span class="kt">int</span> <span class="n">totalCoinCnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="cm">/**
         * 동전 목록을 순회하며 거스름돈으로 줄 동전의 개수를 구한다.
         */</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">coinList</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">coinCnt</span> <span class="o">=</span> <span class="n">price</span> <span class="o">/</span> <span class="n">coinList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">price</span> <span class="o">-=</span> <span class="n">coinCnt</span> <span class="o">*</span> <span class="n">coinList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">totalCoinCnt</span> <span class="o">+=</span> <span class="n">coinCnt</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">totalCoinCnt</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/5585">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[5585번 - 거스름돈]]></summary></entry></feed>