<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-07-13T17:03:23+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">lango’s DevLog</title><subtitle>developer</subtitle><author><name>lango</name></author><entry><title type="html">[Java] 백준(실버-3) 1003번 - 피보나치 함수</title><link href="http://localhost:4000/java/220-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-3) 1003번 - 피보나치 함수" /><published>2023-07-13T00:00:00+09:00</published><updated>2023-07-13T00:00:00+09:00</updated><id>http://localhost:4000/java/220-post</id><content type="html" xml:base="http://localhost:4000/java/220-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 <strong>동적계획법 DP</strong>의 대표적인 예시인 피보나치 수열을 응응하여 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>이번 문제에서는 DP를 통해 피보나치 수열을 도출해내는 동시에 <strong>fibo(0)과 fibo(1)의 호출횟수</strong>를 각각 구해야 한다. 어떻게 0과 1의 호출횟수를 구할 수 있을까?</p>

<p><br /></p>

<p>간단한 에시를 보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="no">N</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">fibo</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="o">=</span> <span class="n">fibo</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">fibo</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>

<span class="no">N</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">fibo</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span> <span class="o">=</span> <span class="o">(</span><span class="n">fibo</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">fibo</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="o">+</span> <span class="n">fibo</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>위 예시처럼 N이 2일 때 0과 1은 각각 1번씩 호출되며, N이 3일 때는 0은 1번, 1은 2번 호출된다. 그렇다면, <strong>N에 대하여 0과 1이 호출된 횟수를 함께 저장</strong>하면 간단하다.</p>

<p>즉, 한 번 탐색할 때마다 N의 0과 1의 호출횟수를 DP 테이블에 저장한 후, 메모이제이션을 통해 이미 저장해둔 N의 호출횟수를 그대로 반환해주면 된다는 것이다.</p>

<p><br /></p>

<p>이를 통해 생각해낸 아이디어는 다음과 같다.</p>

<ol>
  <li>0과 1의 호출횟수를 함께 담아야 하기 때문에 <strong>DP 테이블을 2차원 배열로 선언</strong>한다.</li>
  <li>피보나치 함수(fibo)는 <strong>N에 대한 0과 1의 호출회수를 DP 테이블에 저장</strong>해가며 재귀함수를 호출한다.</li>
</ol>

<blockquote>
  <p>메모이제이션을 통해 이미 N에 대해 0과 1의 호출횟수를 구해두었다면 바로 반환한다.</p>
</blockquote>

<ol>
  <li>재귀함수 호출이 종료되면 해당 N의 대한 0과 1의 호출횟수를 1차원배열의 형태로 반환한다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// 피보나치 수와 N이 0과 1일 때의 호출횟수도 담아야 하기에 2차원 DP 배열 선언</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="no">D</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>

        <span class="kt">int</span> <span class="no">T</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="c1">// N의 범위는 최대 40이며, 0 과 1의 호출횟수를 함께 초기화</span>
        <span class="no">D</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">41</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="mi">40</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// N이 0일 때는 0의 호출횟수가 1, 1의 호출횟수는 0</span>
        <span class="no">D</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="no">D</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// N이 1일 때, 0의 호출횟수 0, 1의 호출횟수 1</span>
        <span class="no">D</span><span class="o">[</span><span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="no">D</span><span class="o">[</span><span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">T</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            
            <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>   
            
            <span class="c1">// 테스트케이스별로 N에 대한 피보나치 재귀함수를 실행한다.</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span> <span class="o">=</span> <span class="n">fibo</span><span class="o">(</span><span class="no">N</span><span class="o">);</span>

            <span class="c1">// 재귀 호출 이후 N에 대한 0과 1의 호출횟수를 출력한다.</span>
            <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">count</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">count</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="s">"\n"</span><span class="o">);</span>
            
        <span class="o">}</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>    

    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">fibo</span><span class="o">(</span><span class="kt">int</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>

        <span class="cm">/**
         * N에 대해 0과 1의 호출횟수를 구하지 않았을 경우 
         * 재귀를 통해 0과 1의 호춣횟수를 저장한다.
         */</span>
        <span class="k">if</span><span class="o">(</span><span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">fibo</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">)[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">fibo</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">2</span><span class="o">)[</span><span class="mi">0</span><span class="o">];</span>
            <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">fibo</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">)[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">fibo</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">2</span><span class="o">)[</span><span class="mi">1</span><span class="o">];</span>
        <span class="o">}</span>
        
        <span class="c1">// [메모이제이션] N에 대해 이미 0과 1의 호출횟수를 구해뒀을 경우 바로 반환한다.</span>
        <span class="k">return</span> <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>

    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/1003">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[1003번 - 피보나치 함수]]></summary></entry><entry><title type="html">[Java] 백준(실버-4) 18110번 - solved.ac</title><link href="http://localhost:4000/java/218-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-4) 18110번 - solved.ac" /><published>2023-07-13T00:00:00+09:00</published><updated>2023-07-13T00:00:00+09:00</updated><id>http://localhost:4000/java/218-post</id><content type="html" xml:base="http://localhost:4000/java/218-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 단순한 <strong>구현</strong> 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>문제에서 요구한 절사평균 30%을 적용하여 높은 값에서부터 15%, 낮은 값에서부터 15%를 제외한 후의 평균을 구하면 된다.</p>

<blockquote>
  <p>또한, 절사평균을 통해 높은 값과 낮은 값에서부터 데이터를 제외해야 한다는 것을 통해 <strong>데이터를 정렬해두고 제외해야 한다는 것</strong>을 꼭 고려해야 한다.</p>
</blockquote>

<p>위 사항만 잘 고려하고, 반올림만 잘 해주면 쉽게 풀 수 있다.</p>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
        
        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        
        <span class="c1">// 절사평균을 구한다.</span>
        <span class="kt">int</span> <span class="n">except</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="nc">Math</span><span class="o">.</span><span class="na">round</span><span class="o">((</span><span class="kt">double</span><span class="o">)</span> <span class="no">N</span> <span class="o">*</span> <span class="mi">15</span> <span class="o">/</span> <span class="mi">100</span><span class="o">);</span>

        <span class="c1">// 입력 배열을 만든다.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="c1">// 테스트케이스 예제 1을 보면 알겠지만 데이터가 오름차순 정렬되어 있어야 한다.</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">);</span>

        <span class="c1">// 총 난이도의 평균을 구할 변수 초기화</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// 절사평균을 통해 제외할 구간만을 순회하여 합을 담는다.</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">except</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">-</span><span class="n">except</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>
        
        <span class="c1">// 절사평균을 제외한 나머지의 평균을 구해 반올림한다.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="nc">Math</span><span class="o">.</span><span class="na">round</span><span class="o">((</span><span class="kt">double</span><span class="o">)</span><span class="n">result</span> <span class="o">/</span> <span class="o">(</span><span class="no">N</span> <span class="o">-</span> <span class="o">(</span><span class="n">except</span><span class="o">*</span><span class="mi">2</span><span class="o">)));</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>    

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/18110">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[18110번 - solved.ac]]></summary></entry><entry><title type="html">[Java] 백준(실버-2) 18111번 - 마인크래프트</title><link href="http://localhost:4000/java/219-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-2) 18111번 - 마인크래프트" /><published>2023-07-13T00:00:00+09:00</published><updated>2023-07-13T00:00:00+09:00</updated><id>http://localhost:4000/java/219-post</id><content type="html" xml:base="http://localhost:4000/java/219-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 <strong>완전 탐색</strong>을 이용해 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>이 문제는 완전탐색을 통해 주어진 2차원 배열을 순회하면서 조건에 부합하는지를 확인하면 된다.</p>

<p>문제 풀이를 위한 아이디어를 살펴보자.</p>

<ol>
  <li>땅을 평탄화하기 위해 쌓을 수 있는 <strong>최소 층과 최대 층 수</strong>를 구한다.</li>
  <li>층별로 블록을 채우거나 제거한 후의 <strong>블록의 개수가 0개 이상(양수)</strong>이어야 한다.</li>
  <li>층별로 평탄화 작업에 걸리는 시간을 통해 가장 적게 걸리는 <strong>최소시간</strong>과 그때의 <strong>층수</strong>를 구하면 된다.</li>
</ol>

<p><br /></p>

<p>말로만 들으면 잘 모를 수 있으니 예시를 들어보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="mi">2</span> <span class="mi">2</span> <span class="mi">2</span>
<span class="mi">5</span> <span class="mi">1</span>
<span class="mi">2</span> <span class="mi">5</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>위 입력예제를 들어보았을 때, 가장 낮은 블록의 높이는 1층부터 가장 높은 블록의 높이는 5층까지 존재한다. 이를 통해 우리가 평탄화를 통해 만들 수 있는 땅의 높이는 1층부터 5층까지 만들 수 있다는 것이다. 그러면 단순하게 1~5까지 순회하며 평탄화 작업을 실시하여 걸리는 시간을 계산하면 된다.</p>

<blockquote>
  <p>1층으로 만들 경우 <br /></p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="mi">5</span><span class="n">층</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="n">층으로</span> <span class="n">만들기</span> <span class="n">위해</span> <span class="n">블록을</span> <span class="n">제거한다</span><span class="o">.</span> <span class="n">얻는</span> <span class="n">블록의</span> <span class="n">수는</span> <span class="mi">4</span><span class="n">개이며</span><span class="o">,</span> <span class="n">평탄화</span> <span class="n">작업에</span> <span class="n">걸리는</span> <span class="n">시간은</span> <span class="mi">8</span><span class="n">초이다</span><span class="o">.</span>
<span class="mi">1</span><span class="n">층</span> <span class="o">-&gt;</span> <span class="n">층이</span> <span class="n">같기에</span> <span class="n">작업</span> <span class="n">필요</span> <span class="no">X</span>
<span class="mi">2</span><span class="n">층</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="n">층으로</span> <span class="n">만들기</span> <span class="n">위해</span> <span class="n">블록을</span> <span class="n">제거한다</span><span class="o">.</span> <span class="n">얻는</span> <span class="n">블록의</span> <span class="n">수는</span> <span class="mi">1</span><span class="n">개이며</span><span class="o">,</span> <span class="n">평탄화</span> <span class="n">작업에</span> <span class="n">걸리는</span> <span class="n">시간은</span> <span class="mi">2</span><span class="n">초이다</span><span class="o">.</span>
<span class="mi">5</span><span class="n">층</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="n">층으로</span> <span class="n">만들기</span> <span class="n">위해</span> <span class="n">블록을</span> <span class="n">제거한다</span><span class="o">.</span> <span class="n">얻는</span> <span class="n">블록의</span> <span class="n">수는</span> <span class="mi">4</span><span class="n">개이며</span><span class="o">,</span> <span class="n">평탄화</span> <span class="n">작업에</span> <span class="n">걸리는</span> <span class="n">시간은</span> <span class="mi">8</span><span class="n">초이다</span><span class="o">.</span>

<span class="n">총</span> <span class="n">평탄화</span> <span class="n">작업</span> <span class="nl">시간:</span> <span class="mi">18</span><span class="n">초</span>
<span class="n">인벤토리</span> <span class="n">블록의</span> <span class="nl">개수:</span> <span class="mi">11</span><span class="n">개</span><span class="o">(</span><span class="n">기존2개</span><span class="o">+</span><span class="mi">8</span><span class="n">개</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>2층으로 만들 경우 <br /></p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="mi">5</span><span class="n">층</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="n">층으로</span> <span class="n">만들기</span> <span class="n">위해</span> <span class="n">블록을</span> <span class="n">제거한다</span><span class="o">.</span> <span class="n">얻는</span> <span class="n">블록의</span> <span class="n">수는</span> <span class="mi">3</span><span class="n">개이며</span><span class="o">,</span> <span class="n">평탄화</span> <span class="n">작업에</span> <span class="n">걸리는</span> <span class="n">시간은</span> <span class="mi">6</span><span class="n">초이다</span><span class="o">.</span>
<span class="mi">1</span><span class="n">층</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="n">층으로</span> <span class="n">만들기</span> <span class="n">위해</span> <span class="n">블록을</span> <span class="n">채운다</span><span class="o">.</span> <span class="n">차감되는</span> <span class="n">블록</span> <span class="n">수는</span> <span class="o">-</span><span class="mi">1</span><span class="n">개이며</span><span class="o">,</span> <span class="n">평탄화</span> <span class="n">작업에</span> <span class="n">걸리는</span> <span class="n">시간은</span> <span class="mi">1</span><span class="n">초이다</span><span class="o">.</span>
<span class="mi">2</span><span class="n">층</span> <span class="o">-&gt;</span> <span class="n">층이</span> <span class="n">같기에</span> <span class="n">작업</span> <span class="n">필요</span> <span class="no">X</span>
<span class="mi">5</span><span class="n">층</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="n">층으로</span> <span class="n">만들기</span> <span class="n">위해</span> <span class="n">블록을</span> <span class="n">제거한다</span><span class="o">.</span> <span class="n">얻는</span> <span class="n">블록의</span> <span class="n">수는</span> <span class="mi">3</span><span class="n">개이며</span><span class="o">,</span> <span class="n">평탄화</span> <span class="n">작업에</span> <span class="n">걸리는</span> <span class="n">시간은</span> <span class="mi">6</span><span class="n">초이다</span><span class="o">.</span>

<span class="n">총</span> <span class="n">평탄화</span> <span class="n">작업</span> <span class="nl">시간:</span> <span class="mi">13</span><span class="n">초</span>
<span class="n">인벤토리</span> <span class="n">블록의</span> <span class="nl">개수:</span> <span class="mi">7</span><span class="n">개</span><span class="o">(</span><span class="n">기존2개</span><span class="o">+</span><span class="mi">5</span><span class="n">개</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>3층으로 만들 경우 <br /></p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="mi">5</span><span class="n">층</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="n">층으로</span> <span class="n">만들기</span> <span class="n">위해</span> <span class="n">블록을</span> <span class="n">제거한다</span><span class="o">.</span> <span class="n">얻는</span> <span class="n">블록의</span> <span class="n">수는</span> <span class="mi">2</span><span class="n">개이며</span><span class="o">,</span> <span class="n">평탄화</span> <span class="n">작업에</span> <span class="n">걸리는</span> <span class="n">시간은</span> <span class="mi">4</span><span class="n">초이다</span><span class="o">.</span>
<span class="mi">1</span><span class="n">층</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="n">층으로</span> <span class="n">만들기</span> <span class="n">위해</span> <span class="n">블록을</span> <span class="n">채운다</span><span class="o">.</span> <span class="n">차감되는</span> <span class="n">블록</span> <span class="n">수는</span> <span class="o">-</span><span class="mi">2</span><span class="n">개이며</span><span class="o">,</span> <span class="n">평탄화</span> <span class="n">작업에</span> <span class="n">걸리는</span> <span class="n">시간은</span> <span class="mi">2</span><span class="n">초이다</span><span class="o">.</span>
<span class="mi">2</span><span class="n">층</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="n">층으로</span> <span class="n">만들기</span> <span class="n">위해</span> <span class="n">블록을</span> <span class="n">채운다</span><span class="o">.</span> <span class="n">차감되는</span> <span class="n">블록</span> <span class="n">수는</span> <span class="o">-</span><span class="mi">1</span><span class="n">개이며</span><span class="o">,</span> <span class="n">평탄화</span> <span class="n">작업에</span> <span class="n">걸리는</span> <span class="n">시간은</span> <span class="mi">1</span><span class="n">초이다</span><span class="o">.</span>
<span class="mi">5</span><span class="n">층</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="n">층으로</span> <span class="n">만들기</span> <span class="n">위해</span> <span class="n">블록을</span> <span class="n">제거한다</span><span class="o">.</span> <span class="n">얻는</span> <span class="n">블록의</span> <span class="n">수는</span> <span class="mi">2</span><span class="n">개이며</span><span class="o">,</span> <span class="n">평탄화</span> <span class="n">작업에</span> <span class="n">걸리는</span> <span class="n">시간은</span> <span class="mi">4</span><span class="n">초이다</span><span class="o">.</span>

<span class="n">총</span> <span class="n">평탄화</span> <span class="n">작업</span> <span class="nl">시간:</span> <span class="mi">11</span><span class="n">초</span>
<span class="n">인벤토리</span> <span class="n">블록의</span> <span class="nl">개수:</span> <span class="mi">3</span><span class="n">개</span><span class="o">(</span><span class="n">기존2개</span><span class="o">+</span><span class="mi">1</span><span class="n">개</span><span class="o">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>4층으로 만들 경우 <br /></p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="mi">5</span><span class="n">층</span> <span class="o">-&gt;</span> <span class="mi">4</span><span class="n">층으로</span> <span class="n">만들기</span> <span class="n">위해</span> <span class="n">블록을</span> <span class="n">제거한다</span><span class="o">.</span> <span class="n">얻는</span> <span class="n">블록의</span> <span class="n">수는</span> <span class="mi">1</span><span class="n">개이며</span><span class="o">,</span> <span class="n">평탄화</span> <span class="n">작업에</span> <span class="n">걸리는</span> <span class="n">시간은</span> <span class="mi">2</span><span class="n">초이다</span><span class="o">.</span>
<span class="mi">1</span><span class="n">층</span> <span class="o">-&gt;</span> <span class="mi">4</span><span class="n">층으로</span> <span class="n">만들기</span> <span class="n">위해</span> <span class="n">블록을</span> <span class="n">채운다</span><span class="o">.</span> <span class="n">차감되는</span> <span class="n">블록</span> <span class="n">수는</span> <span class="o">-</span><span class="mi">3</span><span class="n">개이며</span><span class="o">,</span> <span class="n">평탄화</span> <span class="n">작업에</span> <span class="n">걸리는</span> <span class="n">시간은</span> <span class="mi">3</span><span class="n">초이다</span><span class="o">.</span>
<span class="mi">2</span><span class="n">층</span> <span class="o">-&gt;</span> <span class="mi">4</span><span class="n">층으로</span> <span class="n">만들기</span> <span class="n">위해</span> <span class="n">블록을</span> <span class="n">채운다</span><span class="o">.</span> <span class="n">차감되는</span> <span class="n">블록</span> <span class="n">수는</span> <span class="o">-</span><span class="mi">2</span><span class="n">개이며</span><span class="o">,</span> <span class="n">평탄화</span> <span class="n">작업에</span> <span class="n">걸리는</span> <span class="n">시간은</span> <span class="mi">2</span><span class="n">초이다</span><span class="o">.</span>
<span class="mi">5</span><span class="n">층</span> <span class="o">-&gt;</span> <span class="mi">4</span><span class="n">층으로</span> <span class="n">만들기</span> <span class="n">위해</span> <span class="n">블록을</span> <span class="n">제거한다</span><span class="o">.</span> <span class="n">얻는</span> <span class="n">블록의</span> <span class="n">수는</span> <span class="mi">1</span><span class="n">개이며</span><span class="o">,</span> <span class="n">평탄화</span> <span class="n">작업에</span> <span class="n">걸리는</span> <span class="n">시간은</span> <span class="mi">2</span><span class="n">초이다</span><span class="o">.</span>

<span class="n">총</span> <span class="n">평탄화</span> <span class="n">작업</span> <span class="nl">시간:</span> <span class="mi">9</span><span class="n">초</span>
<span class="n">인벤토리</span> <span class="n">블록의</span> <span class="nl">개수:</span> <span class="o">-</span><span class="mi">1</span><span class="n">개</span><span class="o">(</span><span class="n">기존2개</span><span class="o">+(-</span><span class="mi">3</span><span class="n">개</span><span class="o">))</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>5층으로 만들 경우 <br /></p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="mi">5</span><span class="n">층</span> <span class="o">-&gt;</span> <span class="n">층이</span> <span class="n">같기에</span> <span class="n">작업</span> <span class="n">필요</span> <span class="no">X</span>
<span class="mi">1</span><span class="n">층</span> <span class="o">-&gt;</span> <span class="mi">5</span><span class="n">층으로</span> <span class="n">만들기</span> <span class="n">위해</span> <span class="n">블록을</span> <span class="n">채운다</span><span class="o">.</span> <span class="n">차감되는</span> <span class="n">블록</span> <span class="n">수는</span> <span class="o">-</span><span class="mi">4</span><span class="n">개이며</span><span class="o">,</span> <span class="n">평탄화</span> <span class="n">작업에</span> <span class="n">걸리는</span> <span class="n">시간은</span> <span class="mi">4</span><span class="n">초이다</span><span class="o">.</span>
<span class="mi">2</span><span class="n">층</span> <span class="o">-&gt;</span> <span class="mi">5</span><span class="n">층으로</span> <span class="n">만들기</span> <span class="n">위해</span> <span class="n">블록을</span> <span class="n">채운다</span><span class="o">.</span> <span class="n">차감되는</span> <span class="n">블록</span> <span class="n">수는</span> <span class="o">-</span><span class="mi">3</span><span class="n">개이며</span><span class="o">,</span> <span class="n">평탄화</span> <span class="n">작업에</span> <span class="n">걸리는</span> <span class="n">시간은</span> <span class="mi">3</span><span class="n">초이다</span><span class="o">.</span>
<span class="mi">5</span><span class="n">층</span> <span class="o">-&gt;</span> <span class="n">층이</span> <span class="n">같기에</span> <span class="n">작업</span> <span class="n">필요</span> <span class="no">X</span>

<span class="n">총</span> <span class="n">평탄화</span> <span class="n">작업</span> <span class="nl">시간:</span> <span class="mi">7</span><span class="n">초</span>
<span class="n">인벤토리</span> <span class="n">블록의</span> <span class="nl">개수:</span> <span class="o">-</span><span class="mi">5</span><span class="n">개</span><span class="o">(</span><span class="n">기존2개</span><span class="o">+(-</span><span class="mi">7</span><span class="n">개</span><span class="o">))</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>위와 같이 1층부터 5층까지 평탄화 작업을 실시해가면서 구해낸 <strong>최소시간은 11초</strong>이며, <strong>11초가 걸리는 층수는 3층</strong>이 된다는 것을 볼 수 있다.</p>

<blockquote>
  <p>4층과 5층은 블록의 개수가 음수가 되어 블록을 채울 수 없기 때문에 조건에 부합하지 않는다.</p>
</blockquote>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
</pre></td><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">java_study</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
        
        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="kt">int</span> <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="kt">int</span> <span class="no">B</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">M</span><span class="o">];</span>

        <span class="c1">// 만들 수 있는 가장 낮은 층과 가장 높은 층</span>
        <span class="kt">int</span> <span class="n">min_height</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">max_height</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="no">M</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                <span class="n">min_height</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">min_height</span><span class="o">,</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]);</span>
                <span class="n">max_height</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max_height</span><span class="o">,</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 가장 낮은 층부터 가장 높은 층까지 작업에 걸리는 시간 중 최소시간을 담을 time 변수</span>
        <span class="kt">int</span> <span class="n">time</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        
        <span class="c1">// 최소시간일 경우 땅의 높이를 담을 floor 변수</span>
        <span class="kt">int</span> <span class="n">floor</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="cm">/**
         * 가장 낮은 층부터 높은 층까지 평탄화를 해가면서 층별로 걸리는 시간을 구한다.
         * 이때, 가장 최소시간이 걸리는 시간과 층수를 구하면 된다.
         */</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">idx</span><span class="o">=</span><span class="n">min_height</span><span class="o">;</span> <span class="n">idx</span><span class="o">&lt;=</span><span class="n">max_height</span><span class="o">;</span> <span class="n">idx</span><span class="o">++)</span> <span class="o">{</span>
            
            <span class="c1">// 층별로 작업에 걸리는 시간을 담을 sec 변수</span>
            <span class="kt">int</span> <span class="n">sec</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>            
            
            <span class="c1">// 층별로 작업 이후 인벤토리에 남은 블록의 개수</span>
            <span class="kt">int</span> <span class="n">block</span> <span class="o">=</span> <span class="no">B</span><span class="o">;</span>

            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="no">M</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                    
                    <span class="cm">/*
                     * 현재 블록의 높이가 만들어야 할 층보다 높다면 블록을 깎아 인벤토리에 넣는다.
                     * 블록을 깎을 때는 2배만큼 시간이 걸린다.
                     */</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">idx</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">sec</span> <span class="o">+=</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">-</span> <span class="n">idx</span><span class="o">)</span> <span class="o">*</span> <span class="mi">2</span><span class="o">;</span>
                        <span class="n">block</span> <span class="o">+=</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">-</span> <span class="n">idx</span><span class="o">);</span>
                    <span class="o">}</span>
                    <span class="cm">/**
                     * 현재 블록의 높이가 만드렁야 할 층보다 낮다면 인벤토리에 있는 블록으로 채운다.
                     * 블록을 채울 때는 1배만큼 시간이 걸린다.
                     */</span>
                    <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">idx</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">sec</span> <span class="o">+=</span> <span class="o">(</span><span class="n">idx</span> <span class="o">-</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]);</span>
                        <span class="n">block</span> <span class="o">-=</span> <span class="o">(</span><span class="n">idx</span> <span class="o">-</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]);</span>
                    <span class="o">}</span>
                    
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="c1">// 블록의 개수가 음수라면 블록을 채울 수가 없기 때문에 조건에 맞지 않는다.</span>
            <span class="k">if</span><span class="o">(</span><span class="n">block</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// 층별로 작업에 걸린 시간이 이전 층의 작업 시간보다 적다면, 현재 층의 작업시간과 층수를 저장한다.            </span>
            <span class="k">if</span><span class="o">(</span><span class="n">time</span> <span class="o">&gt;=</span> <span class="n">sec</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">time</span> <span class="o">=</span> <span class="n">sec</span><span class="o">;</span>      
                <span class="n">floor</span> <span class="o">=</span> <span class="n">idx</span><span class="o">;</span>
            <span class="o">}</span>
            
        <span class="o">}</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">time</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">floor</span> <span class="o">+</span> <span class="s">"\n"</span><span class="o">);</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>    

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/18111">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[18111번 - 마인크래프트]]></summary></entry><entry><title type="html">[Java] 백준(브론즈-2) 15829번 - Hashing</title><link href="http://localhost:4000/java/217-post/" rel="alternate" type="text/html" title="[Java] 백준(브론즈-2) 15829번 - Hashing" /><published>2023-07-12T00:00:00+09:00</published><updated>2023-07-12T00:00:00+09:00</updated><id>http://localhost:4000/java/217-post</id><content type="html" xml:base="http://localhost:4000/java/217-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 단순한 <strong>구현</strong> 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>이번 문제는 서브테스크 유형의 문제라 Small Case를 충족하면 50점, Large Case까지 충족하면 100점을 받을 수 있다.</p>

<p>처음엔 단순하게 생각하여 풀었더니 문자열 길이 50까지의 범위를 고려하지 못해 Small Case만 충족되어 50점을 달성하였다. 어떻게 Large Case까지 충족하여 100점을 받을 수 있을까 고민하고 개선하여 100점을 받았는데 그 아이디어를 살펴보자.</p>

<p>문제풀이를 위한 핵심 아이디어 2가지는 다음과 같다.</p>

<ol>
  <li>모듈러 연산</li>
  <li>수의 범위</li>
</ol>

<p><br /></p>

<h4 id="모듈러-연산">모듈러 연산</h4>

<p>이번 문제에서 100점을 받기 위해서는 <strong>모듈러 연산</strong>의 성질을 잘 이해해야 한다.</p>

<blockquote>
  <ol>
    <li>(A + B) mod C = (A mod C + B mod C) mod C</li>
    <li>(A - B) mod C = (A mod C - B mod C) mod C</li>
    <li>(A * B) mod C = (A mod C * B mod C) mod C</li>
  </ol>
</blockquote>

<p>위 성질을 통해 아래 연산식이 가능하다는 것을 알 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="n">a2r2</span> <span class="n">mod</span> <span class="no">M</span> <span class="o">=</span> <span class="o">(</span><span class="n">a2</span> <span class="n">mod</span> <span class="no">M</span> <span class="o">*</span> <span class="n">r2</span> <span class="n">mod</span> <span class="no">M</span><span class="o">)</span> <span class="n">mod</span> <span class="no">M</span>
<span class="n">r2</span> <span class="n">mod</span> <span class="no">M</span> <span class="o">=</span> <span class="o">(</span><span class="n">r</span> <span class="n">mod</span> <span class="no">M</span> <span class="o">*</span> <span class="n">r</span> <span class="n">mod</span> <span class="no">M</span><span class="o">)</span> <span class="n">mod</span> <span class="no">M</span>
<span class="n">r3</span> <span class="n">mod</span> <span class="no">M</span> <span class="o">=</span> <span class="o">(</span><span class="n">r2</span> <span class="n">mod</span> <span class="o">*</span> <span class="n">r</span> <span class="n">mod</span> <span class="no">M</span><span class="o">)</span> <span class="n">mod</span> <span class="no">M</span>
<span class="n">r4</span> <span class="n">mod</span> <span class="no">M</span> <span class="o">=</span> <span class="o">(</span><span class="n">r3</span> <span class="n">mod</span> <span class="no">M</span> <span class="o">*</span> <span class="n">r</span> <span class="n">mod</span> <span class="no">M</span><span class="o">)</span> <span class="n">mod</span> <span class="no">M</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><br /></p>

<h4 id="수의-범위">수의 범위</h4>
<p>또한, Math.pow() 메서드를 사용하여 31의 제곱수를 곱해주는 방식으로 구현했지만 Math.pow(31, 49)까지 간다면 long형의 범위도 벗어나기 때문에 해당 메소드를 사용하지 않고 <strong>pow를 일일이 곱</strong>해주면서 <strong>모듈러 연산을 통해 문제에서 제시한 M(=1234567891)보다 크기를 줄여</strong>가야 한다.</p>

<blockquote>
  <p>그래서 pow로 사용하는 변수와 해시 함수의 결과값을 더해줄 결과값 변수는 long 형으로 선언해서 사용해야 한다.</p>
</blockquote>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
        
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">hm</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">97</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">123</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">hm</span><span class="o">.</span><span class="na">put</span><span class="o">((</span><span class="kt">char</span><span class="o">)</span><span class="n">i</span><span class="o">,</span> <span class="n">i</span><span class="o">-</span><span class="mi">96</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="no">M</span> <span class="o">=</span> <span class="mi">1234567891</span><span class="o">;</span>

        <span class="kt">int</span> <span class="no">L</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>

        <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">long</span> <span class="n">pow</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Math.pow() 메서드를 사용하면 long형의 범위를 벗어나기 때문에 Large 케이스를 통과할 수 없다.</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">L</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">char</span> <span class="n">alph</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="o">(</span><span class="n">hm</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">alph</span><span class="o">)</span> <span class="o">*</span> <span class="n">pow</span><span class="o">)</span> <span class="o">%</span> <span class="no">M</span><span class="o">;</span>
            <span class="n">pow</span> <span class="o">=</span> <span class="o">(</span><span class="n">pow</span> <span class="o">*</span> <span class="mi">31</span><span class="o">)</span> <span class="o">%</span> <span class="no">M</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">((</span><span class="n">result</span><span class="o">%</span><span class="no">M</span><span class="o">)+</span><span class="s">"\n"</span><span class="o">);</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>    

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/15829">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[15829번 - Hashing]]></summary></entry><entry><title type="html">[Java] 백준(실버-5) 1676번 - 팩토리얼 0의 개수</title><link href="http://localhost:4000/java/216-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-5) 1676번 - 팩토리얼 0의 개수" /><published>2023-07-12T00:00:00+09:00</published><updated>2023-07-12T00:00:00+09:00</updated><id>http://localhost:4000/java/216-post</id><content type="html" xml:base="http://localhost:4000/java/216-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 단순한 <strong>구현</strong> 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>이 문제는 단순히 N!의 값을 팩토리얼 연산을 통해 구해서 0을 구할 수 있지만, 입력값의 범위를 생각하면 출제자의 의도는 다른 것이라는 것을 알 수 있다.</p>

<blockquote>
  <p>최대 500! 까지의 값을 구해야 하는데 BigInteger 클래스를 사용해야만 500! 까지의 값을 구할 수 있다.</p>
</blockquote>

<p>물론, BigInteger 클래스를 사용하여 팩토리얼 연산 후 0의 개수를 셀 수도 있겠지만, 여기서는 출제자가 의도한 0의 개수를 세는 것은 다른 방법을 이용하려고 한다.</p>

<p>N!의 값에서 뒷자리가 0이 나오는 경우를 잘 생각해보면 10으로 나누어 떨어질 때를 생각해볼 수 있다. 이 말은, <strong>소인수분해를 해서 2와 5가 존재할 경우 뒷자리는 0으로 끝난다</strong>고 볼 수 있다.</p>

<p>예시를 한번 들어보자.</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">30 = 2*3*5</code> <br />
<code class="language-plaintext highlighter-rouge">231400 = 23*52*13*89</code></p>
</blockquote>

<p>30과 231400 모두 2와 5가 포함된다. 즉, 소인수분해의 성질을 이용해야 한다는 것이다.</p>

<p>소인수분해의 성질을 통해 살펴보면, 뒷자리가 0이 N개 있다는 것은 2와 5개 N개씩 쌍으로 존재한다는 것을 알 수 있다.</p>

<p>30과 231400이라는 수도 소인수분해값을 보면 30은 2와 5가 1개씩 쌍으로 1개가 있으며, 231400은 2는 3개, 5는 2개가 있어 쌍으로 2ㅐ가 있다. 30의 0의 개수는 1개, 231400의 0의 개수는 2개라고 보면 된다.</p>

<p>그런데, N!의 값을 보면 2는 5보다 작기 때문에 소인수분해시, 2의 개수는 5의 개수보다 많게 된다. 그래서 <strong>5의 개수에 초점</strong>을 두어야 한다.</p>

<p><br /></p>

<p>문제 풀이를 위한 생각한 아이디어는 다음과 같다.</p>

<ul>
  <li>N을 5로 나눠가면서 5로 나눌때마다 카운트를 세면 된다.
    <blockquote>
      <p>N을 5를 나눠가며 갱신할 때마다 카운트를 하는 것이 0의 개수를 세는 것과 같다.</p>
    </blockquote>
  </li>
</ul>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
        
        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        
        <span class="k">while</span><span class="o">(</span><span class="no">N</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="o">)</span> <span class="o">{</span>
            <span class="no">N</span> <span class="o">/=</span> <span class="mi">5</span><span class="o">;</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="no">N</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>    

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/1676">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[1676번 - 팩토리얼 0의 개수]]></summary></entry><entry><title type="html">[Java] 백준(실버-5) 1475번 - 방 번호</title><link href="http://localhost:4000/java/215-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-5) 1475번 - 방 번호" /><published>2023-07-11T00:00:00+09:00</published><updated>2023-07-11T00:00:00+09:00</updated><id>http://localhost:4000/java/215-post</id><content type="html" xml:base="http://localhost:4000/java/215-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 단순한 <strong>구현</strong> 문제로 문제가 요구하는 내용을 잘 파악한다면 쉽게 풀 수 있다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>문제 풀이를 위한 생각한 아이디어는 다음과 같다.</p>

<ol>
  <li>0부터 9까지의 원소의 빈도수를 카운팅하기 위해 <strong>카운팅 배열</strong>을 이용한다.</li>
  <li>주어진 방 번호대로 0부터 9까지 빈도수를 센 후, 6과 9는 뒤집어서 쓸 수 있기 때문에 같은 수로 취급한다. <br />
 2.1 6과 9의 카운트의 합이 짝수이면 6과 9의 빈도수를 각각 반으로 나눠주고, 홀수라면 반으로 나눠준 뒤, 한번 더 사용해야 하기 때문에 1씩 증가시킨다.</li>
  <li>카운팅 배열에 원소 중 가장 많은 빈도수가 필요한 세트 수가 된다.</li>
  <li>오름차순/내림차순 정렬 후 최대값 인덱스 접근이나 반복문을 돌며 최대값을 찾는 방법으로 배열의 최대값을 구하면 된다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
        
        <span class="c1">// 카운팅 배열을 사용한다.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">10</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="nc">String</span> <span class="no">N</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="nc">Character</span><span class="o">.</span><span class="na">getNumericValue</span><span class="o">(</span><span class="no">N</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">num</span><span class="o">]++;</span>            
        <span class="o">}</span>

        <span class="cm">/**
         * 6과 9의 경우 바꿔서 사용할 수 있다.
         * 그래서 6과 9의 빈도수를 함께 계산한다.
         * - 짝수라면 각각 반씩 나눈다.
         * - 홀수라면 반씩 나눈 후 1씩을 추가한다.(반씩 나누어도 한 번 더 사용해야 하기 때문)
         */</span>
        <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="mi">6</span><span class="o">]</span> <span class="o">+</span> <span class="n">arr</span><span class="o">[</span><span class="mi">9</span><span class="o">];</span>
        
        <span class="k">if</span><span class="o">(</span><span class="n">temp</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">arr</span><span class="o">[</span><span class="mi">6</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
            <span class="n">arr</span><span class="o">[</span><span class="mi">9</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">arr</span><span class="o">[</span><span class="mi">6</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="n">temp</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="n">arr</span><span class="o">[</span><span class="mi">9</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="n">temp</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="c1">// 필요한 세트 수는 배열의 최댓값이기에 arr 배열을 오름차순 정렬한다.</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">);</span>
        
        <span class="c1">// 배열의 마지막 원소가 필요한 세트 수가 된다.</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="mi">9</span><span class="o">];</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>    

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/1475">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[1475번 - 방 번호]]></summary></entry><entry><title type="html">[Java] 프로그래머스(level-2) - 방문 길이</title><link href="http://localhost:4000/java/214-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-2) - 방문 길이" /><published>2023-07-10T00:00:00+09:00</published><updated>2023-07-10T00:00:00+09:00</updated><id>http://localhost:4000/java/214-post</id><content type="html" xml:base="http://localhost:4000/java/214-post/"><![CDATA[<p><br /></p>

<center><img src="/assets/images/programmers/" width="100%" /></center>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />

<p>이 문제는 <strong>HashSet 자료구조</strong> 를 이용해 풀 수 있다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>HashSet 자료구조를 사용해보기 전에는, 단순히 상, 하, 좌, 우로 이동한 횟수를 카운트 했었는데, 이미 다녀온 중복 이동을 고려하기 어려웠다. 이를 HashSet으로 중복을 제거하여 해결할 수 있었다.</p>

<p>문제 풀이를 위한 아이디어는 다음과 같다.</p>

<ol>
  <li>(0,0) 위치부터 dirs 문자열을 순회하여 <code class="language-plaintext highlighter-rouge">U, D, L, R</code> 명령에 따라 1,-1씩 움직인다.</li>
  <li>상, 하, 좌, 우로 움직일 경우를 각각 고려하여 문자열에 위치정보를 담는다.</li>
  <li>움직인 위치가 이동 칸의 범위(최소 -5, 최대 5)를 벗어나지 않았다면 HashSet에 위치정보를 담은 문자열을 삽입하고 현재 위치를 움직인 위치로 갱신한다.</li>
  <li><strong>HashSet의 크기가 곧 이동횟수</strong>가 된다.</li>
</ol>

<p><br /></p>

<h4 id="어떻게-다녀온-위치-중복을-제거하나">어떻게 다녀온 위치 중복을 제거하나?</h4>

<p>HashSet에 삽입하여 중복을 제거하기 위해 String 문자열에 위치를 담아서 중복을 해결했는데 그 절차는 다음과 같다.</p>

<p>상, 우 로 움직일 경우 <code class="language-plaintext highlighter-rouge">[현재x좌표][현재y좌표][다음x좌표][다음y좌표]</code> 형식으로 문자열을 만들고, 
하, 좌 로 움직일 경우 <code class="language-plaintext highlighter-rouge">[다음x좌표][다음y좌표][현재x좌표][현재y좌표]</code> 형식으로 문자열을 만든다.</p>

<blockquote>
  <p>U
<code class="language-plaintext highlighter-rouge">"[현재x좌표][현재y좌표][다음x좌표][다음y좌표]"</code></p>
</blockquote>

<blockquote>
  <p>D
<code class="language-plaintext highlighter-rouge">"[다음x좌표][다음y좌표][현재x좌표][현재y좌표]"</code></p>
</blockquote>

<blockquote>
  <p>R
<code class="language-plaintext highlighter-rouge">"[다음x좌표][다음y좌표][현재x좌표][현재y좌표]"</code></p>
</blockquote>

<blockquote>
  <p>L
<code class="language-plaintext highlighter-rouge">"[현재x좌표][현재y좌표][다음x좌표][다음y좌표]"</code></p>
</blockquote>

<p>이렇게 문자열을 구성하면 이동시 중복되는 위치의 중복을 해결할 수 있게 된다.</p>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
</pre></td><td class="rouge-code"><pre>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="nc">String</span> <span class="n">dirs</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// 방문 위치를 담을 HashSet</span>
        <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
        
        <span class="c1">// 11*11 크기의 배열의 중심점 (0,0)</span>
        <span class="kt">int</span> <span class="n">nowX</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">nowY</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">idx</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">idx</span><span class="o">&lt;</span><span class="n">dirs</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">idx</span><span class="o">++)</span> <span class="o">{</span>

            <span class="c1">// 다음으로 이동할 좌표 초기화</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">nowX</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">nowY</span><span class="o">;</span>
            
            <span class="c1">// 위치정보를 문자열 형태로 담기 위한 변수</span>
            <span class="nc">String</span> <span class="n">location</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>

            <span class="cm">/**
             * 상: y좌표+1, [nowX][nowY][nextX][nextY]
             * 하: y좌표-1, [nextX][nextY][nowX][nowY]
             * 좌: x좌표-1, [nextX][nextY][nowX][nowY]
             * 우: x좌표+1, [nowX][nowY][nextX][nextY]
             */</span> 
            <span class="k">switch</span><span class="o">(</span><span class="n">dirs</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">idx</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">case</span> <span class="sc">'U'</span><span class="o">:</span>
                    <span class="n">y</span><span class="o">++;</span>
                    <span class="n">location</span> <span class="o">+=</span> <span class="n">nowX</span><span class="o">;</span>
                    <span class="n">location</span> <span class="o">+=</span> <span class="n">nowY</span><span class="o">;</span>
                    <span class="n">location</span> <span class="o">+=</span> <span class="n">x</span><span class="o">;</span>
                    <span class="n">location</span> <span class="o">+=</span> <span class="n">y</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="k">case</span> <span class="sc">'D'</span><span class="o">:</span>
                    <span class="n">y</span><span class="o">--;</span>
                    <span class="n">location</span> <span class="o">+=</span> <span class="n">x</span><span class="o">;</span>
                    <span class="n">location</span> <span class="o">+=</span> <span class="n">y</span><span class="o">;</span>
                    <span class="n">location</span> <span class="o">+=</span> <span class="n">nowX</span><span class="o">;</span>
                    <span class="n">location</span> <span class="o">+=</span> <span class="n">nowY</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="k">case</span> <span class="sc">'R'</span><span class="o">:</span>
                    <span class="n">x</span><span class="o">++;</span>
                    <span class="n">location</span> <span class="o">+=</span> <span class="n">nowX</span><span class="o">;</span>
                    <span class="n">location</span> <span class="o">+=</span> <span class="n">nowY</span><span class="o">;</span>
                    <span class="n">location</span> <span class="o">+=</span> <span class="n">x</span><span class="o">;</span>
                    <span class="n">location</span> <span class="o">+=</span> <span class="n">y</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="k">case</span> <span class="sc">'L'</span><span class="o">:</span>
                    <span class="n">x</span><span class="o">--;</span>
                    <span class="n">location</span> <span class="o">+=</span> <span class="n">x</span><span class="o">;</span>
                    <span class="n">location</span> <span class="o">+=</span> <span class="n">y</span><span class="o">;</span>
                    <span class="n">location</span> <span class="o">+=</span> <span class="n">nowX</span><span class="o">;</span>
                    <span class="n">location</span> <span class="o">+=</span> <span class="n">nowY</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="k">default</span><span class="o">:</span>
                    <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// 좌표 범위 벗어나면 이동하지 않음</span>
            <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">5</span> <span class="o">||</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="o">||</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">5</span> <span class="o">||</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="n">visited</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">location</span><span class="o">);</span>

            <span class="c1">// 현재 위치를 이동한 위치로 갱신</span>
            <span class="n">nowX</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
            <span class="n">nowY</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>

        <span class="o">}</span>

        <span class="k">return</span> <span class="n">visited</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>

    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        
        <span class="c1">// String dirs = "ULURRDLLU";</span>
        <span class="c1">// String dirs = "LULLLLLLU";</span>
        <span class="c1">// String dirs = "LURDLURDLURDLURDRULD";</span>
        <span class="c1">// String dirs = "RRRRRRRRRRRRRRRRRRRRRUUUUUUUUUUUUULU";</span>
        <span class="c1">// String dirs = "RRRRRLLLLL";</span>
        <span class="nc">String</span> <span class="n">dirs</span> <span class="o">=</span> <span class="s">"UDU"</span><span class="o">;</span>

        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">dirs</span><span class="o">);</span>

    <span class="o">}</span>

<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<ul>
  <li>
    <hr />
  </li>
</ul>

<p><br /></p>

<h3 id="출처">출처</h3>
<p>-
—</p>

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://school.programmers.co.kr/learn/courses/30/lessons/49994">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 2 - 방문 길이]]></summary></entry><entry><title type="html">[Java] LeetCode(Easy) - 1. Two Sum</title><link href="http://localhost:4000/java/213-post/" rel="alternate" type="text/html" title="[Java] LeetCode(Easy) - 1. Two Sum" /><published>2023-07-08T00:00:00+09:00</published><updated>2023-07-08T00:00:00+09:00</updated><id>http://localhost:4000/java/213-post</id><content type="html" xml:base="http://localhost:4000/java/213-post/"><![CDATA[<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />

<p>배열의 원소를 순회하며 두 수의 합이 target이 되는지 판단하면 되는 간단한 문제이다. 필자는 완전탐색과 HashMap 2가지를 이용해서 풀어보았다.</p>

<p><br /></p>

<h4 id="아이디어-도출---완전탐색">아이디어 도출 - 완전탐색</h4>

<p>완전탐색의 경우 문제 요구사항 그대로 구현하면 된다.</p>

<ol>
  <li>nums 배열을 순회하며 자리별로 두 수의 합이 target이 되는 인덱스가 있을 경우 List에 삽입한다.</li>
  <li>삽입된 List를 Array로 반환한다.</li>
</ol>

<blockquote>
  <p>완전탐색을 할 경우, 시간복잡도가 O(n^2)이기에 비효율적이다.</p>
</blockquote>

<p><br /></p>

<h4 id="아이디어-도출---hashmap">아이디어 도출 - HashMap</h4>

<p>HashMap을 이용하면 완전탐색 풀이에 비교하면 O(n)으로 보다 효율적인 성능을 보여준다.</p>

<ol>
  <li>nums 배열을 순회하며 배열의 원소를 key로, 인덱스를 value로 HashMap에 삽입한다.</li>
  <li><code class="language-plaintext highlighter-rouge">target - 원소</code> 값이 HashMap에 존재한다면, 두 수의 합을 만들 수 있다고 가정하여, <code class="language-plaintext highlighter-rouge">target - 원소</code> 값의 인덱스와 현재 원소의 인덱스를 반환한다.</li>
</ol>

<p><br /></p>

<p>위와 같이 2가지 방식으로 문제를 풀어보았다. 문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LeetCode</span> <span class="o">{</span>

    <span class="c1">// 완전탐색의 경우 시간복잡도 O(n^2)의 시간이 걸리기에 비효율적이다.</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum1</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
     
        <span class="c1">// 두 수를 담을 List</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// nums 배열을 순회하면서 두 수의 합이 target이 되는 인덱스를 구한다.</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// List를 Array로 반환한다.</span>
        <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">mapToInt</span><span class="o">(</span><span class="nl">Integer:</span><span class="o">:</span><span class="n">intValue</span><span class="o">).</span><span class="na">toArray</span><span class="o">();</span>

    <span class="o">}</span>

    <span class="c1">// 시간복잡도 O(n)으로 풀기 위해 HashMap을 사용한다.</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">twoSum2</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">,</span> <span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
     
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">hm</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">hm</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="o">{</span>
                <span class="n">answer</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">hm</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                <span class="n">answer</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
                
            <span class="o">}</span>
            <span class="n">hm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>

    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="nc">LeetCode</span> <span class="n">leetCode</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LeetCode</span><span class="o">();</span>

        <span class="kt">int</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">6</span><span class="o">;</span>

        <span class="c1">// int[] nums = new int[]{2, 7, 11, 15};</span>
        <span class="c1">// int[] nums = new int[]{11, 7, 15, 2};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">};</span>
        
        <span class="n">leetCode</span><span class="o">.</span><span class="na">twoSum2</span><span class="o">(</span><span class="n">nums</span><span class="o">,</span> <span class="n">target</span><span class="o">);</span>

    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<ul>
  <li></li>
</ul>

<h3 id="출처">출처</h3>
<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://leetcode.com/problems/two-sum/">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="leetcode" /><summary type="html"><![CDATA[Easy - 1. Two Sum]]></summary></entry><entry><title type="html">[Java] 프로그래머스(level-2) - 땅따먹기</title><link href="http://localhost:4000/java/211-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-2) - 땅따먹기" /><published>2023-07-07T00:00:00+09:00</published><updated>2023-07-07T00:00:00+09:00</updated><id>http://localhost:4000/java/211-post</id><content type="html" xml:base="http://localhost:4000/java/211-post/"><![CDATA[<p><br /></p>

<center><img src="/assets/images/programmers/" width="100%" /></center>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />

<p>이 문제는 <strong>동적 계획법, DP</strong> 를 이용한 방법으로 적은 수의 라인으로 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="그리디-완전탐색">그리디? 완전탐색?</h4>

<p>사실, 문제를 보고 그리디 알고리즘이나 완전탐색으로 접근하려 했으나 두 가지 모두 문제 통과는 어렵다고 판단하였다.</p>

<p>그리디 알고리즘을 적용할 경우 최선의 값을 선택하기에 좋은 솔루션으로 생각할 수도 있겠지만, 문제에서 주어지는 행에서의 최대값을 선택한다고 마지막 행까지의 덧셈을 통해 최댓값이 구해지는 것은 아니다. 아래 예시를 보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span>
<span class="o">[</span><span class="mi">9</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">6</span><span class="o">]</span>
<span class="o">[</span><span class="mi">10</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">]</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>위 배열을 보면 4 -&gt; 9 -&gt; 4 로 최대값을 선택하면서 내려왔다면 값은 17이다.
다만, 4 -&gt; 7-&gt; 10 이나 3 -&gt; 8 -&gt; 10을 선택하면서 내려왔다면 21이라는 최대값을 만들 수 있다.</p>

<blockquote>
  <p>여기서 알 수 있는 점은 <strong>매 행에서 최대값을 선택하는 그리디 알고리즘을 적용하는 것은 적절하지 않다</strong>는 것이다!</p>
</blockquote>

<p>또한 <strong>N의 범위는 최대 100,000이기에 완전 탐색을 이용하기엔 시간초과</strong>가 걸린다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>그렇다면 행마다 한번씩 내려가면서, 최고의 합을 기록하며 내려간다면 어떻게 될까? 위에서 살펴 본 배열을 한 번더 예시로 들어보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span>
<span class="o">[</span><span class="mi">9</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">6</span><span class="o">]</span>
<span class="o">[</span><span class="mi">10</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">]</span>

<span class="c1">// 두번째 행을 최고의 합으로 갱신</span>
<span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span>
<span class="o">[</span><span class="mi">13</span><span class="o">(</span><span class="mi">9</span><span class="o">+</span><span class="mi">4</span><span class="o">),</span> <span class="mi">11</span><span class="o">(</span><span class="mi">8</span><span class="o">+</span><span class="mi">3</span><span class="o">),</span> <span class="mi">11</span><span class="o">(</span><span class="mi">7</span><span class="o">+</span><span class="mi">4</span><span class="o">),</span> <span class="mi">10</span><span class="o">(</span><span class="mi">6</span><span class="o">+</span><span class="mi">4</span><span class="o">)]</span>
<span class="o">[</span><span class="mi">10</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">]</span>

<span class="c1">// 마지막 행을 최고의 합으로 갱신</span>
<span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span>
<span class="o">[</span><span class="mi">13</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">10</span><span class="o">]</span>
<span class="o">[</span><span class="mi">21</span><span class="o">(</span><span class="mi">10</span><span class="o">+</span><span class="mi">11</span><span class="o">),</span> <span class="mi">17</span><span class="o">(</span><span class="mi">4</span><span class="o">+</span><span class="mi">13</span><span class="o">),</span> <span class="mi">15</span><span class="o">(</span><span class="mi">2</span><span class="o">+</span><span class="mi">13</span><span class="o">),</span> <span class="mi">14</span><span class="o">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">13</span><span class="o">)]</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>위와 같이 내려오면서 land 배열의 각 자리마다 이전 행의 최대값을 더해주면서 내려온다면 마지막 행에서 21이라는 최대값을 반환하기만 된다는 것을 알 수 있다.</p>

<p>결국, 위와 같은 방법으로 <strong>배열의 각 자리를 갱신하면서 마지막 행에서 가장 큰 값을 가진 값을 반환</strong>하면 된다!</p>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre></td><td class="rouge-code"><pre>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">land</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">land</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="cm">/**
         * 행을 한번씩 내려가면서, 내려올때의 최고의 합을 land에 기록해나간다.
         * 
         * 배열의 2번째 행부터 현재 칸과 이전 행의 최댓값을 더한 값으로 갱신해나간다.
         * 이때, 이전에 최댓값이 된 칸의 경우 같은 칸을 더하지 않도록 한다.
         */</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">+=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">],</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">2</span><span class="o">],</span> <span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">3</span><span class="o">]));</span>
            <span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">+=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">2</span><span class="o">],</span> <span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">3</span><span class="o">]));</span>
            <span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">2</span><span class="o">]</span> <span class="o">+=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">],</span> <span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">3</span><span class="o">]));</span>
            <span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">3</span><span class="o">]</span> <span class="o">+=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">],</span> <span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">2</span><span class="o">]));</span>
        <span class="o">}</span>

        <span class="c1">// 마지막 행 중 최대값을 구하여 반환한다.</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">land</span><span class="o">[</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">answer</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">answer</span><span class="o">,</span> <span class="n">num</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        
        <span class="c1">// int[][] land = new int[][]{{1,2,3,5},</span>
        <span class="c1">//                         {5,6,7,8},</span>
        <span class="c1">//                         {4,3,2,1}};</span>

        <span class="c1">// int[][] land = new int[][]{{1,1,1,1},</span>
        <span class="c1">//                             {2,2,2,3},</span>
        <span class="c1">//                             {3,3,3,6},</span>
        <span class="c1">//                             {4,4,4,7}};</span>

        <span class="kt">int</span><span class="o">[][]</span> <span class="n">land</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[][]{{</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">},</span>
                                    <span class="o">{</span><span class="mi">9</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">6</span><span class="o">},</span>
                                    <span class="o">{</span><span class="mi">10</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">}};</span>

        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">land</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<ul>
  <li>
    <hr />
  </li>
</ul>

<p><br /></p>

<h3 id="출처">출처</h3>
<p>-
—</p>

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://school.programmers.co.kr/learn/courses/30/lessons/12913">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 2 - 땅따먹기]]></summary></entry><entry><title type="html">[Java] 백준(골드-5) 15686번 - 치킨 배달</title><link href="http://localhost:4000/java/212-post/" rel="alternate" type="text/html" title="[Java] 백준(골드-5) 15686번 - 치킨 배달" /><published>2023-07-07T00:00:00+09:00</published><updated>2023-07-07T00:00:00+09:00</updated><id>http://localhost:4000/java/212-post</id><content type="html" xml:base="http://localhost:4000/java/212-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 <strong>DFS를 통한 백트래킹</strong>을 이용해 풀 수 있다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>문제 풀이를 위해 생각한 아이디어는 다음과 같다.</p>

<ol>
  <li>집과 치킨집의 위치를 미리 저장한다.</li>
  <li>M개만큼 뽑은 치킨집은 방문 여부를 체크하여 도시의 치킨 거리를 구할 때 사용한다.</li>
  <li>M개의 치킨집을 모두 뽑았다면, 모든 집의 위치에서 최소거리에 있는 치킨집과의 거리을 구한다.</li>
  <li>그렇게 모든 치킨집과의 최소거리를 계산한다면, 모든 도시의 치킨거리 중 최솟값을 구하면 된다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// 방문배열과 입력배열</span>
    <span class="kd">static</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">map</span><span class="o">;</span>
    
    <span class="c1">// 집과 치킨집 좌표를 저장할 List</span>
    <span class="kd">static</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">house</span><span class="o">;</span>
    <span class="kd">static</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">chicken</span><span class="o">;</span>
    
    <span class="c1">// 입력배열의 크기인 N과 깊이 M</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="no">N</span><span class="o">,</span> <span class="no">M</span><span class="o">;</span>

    <span class="c1">// 도시의 치킨거리 최솟값을 저장할 변수</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">result</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
        
        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

        <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">N</span><span class="o">];</span> 
        <span class="n">house</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">chicken</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>


        <span class="cm">/**
         * 위치들을 입력받으며 house, chicken List 초기화
         */</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                
                <span class="c1">// 집의 위치와 치킨집의 위치를 저장</span>
                <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">house</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">});</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">chicken</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">});</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 치킨집 크기만큼 방문 배열을 초기화</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">chicken</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>  
        
        <span class="c1">// 최솟값을 구해야 하므로 result를 Integer.MAX_VALUE 값으로 초기화</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

        <span class="c1">// DFS 재귀함수 호출</span>
        <span class="n">recursion</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 백트래킹을 진행할 DFS 재귀함수
     * depth(깊이)가 M과 같아지면 선택한 치킨집과 집과의 치킨 거리를 구한다.
     * 치킨거리 중 최솟값을 누적시키며, 모든 도시의 치킨 거리 중 최솟값을 구한다.
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">recursion</span><span class="o">(</span><span class="kt">int</span> <span class="n">depth</span><span class="o">,</span> <span class="kt">int</span> <span class="n">at</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="k">if</span><span class="o">(</span><span class="n">depth</span> <span class="o">==</span> <span class="no">M</span><span class="o">)</span> <span class="o">{</span>            
            
            <span class="c1">// 도시의 치킨거리</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">house</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

                <span class="c1">// 집과 치킨 집 중 방문한 치킨집의 모든 거리를 비교하며 최소거리를 구한다.</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">chicken</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
                        <span class="c1">// 해당 집의 치킨 거리 |r1-c1|+|r2-c2|</span>
                        <span class="kt">int</span> <span class="n">distance</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">house</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">chicken</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">)[</span><span class="mi">0</span><span class="o">])</span>
                                    <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">house</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">chicken</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">)[</span><span class="mi">1</span><span class="o">]);</span>
                        <span class="n">min</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">min</span><span class="o">,</span> <span class="n">distance</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">min</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="n">result</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">sum</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>

        <span class="o">}</span>

        <span class="c1">// 백트래킹 탐색 진행</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">at</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">chicken</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// 방문 여부를 통해 가지치기</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="n">recursion</span><span class="o">(</span><span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
                <span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>

        <span class="o">}</span>
        
    <span class="o">}</span>    

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/15686">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[15686번 - 치킨 배달]]></summary></entry></feed>