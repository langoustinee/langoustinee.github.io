<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-08-09T15:44:42+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">lango’s DevLog</title><subtitle>developer</subtitle><author><name>lango</name></author><entry><title type="html">[Java] 프로그래머스(level-2) - 파일명 정렬</title><link href="http://localhost:4000/java/247-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-2) - 파일명 정렬" /><published>2023-08-09T00:00:00+09:00</published><updated>2023-08-09T00:00:00+09:00</updated><id>http://localhost:4000/java/247-post</id><content type="html" xml:base="http://localhost:4000/java/247-post/"><![CDATA[<p><br /></p>

<center><img src="/assets/images/programmers/" width="100%" /></center>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />

<p>이번 문제는 주어진 배열을 조건별로 <strong>정렬</strong>하여 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>문제에서 요구하는 정렬 기준에 따라서 정렬을 해야한다. 
필자는 Java를 이용해 풀기 때문에 <code class="language-plaintext highlighter-rouge">Comparator</code>의 <code class="language-plaintext highlighter-rouge">compare()</code> 메서드를 재정의하여 커스텀 정렬을 구현하였다.</p>

<p>문제 풀이를 위한 아이디어는 다음과 같다.</p>

<ol>
  <li>files 배열을 정렬하는 데, 파일명 별로 HEAD, NUMBER, TAIL를 분리한다.</li>
  <li>HEAD의 경우 대소문자 구분을 하지 않기에 대문자든, 소문자든 통일시킨다.</li>
  <li>HEAD와 NUMBER가 모두 같다면, <strong>HEAD를 기준으로 사전 순 정렬하여 입력 순서를 보장</strong>하도록 한다.</li>
  <li>HEAD만 같다면, <strong>NUMBER를 int형으로 비교하여 오름차순으로 정렬</strong>한다.</li>
</ol>

<p><br /></p>

<p>다음으로 문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
</pre></td><td class="rouge-code"><pre>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>


    <span class="kd">public</span> <span class="nc">String</span><span class="o">[]</span> <span class="nf">solution</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">files</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// 1. HEAD: 사전 순 정렬, 대소문자 구분 X</span>
        <span class="c1">// 2. NUMBER: 숫자 순 정렬, 숫자 앞 0 무시</span>
        <span class="c1">// 3. HEAD와 NUMBER가 같다면 입력 순서 유지</span>

        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">files</span><span class="o">,</span> <span class="o">(</span><span class="n">o1</span><span class="o">,</span> <span class="n">o2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            
            <span class="nc">String</span><span class="o">[]</span> <span class="n">o1_sep</span> <span class="o">=</span> <span class="n">separate</span><span class="o">(</span><span class="n">o1</span><span class="o">);</span>
            <span class="nc">String</span><span class="o">[]</span> <span class="n">o2_sep</span> <span class="o">=</span> <span class="n">separate</span><span class="o">(</span><span class="n">o2</span><span class="o">);</span>

            <span class="cm">/*
             * HEAD를 기준으로 사전 순 정렬을 한다.
             * 두 문자의 head가 같다면 0
             * o1의 head가 크면 양수
             * o2가 크면 음수
             */</span>
            <span class="kt">int</span> <span class="n">compareHead</span> <span class="o">=</span> <span class="n">o1_sep</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">compareTo</span><span class="o">(</span><span class="n">o2_sep</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
            
            <span class="cm">/*
             * HEAD가 같다면 NUMBER를 기준으로 오름차순 정렬한다.
             * NUMBER도 같다면 0을 반환하여 입력 순서를 보장한다.
             * 
             * 두 수의 HEAD가 다르다면, HEAD를 기준으로 정렬한다.
             */</span>
            <span class="k">if</span><span class="o">(</span><span class="n">compareHead</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">o1_num</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">o1_sep</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
                <span class="kt">int</span> <span class="n">o2_num</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">o2_sep</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
                <span class="k">return</span> <span class="n">o1_num</span> <span class="o">-</span> <span class="n">o2_num</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">compareHead</span><span class="o">;</span>
            <span class="o">}</span>
            
        <span class="o">});</span>

        <span class="k">return</span> <span class="n">files</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span><span class="o">[]</span> <span class="nf">separate</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>

        <span class="nc">String</span> <span class="n">head</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">number</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">tail</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>

        <span class="c1">// 하나의 인덱스를 통해 head를 먼저 갱신하고 숫자부터 number를 갱신한다. 이후는 tail에 갱신한다.</span>
        <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        
        <span class="c1">// 숫자가 나올때까지 head 갱신</span>
        <span class="k">for</span><span class="o">(;</span> <span class="n">idx</span><span class="o">&lt;</span><span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">idx</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">idx</span><span class="o">);</span>
            <span class="k">if</span><span class="o">((</span><span class="sc">'0'</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="sc">'9'</span><span class="o">))</span> <span class="k">break</span><span class="o">;</span>
            <span class="n">head</span> <span class="o">+=</span> <span class="n">c</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 숫자부터 number 갱신</span>
        <span class="k">for</span><span class="o">(;</span> <span class="n">idx</span><span class="o">&lt;</span><span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">idx</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">idx</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(!(</span><span class="sc">'0'</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="sc">'9'</span><span class="o">))</span> <span class="k">break</span><span class="o">;</span>
            <span class="n">number</span> <span class="o">+=</span> <span class="n">c</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 나머지 문자열 tail에 갱신</span>
        <span class="k">for</span><span class="o">(;</span> <span class="n">idx</span><span class="o">&lt;</span><span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">idx</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">idx</span><span class="o">);</span>
            <span class="n">tail</span> <span class="o">+=</span> <span class="n">c</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[]{</span><span class="n">head</span><span class="o">.</span><span class="na">toLowerCase</span><span class="o">(),</span> <span class="n">number</span><span class="o">,</span> <span class="n">tail</span><span class="o">};</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        
        <span class="c1">// String[] files = new String[]{"img12.png", </span>
        <span class="c1">//                                 "img10.png", </span>
        <span class="c1">//                                 "img02.png", </span>
        <span class="c1">//                                 "img1.png", </span>
        <span class="c1">//                                 "IMG01.GIF",</span>
        <span class="c1">//                                 "img2.JPG"};</span>

        <span class="nc">String</span><span class="o">[]</span> <span class="n">files</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[]{</span><span class="s">"F-5 Freedom Fighter"</span><span class="o">,</span> 
                                        <span class="s">"B-50 Superfortress"</span><span class="o">,</span> 
                                        <span class="s">"A-10 Thunderbolt II"</span><span class="o">,</span> 
                                        <span class="s">"F-14 Tomcat"</span><span class="o">};</span>

        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">files</span><span class="o">);</span>

    <span class="o">}</span>

<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<p>-
—</p>

<p><br /></p>

<h3 id="출처">출처</h3>
<p>-
—</p>

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://school.programmers.co.kr/learn/courses/30/lessons/17686">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 2 - 파일명 정렬]]></summary></entry><entry><title type="html">[Java] 백준(골드-4) 7662번 - 이중 우선순위 큐</title><link href="http://localhost:4000/java/246-post/" rel="alternate" type="text/html" title="[Java] 백준(골드-4) 7662번 - 이중 우선순위 큐" /><published>2023-08-08T00:00:00+09:00</published><updated>2023-08-08T00:00:00+09:00</updated><id>http://localhost:4000/java/246-post</id><content type="html" xml:base="http://localhost:4000/java/246-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 문제명인 <strong>이중 우선순위 큐를 이용하면 시간 초과가 발생</strong>하기에 <strong>TreeMap 자료구조</strong>를 이용해 풀어야 한다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>별 다른 생각없이 최소 힙, 최대 힙을 구현한 2개의 우선순위 큐를 이용하여 풀었지만, <strong>큐의 삭제 연산 remove() 메서드를 수행할 때 시간복잡도가 O(n)이기에 시간초과가 발생</strong>했다.</p>

<h4 id="최소-힙-최대-힙-우선순위-큐-2개를-이용한-풀이---시간초과-발생">최소 힙, 최대 힙 우선순위 큐 2개를 이용한 풀이 - 시간초과 발생</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="c1">// 1. 이중 우선순위 큐를 구현하기 위해 최소 힙, 최대 힙인 우선순위 큐 2개를 활용한다.</span>
        <span class="c1">// 2. I 명령이면 N을 삽입하고, D 1 명령이면 큐의 최댓값 제거, D -1 명령이면 큐의 최솟값을 제거한다.</span>
        <span class="c1">// 3. D 명령 수행시 큐가 비었다면 무시하고 진행한다.</span>
        <span class="c1">// 4. 큐에 저장되는 정수의 범위는 -2^31 부터 2^31까지 이기에 long형 타입을 사용해야 한다.</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
            
                <span class="kt">int</span> <span class="no">T</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

                <span class="k">while</span><span class="o">(</span><span class="no">T</span> <span class="o">--&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    
                    <span class="c1">// 최솟값을 기준으로 정렬할 최소 힙 우선순위 큐 선언</span>
                    <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">min_q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;();</span>
                    
                    <span class="c1">// 최댓값을 기준으로 정렬할 최대 힙 우선순위 큐 선언</span>
                    <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">max_q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;(</span><span class="k">new</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;()</span> <span class="o">{</span>
                        <span class="nd">@Override</span>
                        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="nc">Long</span> <span class="n">o1</span><span class="o">,</span> <span class="nc">Long</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
                            <span class="k">if</span><span class="o">(</span><span class="n">o1</span> <span class="o">&gt;</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
                                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                            <span class="o">}</span>
                            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">o1</span> <span class="o">&lt;</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
                                <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
                            <span class="o">}</span>
                            <span class="k">else</span> <span class="o">{</span>
                                <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
                            <span class="o">}</span>
                        <span class="o">}</span>
                    <span class="o">});</span>

                    <span class="kt">int</span> <span class="no">K</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                    
                    <span class="k">while</span><span class="o">(</span><span class="no">K</span> <span class="o">--&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        
                        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                        <span class="nc">String</span> <span class="n">cmd</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">();</span>
                        <span class="kt">long</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">parseLong</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

                        <span class="c1">// cmd == I</span>
                        <span class="k">if</span><span class="o">(</span><span class="n">cmd</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"I"</span><span class="o">))</span> <span class="o">{</span>
                            <span class="n">min_q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="no">N</span><span class="o">);</span>
                            <span class="n">max_q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="no">N</span><span class="o">);</span>
                        <span class="o">}</span> 
                        <span class="c1">// cmd == D</span>
                        <span class="k">else</span> <span class="o">{</span>
                            <span class="c1">// 최댓값 제거일 경우 최대 힙(max_q)에서만 제거</span>
                            <span class="k">if</span><span class="o">(</span><span class="no">N</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                                <span class="k">if</span><span class="o">(</span><span class="n">max_q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="k">continue</span><span class="o">;</span>
                                <span class="kt">long</span> <span class="n">target</span> <span class="o">=</span> <span class="n">max_q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                                <span class="n">min_q</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">target</span><span class="o">);</span>
                            <span class="o">}</span> 
                            <span class="c1">// 최솟값 제거일 경우 최소 힙(min_q)에서만 제거</span>
                            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="no">N</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                                <span class="k">if</span><span class="o">(</span><span class="n">min_q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="k">continue</span><span class="o">;</span>
                                <span class="kt">long</span> <span class="n">target</span> <span class="o">=</span> <span class="n">min_q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                                <span class="n">max_q</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">target</span><span class="o">);</span>
                            <span class="o">}</span>
                        <span class="o">}</span>

                    <span class="o">}</span>

                    <span class="cm">/**
                     * 큐가 비어있다면 "EMPTY"를 출력하고
                     * 비어있지 않다면, 최댓값과 최솟값을 공백을 두고 출력한다.
                     */</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">min_q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">max_q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"EMPTY"</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">max_q</span><span class="o">.</span><span class="na">peek</span><span class="o">()+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">min_q</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">+</span> <span class="s">"\n"</span><span class="o">);</span>
                    <span class="o">}</span>

                <span class="o">}</span>

        <span class="o">}</span>

    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><br /></p>

<p>이를 위해, 시간 초과가 발생하는 큐를 사용하는 것이 아니라 원소 추가 및 삭제에 <strong>O(logN)의 시간복잡도를 가지는 TreeMap</strong>를 이용하여 풀게 되었다. TreeMap을 활용해 풀 수 있는 아이디어를 다음과 같이 생각해보았다.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">I N</code> 명령일 경우, N을 TreeMap에 Key로, N의 빈도수(개수)를 Value로 삽입한다.</li>
  <li>D 명령일 경우 TreeMap이 비어있다면 D 연산을 무시하고 넘어간다.</li>
  <li><code class="language-plaintext highlighter-rouge">D 1</code> 명령일 경우, TreeMap의 마지막 값(<code class="language-plaintext highlighter-rouge">lastKey()</code>)을 제거한다.</li>
  <li><code class="language-plaintext highlighter-rouge">D -1</code> 명령일 경우, TreeMap의 첫번째 값(<code class="language-plaintext highlighter-rouge">firstKey()</code>)을 제거한다.</li>
</ol>

<blockquote>
  <p><strong>TreeMap 자료구조는 오름차순 정렬</strong>이 기본으로 설정되어있다. 또한, <strong>firstKey()</strong> 메서드와 <strong>lastKey()</strong> 메서드가 존재한다. firstKey() 메서드는 Map의 첫번째 키를, lastKey() 메서드는 Map의 마지막 키를 가져올 수 있다.</p>
</blockquote>

<p>결국, TreeMap의 두 메서드를 통해 이중 우선순위 큐에서 서로의 큐의 삭제연산을 할 때의 비용을 절감하여 시간 초과를 해결할 수 있었다.</p>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="c1">// 1. 이중 우선순위 큐를 구현하기 위해 최소 힙, 최대 힙인 우선순위 큐 2개를 활용한다.</span>
        <span class="c1">// 2. I 명령이면 N을 삽입하고, D 1 명령이면 큐의 최댓값 제거, D -1 명령이면 큐의 최솟값을 제거한다.</span>
        <span class="c1">// 3. D 명령 수행시 큐가 비었다면 무시하고 진행한다.</span>
        <span class="c1">// 4. 큐에 저장되는 정수의 범위는 -2^31 부터 2^31까지 이기에 long형 타입을 사용해야 한다.</span>
        <span class="c1">// 5. D 명령 수행시 큐 remove() 연산을 수행하게 되면 시간초과가 발생한다.</span>
        <span class="c1">// 6. 원소의 추가, 삭제 이후에 정렬 상태를 유지하는데 O(logN)의 시간복잡도를 가지는 TreeMap 자료구조를 이용해 풀어야 한다.</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
            
                <span class="kt">int</span> <span class="no">T</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

                <span class="k">while</span><span class="o">(</span><span class="no">T</span> <span class="o">--&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>

                    <span class="c1">// 최소힙과 최대힙의 원소와 개수를 담을 TreeMap 선언</span>
                    <span class="nc">TreeMap</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">tm</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeMap</span><span class="o">&lt;&gt;();</span>

                    <span class="kt">int</span> <span class="no">K</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                    
                    <span class="k">while</span><span class="o">(</span><span class="no">K</span> <span class="o">--&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        
                        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                        <span class="nc">String</span> <span class="n">cmd</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">();</span>
                        <span class="kt">long</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">parseLong</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

                        <span class="c1">// cmd == I</span>
                        <span class="k">if</span><span class="o">(</span><span class="n">cmd</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"I"</span><span class="o">))</span> <span class="o">{</span>
                            <span class="n">tm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="no">N</span><span class="o">,</span> <span class="n">tm</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="no">N</span><span class="o">,</span> <span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
                        <span class="o">}</span> 
                        <span class="c1">// cmd == D</span>
                        <span class="k">else</span> <span class="o">{</span>
                            
                            <span class="c1">// TreeMap이 비어있다면 D 연산은 무시한다.</span>
                            <span class="k">if</span><span class="o">(</span><span class="n">tm</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="k">continue</span><span class="o">;</span>
                            
                            <span class="c1">// 최댓값 제거</span>
                            <span class="k">if</span><span class="o">(</span><span class="no">N</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>

                                <span class="c1">// 최댓값 key</span>
                                <span class="kt">long</span> <span class="n">last</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="na">lastKey</span><span class="o">();</span>
                                
                                <span class="c1">// 1개밖에 없다면 Map에서 제거</span>
                                <span class="k">if</span><span class="o">(</span><span class="n">tm</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">last</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                                    <span class="n">tm</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">last</span><span class="o">);</span>
                                    <span class="k">continue</span><span class="o">;</span>
                                <span class="o">}</span>
                                
                                <span class="c1">// 2개 이상이라면 개수 1개 차감</span>
                                <span class="n">tm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">last</span><span class="o">,</span> <span class="n">tm</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">last</span><span class="o">)-</span><span class="mi">1</span><span class="o">);</span>

                            <span class="o">}</span> 
                            <span class="c1">// 최솟값 제거</span>
                            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="no">N</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                                
                                <span class="c1">// 최솟값 key</span>
                                <span class="kt">long</span> <span class="n">first</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="na">firstKey</span><span class="o">();</span>
                                
                                <span class="c1">// 1개밖에 없다면 Map에서 제거</span>
                                <span class="k">if</span><span class="o">(</span><span class="n">tm</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">first</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                                    <span class="n">tm</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">first</span><span class="o">);</span>
                                    <span class="k">continue</span><span class="o">;</span>
                                <span class="o">}</span>

                                <span class="c1">// 2개 이상이라면 개수 1개 차감</span>
                                <span class="n">tm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">first</span><span class="o">,</span> <span class="n">tm</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">first</span><span class="o">)-</span><span class="mi">1</span><span class="o">);</span>


                            <span class="o">}</span>
                        <span class="o">}</span>

                    <span class="o">}</span>

                    <span class="cm">/**
                     * 큐가 비어있다면 "EMPTY"를 출력하고
                     * 비어있지 않다면, 최댓값과 최솟값을 공백을 두고 출력한다.
                     */</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">tm</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"EMPTY"</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">tm</span><span class="o">.</span><span class="na">lastKey</span><span class="o">()+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">tm</span><span class="o">.</span><span class="na">firstKey</span><span class="o">()</span> <span class="o">+</span> <span class="s">"\n"</span><span class="o">);</span>
                    <span class="o">}</span>

                <span class="o">}</span>
                
        <span class="o">}</span>

    <span class="o">}</span>


<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/7662">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[7662번 - 이중 우선순위 큐]]></summary></entry><entry><title type="html">[Java] 백준(실버-2) 21736번 - 헌내기는 친구가 필요해</title><link href="http://localhost:4000/java/244-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-2) 21736번 - 헌내기는 친구가 필요해" /><published>2023-08-07T00:00:00+09:00</published><updated>2023-08-07T00:00:00+09:00</updated><id>http://localhost:4000/java/244-post</id><content type="html" xml:base="http://localhost:4000/java/244-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 <strong>너비 우선 탐색 BFS</strong>를 이용해 간단하게 풀 수 있다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>너비 우선 탐색인 BFS를 잘 숙지하고 있다면 쉽게 도연이가 사람들과 만난 횟수를 구할 수 있을 것이다.</p>

<p>문제풀이를 위한 아이디어는 다음과 같다.</p>

<ol>
  <li>지도를 입력받고 BFS 탐색을 수행한다.</li>
  <li>BFS로 탐색하면서 벽(X)이 아닌 빈공간(0)과 사람(P)일 경우만 상,하,좌,우 탐색을 이어나간다.</li>
  <li>사람(P)을 만날 경우 만난 횟수를 1 증가시킨다.</li>
  <li>BFS 탐색 종료후, 만난 룃수가 1 이상이라면 만난 횟수를, 사람을 만나지 못했다면 “TT”를 출력한다.</li>
</ol>

<p>유의할 점은 다음과 같다.</p>
<blockquote>
  <p>지도의 (0,0) 위치부터 탐색을 하는 것이 아니라, <strong>도연이의 위치부터 탐색을 시작</strong>해야 벽을 고려하여 사람들과의 만난 횟수를 구할 수 있다.</p>
</blockquote>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dx</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>

    <span class="kd">static</span> <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">visited</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">char</span><span class="o">[][]</span> <span class="n">map</span><span class="o">;</span>

    <span class="kd">static</span> <span class="kt">int</span> <span class="no">N</span><span class="o">,</span> <span class="no">M</span><span class="o">;</span>

    <span class="kd">static</span> <span class="kt">int</span> <span class="n">result</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
            
            <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

            <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
            <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

            <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">M</span><span class="o">];</span>
            <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">M</span><span class="o">];</span>

            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="nc">String</span> <span class="n">input</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="no">M</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
                    <span class="c1">// 도연이의 위치를 x와 y에 담는다.</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'I'</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                        <span class="n">y</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>  
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
            
            <span class="c1">// 만난 횟수를 담을 변수 초기화</span>
            <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

            <span class="c1">// 도연이의 위치부터 BFS를 수행한다.</span>
            <span class="no">BFS</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
            
            <span class="c1">// 만난 횟수가 1번 이상이라면 횟수를, 아니라면 "TT"를 출력한다.</span>
            <span class="k">if</span><span class="o">(</span><span class="n">result</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"TT"</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
            <span class="o">}</span>
            
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="cm">/**
     * BFS 탐색 함수
     * 벽(X)아닌 위치로 상,하,좌,우 탐색을 한다.
     * 탐색 중, 사람(P)의 위치일 경우 result를 1 증가시킨다.
     */</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">BFS</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">});</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">now</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">dir</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">dir</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">;</span> <span class="n">dir</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">now</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">dx</span><span class="o">[</span><span class="n">dir</span><span class="o">];</span>
                <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">now</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">dy</span><span class="o">[</span><span class="n">dir</span><span class="o">];</span>
                <span class="k">if</span><span class="o">(</span><span class="n">isRange</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="sc">'X'</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'P'</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">result</span><span class="o">++;</span>
                        <span class="o">}</span>
                        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">});</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isRange</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">&lt;</span><span class="no">N</span> <span class="o">&amp;&amp;</span> <span class="n">y</span><span class="o">&lt;</span><span class="no">M</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/21736">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[21736번 - 헌내기는 친구가 필요해]]></summary></entry><entry><title type="html">[Java] 백준(실버-3) 17626번 - Four Squares</title><link href="http://localhost:4000/java/243-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-3) 17626번 - Four Squares" /><published>2023-08-07T00:00:00+09:00</published><updated>2023-08-07T00:00:00+09:00</updated><id>http://localhost:4000/java/243-post</id><content type="html" xml:base="http://localhost:4000/java/243-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 얼핏 보면 그리디 알고리즘과 헷갈리지만, <strong>동적계획법 DP</strong>를 이용해 풀어야 한다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>처음엔 무작정 제곱수가 큰 것부터 접근해나가려 했지만 N=12일 경우 <code class="language-plaintext highlighter-rouge">2^2 + 2^2 + 2^2</code>의 경우도 고려해야 하기 때문에 그리디 알고리즘이 아닌 DP로 풀어야 함을 알게 되었다.</p>

<p>DP를 이용해 부분 문제를 구해주면, 결국 최적해를 구할 수 있게 된다.</p>

<p>어떻게 최적해인 N을 만들기 위한 최소 제곱수의 개수를 구할 수 있을까? 1부터 9까지 최소 제곱수의 개수를 한번 나열하고 살펴보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="mi">1</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="n">개</span>
<span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="n">개</span>
<span class="mi">3</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="n">개</span>
<span class="mi">4</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">^</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="n">개</span>
<span class="mi">5</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="n">개</span>
<span class="mi">6</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="n">개</span>
<span class="mi">7</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">4</span><span class="n">개</span>
<span class="mi">8</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">^</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="n">개</span>
<span class="mi">9</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="o">^</span><span class="mi">3</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="n">개</span>
<span class="o">...</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>위처럼 1부터 9까지 살펴보면, N을 만들 수 있는 최소 제곱수의 개수의 패턴을 도출할 수 있다. <strong>N보다 작은 제곱수들 중에서 가장 작은 값을 가지는 D[N-제곱수] 값에 1을 더해</strong>주면 된다.</p>

<p>즉 이를 통해 도출한 점화식은 다음과 같다.</p>

<blockquote>
  <p>점화식: <code class="language-plaintext highlighter-rouge">D[i] = min(D[i-j*j])+1</code></p>
</blockquote>

<p>그러면 문제풀이를 위한 아이디어를 그려보자.</p>

<ol>
  <li>DP 테이블에 D[0]을 0으로, D[1]을 1인 초기값으로 설정한다.</li>
  <li>D[2]부터 D[N]까지 DP 테이블의 값을 채우기 위해 2부터 N까지 순회하며, 각 <strong>순회(이중for문)마다 최소가 되는 <code class="language-plaintext highlighter-rouge">D[i-j*j]</code>의 값을 D[i]번째에 채운다.</strong></li>
  <li>완전 탐색 종료 후 D[N]번째 값을 출력한다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// DP 테이블 선언</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="no">D</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>

            <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

            <span class="c1">// DP 테이블 초기화</span>
            <span class="no">D</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>

            <span class="c1">// 초기값 설정</span>
            <span class="no">D</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="no">D</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

            <span class="c1">// DP 함수 실행</span>
            <span class="no">DP</span><span class="o">(</span><span class="no">N</span><span class="o">);</span>
            
            <span class="c1">// DP 테이블의 N번째 값 출력</span>
            <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">]+</span><span class="s">"\n"</span><span class="o">);</span>
            
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="cm">/**
     * DP 함수
     * 점화식: D[i] = min(D[i-j*j])+1
     */</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">DP</span><span class="o">(</span><span class="kt">int</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="c1">// 2부터 N까지 완전탐색으로 순회한다.</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            
            <span class="c1">// 최솟값을 비교하기 위한 변수</span>
            <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
            
            <span class="c1">// 1. i보다 작은 제곱수를 뺄셈한 DP 테이블의 값 중 최솟값을 구한다.</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">*</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">min</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">min</span><span class="o">,</span> <span class="no">D</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span> <span class="o">*</span> <span class="n">j</span><span class="o">]);</span>  
            <span class="o">}</span>
            
            <span class="c1">// 2. D[i]에 1을 더해준다.</span>
            <span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">min</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

        <span class="o">}</span>

    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/17626">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[17626번 - Four Squares]]></summary></entry><entry><title type="html">[Java] 백준(골드-5) 16928번 - 뱀과 사다리 게임</title><link href="http://localhost:4000/java/245-post/" rel="alternate" type="text/html" title="[Java] 백준(골드-5) 16928번 - 뱀과 사다리 게임" /><published>2023-08-07T00:00:00+09:00</published><updated>2023-08-07T00:00:00+09:00</updated><id>http://localhost:4000/java/245-post</id><content type="html" xml:base="http://localhost:4000/java/245-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 <strong>너비 우선 탐색 BFS</strong>를 이용해 간단하게 풀 수 있다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>10x10 크기의 게임 보드판에서 주사위를 던져 나오는 눈의 숫자만큼 이동하면서 사다리가 나오면 넘어가고, 뱀이 나오면 돌아오면서 100번째 칸에 도달했을 때 던진 주사위 횟수를 구해야 한다.</p>

<blockquote>
  <p>필자는 게임 보드판을 만들 때 상,하,좌,우 탐색 이동이 없어서, 2차원 배열보다 1차원 배열을 활용하는게 쉽다고 느껴서 1치원 배열을 이용했다.</p>
</blockquote>

<p>예제 1번을 토대로 아레 보드판을 만드는 과정을 알아보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="mi">1</span>  <span class="mi">2</span>  <span class="mi">3</span>  <span class="mi">4</span>  <span class="mi">5</span>  <span class="mi">6</span>  <span class="mi">7</span>  <span class="mi">8</span>  <span class="mi">9</span>  <span class="mi">10</span>
<span class="mi">11</span> <span class="mi">12</span><span class="o">(</span><span class="mi">98</span><span class="o">)</span> <span class="mi">13</span> <span class="mi">14</span> <span class="mi">15</span> <span class="mi">16</span> <span class="mi">17</span> <span class="mi">18</span> <span class="mi">19</span> <span class="mi">20</span>
<span class="o">...</span>
<span class="mi">91</span> <span class="mi">92</span><span class="o">(</span><span class="mi">37</span><span class="o">)</span> <span class="mi">93</span> <span class="mi">94</span><span class="o">(</span><span class="mi">13</span><span class="o">)</span> <span class="mi">95</span> <span class="mi">96</span> <span class="mi">97</span><span class="o">(</span><span class="mi">25</span><span class="o">)</span> <span class="mi">98</span> <span class="mi">99</span> <span class="mi">100</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>인덱스가 12인 위치에 98을 삽입하는 방식으로 배열의 값을 입력받는다면, 12 위치에 도달했을 때 98 위치로 이동하도록 하면 된다.</p>

<p>다음으로는 주사위를 굴려 나온 횟수를 어떻게 저장할까?</p>

<p>BFS 탐색을 통해 주사위를 굴리면서 보드판을 탐색해야 하니, 1부터 6까지 큐에 삽입하고 방문 여부 체크를 한다.</p>

<blockquote>
  <p>만약, 1이 나왔다면 다음엔 2부터 7까지 이동할 수 있다. 이때, 2부터 6까지는 1번만 던져 갈 수 있도록 처리했으니(방문 여부 체크) 7에는 한 번 더 던져야 하는 횟수인 2를 기록하면 된다. 그렇게 주사위를 던져나가면서 주사위 던진 횟수를 방문 배열에 기록하는데 사다리 위치가 나올 경우 12 위치에서 98 위치로 탐색을 건너뛰기 때문에 98 위치부터는 주사위 던진 횟수를 2부터 기록하게 된다. 결국, 99, 100까지는 주사위 3번만 던지면 이동할 수 있기 때문에 3을 출력하면 된다.</p>
</blockquote>

<p>설명이 좀 길었지만 문제 풀이를 위한 아이디어는 다음과 같다.</p>

<ol>
  <li>보드판을 1차원 배열을 활용해 1부터 100까지 채우기</li>
  <li>보드에 사다리 값을 갱신한다. - 사다리[0]에는 사다리[1] 값을 삽입</li>
  <li>보드에 뱀 값을 갱신한다. - 뱀[0]에는 뱀[1] 값을 갱신한다.</li>
  <li>1부터 BFS 탐색을 시작한다.</li>
  <li>주사위를 굴려 100번째 칸을 벗어날 경우 탐색을 스킵하고, <strong>방문하지 않은 칸이라면 주사위 굴린 횟수를 1 증가</strong>시켜 갱신해나간다.</li>
  <li>BFS 탐색 종료 후, 100번째 칸에 기록한 주사위 굴린 횟수를 출력한다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dx</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>

    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">board</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">visited</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
            
                <span class="c1">// 1. 보드판을 1차원 배열을 활용해 1부터 100까지 채우기</span>
                <span class="c1">// 2. 보드에 사다리 값을 갱신한다. - 사다리[0]에는 사다리[1] 값을 삽입</span>
                <span class="c1">// 3. 보드에 뱀 값을 갱신한다. - 뱀[0]에는 뱀[1] 값을 갱신한다.</span>
                <span class="c1">// 4. 1부터 BFS 탐색을 시작한다.</span>
                <span class="c1">// 5. BFS 탐색을 통해 100번째 칸에 도달할 때까지 주사위를 굴린다.</span>
                <span class="c1">// 6. 100번째 칸을 방문하면 주사위 굴린 횟수를 출력한다.</span>

                <span class="c1">// 보드판의 크기 1~100만큼 초기화</span>
                <span class="n">board</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">101</span><span class="o">];</span>
                <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">101</span><span class="o">];</span>

                <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

                <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                <span class="kt">int</span> <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

                <span class="c1">// 1차원 배열인 게임 보드판을 1부터 100까지 채운다.</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="c1">// 사다리와 뱀의 위치를 보드판의 기록한다.</span>
                <span class="k">while</span><span class="o">(</span><span class="no">N</span> <span class="o">--&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                    <span class="kt">int</span> <span class="n">ladder1</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="kt">int</span> <span class="n">ladder2</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="n">board</span><span class="o">[</span><span class="n">ladder1</span><span class="o">]</span> <span class="o">=</span> <span class="n">ladder2</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">while</span><span class="o">(</span><span class="no">M</span> <span class="o">--&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                    <span class="kt">int</span> <span class="n">snake1</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="kt">int</span> <span class="n">snake2</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="n">board</span><span class="o">[</span><span class="n">snake1</span><span class="o">]</span> <span class="o">=</span> <span class="n">snake2</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="c1">// 1부처 BFS 함수를 통해 탐색을 진행한다.</span>
                <span class="no">BFS</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>

                <span class="c1">// BFS 탐색 종료 후, 100번째 칸 방문시 주사위를 굴린 횟수를 출력한다.</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="mi">100</span><span class="o">]+</span><span class="s">"\n"</span><span class="o">);</span>

        <span class="o">}</span>

    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">BFS</span><span class="o">(</span><span class="kt">int</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">node</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">while</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">now</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>

            <span class="c1">// 100번째 칸에 도달하면 순회 종료</span>
            <span class="k">if</span><span class="o">(</span><span class="n">now</span> <span class="o">==</span> <span class="mi">100</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// 큐가 빌때까지 주사위를 굴려 나오는 경우를 탐색하기 (1~6)</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="mi">6</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                
                <span class="c1">// 주사위 굴려서 이동할 수 있는 칸</span>
                <span class="kt">int</span> <span class="n">next</span> <span class="o">=</span> <span class="n">now</span> <span class="o">+</span> <span class="n">i</span><span class="o">;</span>

                <span class="cm">/**
                 * 주사위를 굴려서 보드판의 범위를 벗어나면 안된다.
                 * 이때, 던진 주사위 이동을 무시한다.
                 */</span>
                <span class="k">if</span><span class="o">(</span><span class="n">next</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="cm">/*
                 * 주사위를 굴려 이동한 보드판 위치가 방문하지 않았다면,
                 * 해당 위치를 큐에 삽입하여 BFS의 탐색 대상이 될 수있도록 한다.
                 * 또한, 방문 배열에 주사위 굴린 횟수를 갱신한다.
                 */</span>
                <span class="k">if</span><span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">board</span><span class="o">[</span><span class="n">next</span><span class="o">]]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">next</span><span class="o">]);</span>
                    <span class="n">visited</span><span class="o">[</span><span class="n">board</span><span class="o">[</span><span class="n">next</span><span class="o">]]</span> <span class="o">=</span> <span class="n">visited</span><span class="o">[</span><span class="n">now</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/16928">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[16928번 - 뱀과 사다리 게임]]></summary></entry><entry><title type="html">[Java] 백준(실버-4) 17219번 - 비밀번호 찾기</title><link href="http://localhost:4000/java/242-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-4) 17219번 - 비밀번호 찾기" /><published>2023-08-04T00:00:00+09:00</published><updated>2023-08-04T00:00:00+09:00</updated><id>http://localhost:4000/java/242-post</id><content type="html" xml:base="http://localhost:4000/java/242-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 자료구조 중 하나인 <strong>HashMap</strong>을 이용해 간단히 풀 수 있다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<blockquote>
  <p>문제에서 요구한 대로 입출력 속도 향상을 위해 Scanner가 아닌 BufferedReader와 BufferedWriter를 사용하여 입출력 처리를 하였다.</p>
</blockquote>

<p>문제 자체는 굉장히 쉽다.</p>

<ol>
  <li>N만큼의 입력을 받으며 HashMap에 사이트와 비밀번호를 담는다.</li>
  <li>M만큼의 찾고자 하는 사이트 입력을 받으며 해당 사이트가 HashMap에 있는지 찾아 사이트의 값인 비밀번호를 출력한다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>

            <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        
            <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
            <span class="kt">int</span> <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

            <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">hm</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

            <span class="c1">// HashMap에 사이트와 비밀번호를 담는다.</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
                <span class="n">hm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">)[</span><span class="mi">0</span><span class="o">],</span> <span class="n">str</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">)[</span><span class="mi">1</span><span class="o">]);</span>
            <span class="o">}</span>
            
            <span class="c1">// 해당 사이트의 문자열 값을 key로 HashMap의 value인 비밀번호를 조회한다.</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">M</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="nc">String</span> <span class="n">find</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">hm</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">find</span><span class="o">)+</span><span class="s">"\n"</span><span class="o">);</span>
            <span class="o">}</span>

        <span class="o">}</span>

    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/17219">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[17219번 - 비밀번호 찾기]]></summary></entry><entry><title type="html">[Java] 백준(실버-3) 9375번 - 패션왕 신해빈</title><link href="http://localhost:4000/java/241-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-3) 9375번 - 패션왕 신해빈" /><published>2023-08-04T00:00:00+09:00</published><updated>2023-08-04T00:00:00+09:00</updated><id>http://localhost:4000/java/241-post</id><content type="html" xml:base="http://localhost:4000/java/241-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 <strong>조합</strong>과 관련된 문제로 <strong>HashMap</strong>을 이용해 간단히 풀 수 있다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>문제의 예시만 잘 살펴봐도 어떻게 풀어야 할지 쉽게 파악할 수 있다. 예시를 보자.</p>

<p>문제의 요구사항을 보면 위에서 두어진 2 종류와 3개의 옷가지를 통해 <strong>알몸이 되지 않는 경우의 수</strong>를 구해야 한다고 한다.</p>

<p>경우의 수를 바로 구해보자. 이때, 같은 종류의 옷은 입지 못하는 것을 유의하자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="n">한</span> <span class="n">개만</span> <span class="n">입을</span> <span class="n">경우</span> <span class="o">:</span> <span class="o">{</span><span class="n">hat</span><span class="o">},</span> <span class="o">{</span><span class="n">turban</span><span class="o">},</span> <span class="o">{</span><span class="n">sunglasses</span><span class="o">}</span>
<span class="n">두</span> <span class="n">개씩</span> <span class="n">조합하여</span> <span class="n">입을</span> <span class="n">경우</span> <span class="o">:</span> <span class="o">{</span><span class="n">hat</span><span class="o">,</span> <span class="n">sunglasses</span><span class="o">},</span> <span class="o">{</span><span class="n">turban</span><span class="o">,</span> <span class="n">sunglasses</span><span class="o">}</span>

<span class="n">총</span> <span class="mi">5</span><span class="n">가지</span> <span class="n">경우의</span> <span class="n">수</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>이렇게 5가지 경우의 수를 구하면 되는데, 조합 공식을 통해 구하는 방법을 알아보자.</p>

<blockquote>
  <p><strong>[headgear]</strong> <br />
hat <br />
turban</p>
</blockquote>

<blockquote>
  <p><strong>[eyewear]</strong> <br />
sunglasses</p>
</blockquote>

<p>위와 같이 두 종류의 옷마다 1개를 선택하는 경우의 수를 구해야 한다. 그런데 위의 종류의 옷은 저것으로 끝이 아니다! 바로 <strong>아무 것도 입지 않는 경우도 포함</strong>시켜야 한다.</p>

<blockquote>
  <p><strong>[headgear]</strong> <br />
hat <br />
turban <br />
null</p>
</blockquote>

<blockquote>
  <p><strong>[eyewear]</strong> <br />
sunglasses <br />
null</p>
</blockquote>

<p>위와 같이 알몸의 아무 것도 입지 않은 경우를 두 종류에 포함시켜서 조합 공식을 적용해야 한다. 그렇게 <strong>headgear에서는 3C1</strong>을, <strong>eyewear에서는 2C1</strong>을 구한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="mi">3</span><span class="no">C1</span> <span class="o">=</span> <span class="mi">3</span>
<span class="mi">2</span><span class="no">C1</span> <span class="o">=</span> <span class="mi">2</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>이 둘을 곱하면 6으로 모든 종류의 옷을 통해 구한 경우의 수가 된다. 그리고 한 가지 더 유의할 점은 옷의 종류마다 안 입는 경우도 포함시켰기 때문에 모든 경우의 수에는 알몸인 상태가 포함되어 있다. 그래서 <code class="language-plaintext highlighter-rouge">(3C1 * 2C1) - 1</code>과 같이 <strong>1가지 경우의 수를 차감시켜 알몸인 경우를 제외</strong>해야 한다.</p>

<p>이를 통해 문제를 풀기 위해 정리한 아이디어는 다음과 같다.</p>

<ol>
  <li>T(테스트케이스)마다 HashMap에 옷의 종류와 옷의 종류의 갯수를 담는다. (이때, 옷 이름은 필요없다.)</li>
  <li>같은 옷의 종류가 나온다면 갯수를 1 증가시키고, 같은 종류의 옷이 아니라면 1을 삽입하여 카운트할 수 있도록 한다.</li>
  <li>HashMap을 순회하며, 옷의 종류마다 알몸의 경우를 고려해(+1) 곱해나가면, 알몸이 아닌 옷의 종류별 모든 경우의 수를 구할 수 있다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
        
        <span class="kt">int</span> <span class="no">T</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="k">while</span><span class="o">(</span><span class="no">T</span> <span class="o">--&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            
            <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">hm</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
            <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

            <span class="k">while</span><span class="o">(</span><span class="no">N</span> <span class="o">--&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
                <span class="nc">String</span> <span class="n">cloth_type</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">)[</span><span class="mi">1</span><span class="o">];</span>

                <span class="cm">/**
                 * 같은 종류의 옷이 hashMap에 존재한다면, 해당 종류의 값을 1씩 증가시킨다.
                 * 같은 종류의 옷이 없다면 값에 1을 삽입한다.
                 */</span>
                <span class="k">if</span><span class="o">(</span><span class="n">hm</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">cloth_type</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">hm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">cloth_type</span><span class="o">,</span> <span class="n">hm</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">cloth_type</span><span class="o">,</span> <span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                    <span class="n">hm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">cloth_type</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span>

            <span class="o">}</span>
            
            <span class="c1">// 조합을 구할 변수</span>
            <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

            <span class="c1">// 안 입는 경ㅜ를 고해 종류별로 경우의 수ㄹ 1씩 더해야 한다.</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span> <span class="o">:</span> <span class="n">hm</span><span class="o">.</span><span class="na">values</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">result</span> <span class="o">*=</span> <span class="o">(</span><span class="n">value</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
            
            <span class="c1">// 모두 안입은 경우의 수 1가지를 감소시킨다.</span>
            <span class="n">result</span> <span class="o">-=</span> <span class="mi">1</span><span class="o">;</span>

            <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>

        <span class="o">}</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/9375">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[9375번 - 패션왕 신해빈]]></summary></entry><entry><title type="html">[Java] 프로그래머스(level-2) - 뒤에 있는 큰 수 찾기</title><link href="http://localhost:4000/java/240-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-2) - 뒤에 있는 큰 수 찾기" /><published>2023-08-03T00:00:00+09:00</published><updated>2023-08-03T00:00:00+09:00</updated><id>http://localhost:4000/java/240-post</id><content type="html" xml:base="http://localhost:4000/java/240-post/"><![CDATA[<p><br /></p>

<center><img src="/assets/images/programmers/" width="100%" /></center>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />

<p>이번 문제는 <strong>Stack(스택)</strong>을 활용해 시간복잡도를 줄여 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<blockquote>
  <p>스택을 사용하지 않고 이중 for문으로 뒷 큰수를 찾을 경우 numbers의 범위가 1,000,000이기에 시간초과가 발생한다. 시간복잡도를 O(n)으로 줄이기 위해 스택을 활용해야 한다.</p>
</blockquote>

<p>필자의 경우 스택에 [인덱스, 값] 형태를 삽입하여 현재 값과 스택의 정상값을 비교하며 뒷 큰수를 찾도록 구현하였다. 이를 위한 아이디어는 다음과 같다.</p>

<ol>
  <li>numbers 길이를 가지는 answer 배열을 선언한다.</li>
  <li>스택에 [인덱스, 값] 형태로 삽입한 후, numbers를 순회하며 현재 값이 이전 원소인 스택의 정상값보다 큰지 확인한다.</li>
  <li>현재 값이 스택의 정상값보다 큰지 확인하기 위해 스택이 빌 때까지 반복한다.</li>
  <li>이때, 뒷 큰수가 된다면 해당 값을 answer 배열에 이전 원소(스택 정상값)의 인덱스 위치에 갱신한다.</li>
  <li>현재 인덱스와 값으 스택에 삽입한다.</li>
  <li>2-5번 과정을 반복하며 numbers 순회가 끝나고 스택에 값이 남아있다면 뒷 큰수가 되지 못하는 수가 있는 것이기 때문에, 스택이 빌때까지 값을 추출하며 answer 배열에 -1로 갱신한다.</li>
</ol>

<p><br /></p>

<p>다음으로 문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre></td><td class="rouge-code"><pre>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">numbers</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// 1. numbers를 순회하면서 현재 원소와 뒤의 원소들과 비교하며 더 큰수가 있는지 확인한다.</span>
        <span class="c1">// 2. 현재 원소보다 뒤에 큰 수가 있다면, 해당 수를 결과 배열의 같은 위치에 담는다.</span>
        <span class="c1">// 3. numbers의 범위가 최대 1.000.000이기에 시간초과를 고려해야 한다. -&gt; O(n) 수준</span>
        <span class="c1">// 4. 이때, Stack을 활용해 현재 원소와 스택의 정상값을 비교해가며 뒷 큰수를 확인한다.</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">numbers</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>

        <span class="c1">// 스택은 [인덱스: numbers값] 형식으로 담는다.</span>
        <span class="nc">Stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// 먼저 numbers의 첫번째 값을 담는다.</span>
        <span class="n">st</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">0</span><span class="o">,</span> <span class="n">numbers</span><span class="o">[</span><span class="mi">0</span><span class="o">]});</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">numbers</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            
            <span class="c1">// 현재 인덱스의 값</span>
            <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            
            <span class="c1">// 현재 값(num)이 이전 원소(스택의 정상값=st.peek()[1])보다 클 경우 뒷 큰수를 충족한다.</span>
            <span class="k">while</span><span class="o">(!</span><span class="n">st</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="n">st</span><span class="o">.</span><span class="na">peek</span><span class="o">()[</span><span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                <span class="kt">int</span><span class="o">[]</span> <span class="n">toBig</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="na">pop</span><span class="o">();</span>
                <span class="n">answer</span><span class="o">[</span><span class="n">toBig</span><span class="o">[</span><span class="mi">0</span><span class="o">]]</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// 현재 인덱스와 값을 스택에 담는다.</span>
            <span class="n">st</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">i</span><span class="o">,</span> <span class="n">numbers</span><span class="o">[</span><span class="n">i</span><span class="o">]});</span>

        <span class="o">}</span>

        <span class="c1">// 뒷 큰수가 존재하지 않는 값들의 위치를 -1로 갱신한다.</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">st</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">answer</span><span class="o">[</span><span class="n">st</span><span class="o">.</span><span class="na">pop</span><span class="o">()[</span><span class="mi">0</span><span class="o">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        
        <span class="c1">// int[] numbers = new int[]{2, 3, 3, 5};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">numbers</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">9</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>

        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">numbers</span><span class="o">);</span>

    <span class="o">}</span>

<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<p>-
—</p>

<p><br /></p>

<h3 id="출처">출처</h3>
<p>-
—</p>

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://school.programmers.co.kr/learn/courses/30/lessons/154539">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 2 - 뒤에 있는 큰 수 찾기]]></summary></entry><entry><title type="html">[Java] 프로그래머스(level-2) - 더 맵게</title><link href="http://localhost:4000/java/239-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-2) - 더 맵게" /><published>2023-08-02T00:00:00+09:00</published><updated>2023-08-02T00:00:00+09:00</updated><id>http://localhost:4000/java/239-post</id><content type="html" xml:base="http://localhost:4000/java/239-post/"><![CDATA[<p><br /></p>

<center><img src="/assets/images/programmers/" width="100%" /></center>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />

<p>이번 문제는 <strong>우선순위 큐</strong>를 활용한 <strong>최소 힙</strong>을 구현하여 풀 수 있다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>이 문제는 힙에 대한 지식이 어느정도 필요하다.</p>

<blockquote>
  <p>여기서 말하는 Heap(힙)은 최소값 및 최대값을 최대한 빠르게 찾아내기 위해 특별히 고안된 자료 구조이다.</p>
</blockquote>

<p>Java에서는 일반적으로 우선순위 큐인 PriorityQueue를 이용해 힙을 구현한다.</p>

<blockquote>
  <p>PriorityQueue는 우선순위 큐를 구현한 자료구조로서, 내부적으로 이진 힙(Binary Heap)을 사용하여 요소들을 저장하고 관리한다. 이진 힙은 완전 이진 트리의 형태를 갖춘 특별한 형태의 힙 자료구조로서, 최소 힙 또는 최대 힙의 형태로 사용될 수 있다.</p>
</blockquote>

<p>여기서 중요한 점은 바로 우선순위 큐를 이용하면 큐의 원소들은 우선순위에 따라 자동으로 정렬된다, <strong>즉 우선순위를 설정하여 정렬</strong>할 수 있다는 것이다. 문제대로라면 스코빌 지수가 K 이상이 되도록 모든 음식을 섞어야 하기에 <strong>첫번째 최소값과 두번째 최소값을 알기 위해 큐를 오름차순으로 정렬</strong>해 두어야 한다.</p>

<p>이러한 우선순위 큐를 이용해 문제 풀이를 위한 아이디어는 다음과 같다.</p>

<ol>
  <li>우선순위 큐의 우선순위를 최소로 설정한다.(PriorityQueue는 기본값으로 최소값이 우선순위가 되도록 제공한다.)</li>
  <li>우선순위큐에 scoville의 원소들을 담는다.</li>
  <li>큐의 첫번째 값이 K보다 작다면, <code class="language-plaintext highlighter-rouge">첫번째 최소값 + (두번째 최소값 * 2)</code> 연산을 수행해 큐에 재삽입한다.</li>
  <li>3번 과정을 반복하며 섞는 횟수를 1 증가시킨다.</li>
  <li>위 3-4번 과정을 반복하며 큐의 첫번째 값이 K보다 크다면 순회를 종료하고 섞는 횟수를 출력한다.</li>
  <li>이때, 첫번째 값이 K보다 작다면 모든 수를 K 이상으로 만들 수 없기에 종료하고 -1을 출력한다.</li>
</ol>

<p><br /></p>

<p>다음으로 문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
</pre></td><td class="rouge-code"><pre>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">scoville</span><span class="o">,</span> <span class="kt">int</span> <span class="no">K</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// 1. scoville의 최솟값이 K보다 커야 한다.</span>
        <span class="c1">// 2. 최솟값이 K보다 작다면, 섞어야 한다.</span>
        <span class="c1">// 3. 첫번째 최소값+(두번째 최솟값*2) 연산의 값을 다시 삽입한다.</span>
        <span class="c1">// 4. 위 1-3번 과정을 반복하며 scoville의 최소값이 K보다 크다면 섞은 횟수를 출력한다.</span>
        <span class="c1">// 5. 이때, scoville을 우선순위 큐를 이용해 최소 힙처럼 사용한다.</span>

        <span class="c1">// 우선순위 큐 선언</span>
        <span class="c1">// 기본으로 최소값을 우선으로 두는 힙처럼 사용할 수 있다.</span>
        <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;();</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">scoville</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">scoville</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>

        <span class="c1">// 스코빌 지수를 K 이상으로 만들기 위해 섞는 횟수</span>
        <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        
        <span class="c1">// 모든 음식을 K 이상으로 만들 수 있는지 여부를 담을 변수</span>
        <span class="kt">boolean</span> <span class="n">possiable</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

        <span class="k">while</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">&lt;</span> <span class="no">K</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 큐의 원소가 하나남았음에도 K를 만들지 못한다면 </span>
            <span class="c1">// 모든 원소를 K 이상으로 만들지 못하기에 순회를 종료한다.</span>
            <span class="k">if</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">&lt;</span> <span class="no">K</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">possiable</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            
            <span class="c1">// 첫번째 최소값+(두번째 최솟값*2) 연산한 값을 큐에 재삽입한다.</span>
            <span class="kt">int</span> <span class="n">first_min</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">second_min</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">first_min</span><span class="o">+(</span><span class="n">second_min</span><span class="o">*</span><span class="mi">2</span><span class="o">));</span>
            
            <span class="c1">// 섞는 횟수를 1 증가시킨다.</span>
            <span class="n">answer</span><span class="o">++;</span>

        <span class="o">}</span>
        
        <span class="c1">// 모든 원소를 K 이상으로 만들지 못하기에 -1을 반환한다.</span>
        <span class="k">if</span><span class="o">(!</span><span class="n">possiable</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
        
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        
        <span class="c1">// int[] scoville = new int[]{1, 2, 3, 9, 10, 12};</span>
        <span class="c1">// int K = 7;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">scoville</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">6</span><span class="o">};</span>
        <span class="kt">int</span> <span class="no">K</span> <span class="o">=</span> <span class="mi">24</span><span class="o">;</span>

        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">scoville</span><span class="o">,</span> <span class="no">K</span><span class="o">);</span>

    <span class="o">}</span>

<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<p>-
—</p>

<p><br /></p>

<h3 id="출처">출처</h3>
<p>-
—</p>

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://school.programmers.co.kr/learn/courses/30/lessons/42626">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 2 - 더 맵게]]></summary></entry><entry><title type="html">[Java] 백준(실버-1) 11286번 - 절댓값 힙</title><link href="http://localhost:4000/java/237-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-1) 11286번 - 절댓값 힙" /><published>2023-07-29T00:00:00+09:00</published><updated>2023-07-29T00:00:00+09:00</updated><id>http://localhost:4000/java/237-post</id><content type="html" xml:base="http://localhost:4000/java/237-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 우선순위 큐를 이용해 요구한 힙을 구현하면 되는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>이번 문제는 <a href="https://langoustinee.github.io/java/231-post/">최대 힙</a> 문제와 같이 <code class="language-plaintext highlighter-rouge">PriorityQueue</code>를 사용해 <code class="language-plaintext highlighter-rouge">Comparator</code>의 <strong>compare()</strong> 메서드를 오버라이딩하여 큐에 삽입되는 데이터를 주어진 조건대로 정렬해야 한다.</p>

<p>문제를 잘 살펴보면, 큐의 우선순위를 절댓값이 작은 순서에서 숫자가 작은 순서로 제거해야 한다는 것을 알 수 있다.</p>

<ol>
  <li>두 수(o1, o2)의 절댓값이 같다면, 두 수 중 <strong>더 큰 수를 기준으로 우선순위가 높게 책정</strong>되도록 한다.</li>
  <li>두 수의 절댓값이 다르다면, 두 수의 절댓값의 차 즉, <strong>절댓값이 작은 수의 우선순위가 높게 책정</strong>되도록 한다.</li>
  <li>결과적으로 절댓값이 작은 순서로 정렬되도록 한다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
        
        <span class="c1">// 람다식으로 풀이</span>
        <span class="c1">// 절댓값이 작은 순서로 정렬된다.</span>
        <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;((</span><span class="n">o1</span><span class="o">,</span> <span class="n">o2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>

            <span class="c1">// 두 수의 절댓값이 같고 앞 수가 더 크다면, 더 큰수의 우선순위를 높게 설정된다.</span>
            <span class="k">if</span><span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">o1</span><span class="o">)</span> <span class="o">==</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">o2</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">o1</span> <span class="o">&gt;</span> <span class="n">o2</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// 두 수의 절댓값이 다르다면 절댓값이 작은 수의 우선순위가 높게 설정된다.</span>
            <span class="k">return</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">o1</span><span class="o">)</span> <span class="o">-</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">o2</span><span class="o">);</span>

        <span class="o">});</span>

        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
            
            <span class="c1">// 만약 입력값이 0보다 큰 자연수라면 우선순위 큐에 삽입.</span>
            <span class="k">if</span><span class="o">(</span><span class="n">num</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            
            <span class="c1">// 0일 때 우선순위 큐가 비어있다면 0을, 비어있지 않다면 가장 작은 수를 꺼낸다.</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">()+</span><span class="s">"\n"</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"0"</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
            <span class="o">}</span>
            
        <span class="o">}</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/11286">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[11286번 - 절댓값 힙]]></summary></entry></feed>