<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-05-31T18:00:43+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">lango’s DevLog</title><subtitle>developer</subtitle><author><name>lango</name></author><entry><title type="html">[Java] 프로그래머스(level-2) - 숫자 블록</title><link href="http://localhost:4000/java/159-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-2) - 숫자 블록" /><published>2023-05-31T00:00:00+09:00</published><updated>2023-05-31T00:00:00+09:00</updated><id>http://localhost:4000/java/159-post</id><content type="html" xml:base="http://localhost:4000/java/159-post/"><![CDATA[<p><br /></p>
<center><img src="/assets/images/programmers/ㄴ.png" width="100%" /></center>
<p><br /></p>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre></td><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">java_study</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">long</span> <span class="n">begin</span><span class="o">,</span> <span class="kt">long</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// end+1 크기의 배열에서 인덱스 별로 1과 자신을 제외한 가장 큰 약수를 삽입하면 된다.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[(</span><span class="kt">int</span><span class="o">)(</span><span class="n">end</span><span class="o">-</span><span class="n">begin</span><span class="o">+</span><span class="mi">1</span><span class="o">)];</span>
        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">begin</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">answer</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">getMaxDivisor</span><span class="o">(</span><span class="n">start</span><span class="o">);</span>
            <span class="n">start</span><span class="o">++;</span>   
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">getMaxDivisor</span><span class="o">(</span><span class="kt">int</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 1일 경우 0 반환</span>
        <span class="k">if</span><span class="o">(</span><span class="n">number</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="c1">// 소수가 아닐 경우 1과 지신을 제외한 최대 약수 값 반환</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="nc">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">number</span><span class="o">);</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">number</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                <span class="c1">// 숫자블록은 10,000,000까지 놓을 수 있다. 그래서 number의 약수중 10^7 이하인 가장 큰 수를 넣어야 한다.</span>
                <span class="k">if</span><span class="o">((</span><span class="n">number</span><span class="o">/</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;=</span> <span class="mi">10000000</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">number</span><span class="o">/</span><span class="n">i</span><span class="o">);</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span> 
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()&gt;</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="c1">// 소수일 경우 1을 반환</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>

        <span class="c1">// long begin = 1;</span>
        <span class="c1">// long end = 10;</span>
        <span class="c1">// long begin = 2;</span>
        <span class="c1">// long end = 5;</span>
        <span class="kt">long</span> <span class="n">begin</span> <span class="o">=</span> <span class="mi">100000014</span><span class="o">;</span>
        <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">100000016</span><span class="o">;</span>

        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">begin</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<ul>
  <li>
    <hr />
  </li>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://school.programmers.co.kr/learn/courses/30/lessons/12923#qna">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 2 - 숫자 블록]]></summary></entry><entry><title type="html">[Java] 백준(실버-2) 24479번 - 알고리즘 수업(깊이 우선 탐색 1)</title><link href="http://localhost:4000/java/158-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-2) 24479번 - 알고리즘 수업(깊이 우선 탐색 1)" /><published>2023-05-26T00:00:00+09:00</published><updated>2023-05-26T00:00:00+09:00</updated><id>http://localhost:4000/java/158-post</id><content type="html" xml:base="http://localhost:4000/java/158-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-분석">문제 분석</h3>

<hr />

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="c1">// 방문한 정점을 담을 배열</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">visited</span><span class="o">;</span>
    <span class="c1">// 인접 리스트</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">list</span><span class="o">;</span>
    <span class="c1">// 방문 순서</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        
        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="kt">int</span> <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="kt">int</span> <span class="no">R</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

        <span class="c1">// 방문 배열 초기화</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>

        <span class="c1">// 인접리스트 초기화(1 ~ N)</span>
        <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;());</span>
        <span class="o">}</span>

        <span class="c1">// M개의 간선 입력받으며 인접리스트 구현</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">M</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
            <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
            <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
            <span class="c1">// 무방향이기에 양쪽 정점을 모두 추가</span>
            <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">start</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">end</span><span class="o">);</span>
            <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">end</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">start</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="c1">// 인접리스트의 각 노드 오름차순 정렬</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
        
        <span class="c1">// 방문 순서 초기화</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        
        <span class="c1">// DFS 호출</span>
        <span class="no">DFS</span><span class="o">(</span><span class="no">R</span><span class="o">);</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">visited</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="s">"\n"</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">DFS</span><span class="o">(</span><span class="kt">int</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">node</span><span class="o">]</span> <span class="o">=</span> <span class="n">cnt</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">:</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">node</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">n</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">cnt</span><span class="o">++;</span>
                <span class="no">DFS</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/24479">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[24479번 - 알고리즘 수업(깊이 우선 탐색 1)]]></summary></entry><entry><title type="html">[Java] 백준(실버-2) 18353번 - 병사 배치하기</title><link href="http://localhost:4000/java/157-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-2) 18353번 - 병사 배치하기" /><published>2023-03-29T00:00:00+09:00</published><updated>2023-03-29T00:00:00+09:00</updated><id>http://localhost:4000/java/157-post</id><content type="html" xml:base="http://localhost:4000/java/157-post/"><![CDATA[<p><br /></p>

<center><img src="/assets/images/baekjoon/18353-attach01.png" width="100%" /></center>
<center><img src="/assets/images/baekjoon/18353-attach02.png" width="100%" /></center>

<p><br /><br /></p>

<h3 id="문제-분석">문제 분석</h3>

<hr />

<p>이번 문제는 내림차순으로 병사를 배치하기 위해서 내림차순 순서가 맞지 않는 병사들을 제외시켜야 한다.</p>

<p>이 때 LIS라는 최장 증가 부분 수열 알고리즘을 이용하여 정답을 구할 수 있다. 이 LIS를 구하기 위해 DP와 이분탐색 2가지 풀이 방법으로 문제를 풀어보겠다.</p>

<h3 id="lis란">LIS란?</h3>

<p><strong>LIS(Longest Increasing Subsequenc)</strong>란 최장 증가 부분 수열이라고 한다. 즉 가장 긴 증가하는 부분 수열이라는 뜻이다.</p>

<p>LIS는 원소가 N개인 배열의 일부 원소를 골라내서 만든 부분 수열 중에서 각 원소가 이전 원소보다 크다는 조건을 만족하고, 그 길이가 최대인 부분 수열을 최장 증가 부분 수열이라고 한다. 바로 <strong>오름차순으로 증가하는 형태의 부분 수열이며, 해당 수열의 길이가 가장 긴 수열</strong>을 뜻한다.</p>

<center><img src="https://velog.velcdn.com/images%2Fkimdukbae%2Fpost%2Feaade731-0699-437b-a5bd-faf3341487d2%2Fimage.png" width="80%" /></center>

<p>예를 들어, <code class="language-plaintext highlighter-rouge">{10, 21, 1, 10, 20, 30, 40, 50, 60}</code> 이라는 배열이 있을 경우, LIS는 <strong><code class="language-plaintext highlighter-rouge">{1, 10, 20, 30, 40, 50, 60}</code></strong>이다. <code class="language-plaintext highlighter-rouge">{1, 10, 20}</code>, <code class="language-plaintext highlighter-rouge">{1, 10, 20, 30, 40}</code>과 같이 증가하는 부분 수열은 많지만 그 중에서 가장 긴 수열이 LIS가 되기 때문에 <code class="language-plaintext highlighter-rouge">{1, 10, 20, 30, 40, 50, 60}</code>가 되는 것이다.</p>

<p>이러한 LIS, 즉 최장 증가 부분 수열의 길이를 구하는 것은 일반적으로 <strong>DP(동적계획법)</strong>을 이용한다.</p>

<p><br /></p>

<h3 id="dp동적게획법란">DP(동적게획법)란?</h3>

<p>DP란, 하나의 큰 문제를 작은 문제로 나누어 해결하는 기법을 의미한다. 특정한 알고리즘을 지칭하는 것이 아니라, 기법 그 자체를 의미한다. 같은 DP로 문제를 풀어도 다른 알고리즘을 이용할 수도 있다는 것이다.</p>

<h4 id="dp의-2가지-조건">DP의 2가지 조건</h4>

<p>DP가 적용되기 위해서, 또는 문제풀이 기법이 DP라 부르기 위해서는 2가지 조건이 필요하다.</p>

<ul>
  <li><strong>겹치는 소문제</strong>(Overlapping Subproblems)</li>
  <li><strong>최적 부분 구조</strong>(Optimal Substructure)</li>
</ul>

<p>먼저 겹치는 소문제에 대해서 알아보자.
기본적으로 DP는 문제를 작은 문제로 나누고, 작은 문제의 결과를 재사용해서 원하는 결과를 도출하는 과정이다. 따라서 문제를 작은 문제를 나눴을 때 작은 문제들이 동일하게, 또는 비슷한 형태로 반복될 경우에 DP를 적용할 수 있다.
만약 문제를 나눌 순 있어도, <strong>중복되는 부분이 없어 각 소문제의 결과를 재사용할 수 없다면 DP를 적용하기 어렵다.</strong></p>

<p>다음은 최적 부분 구조이다. 소문제들의 최적 결과 값을 이용해 전체 문제의 최적 결과를 낼 수 있는 경우에 DP를 적용할 수 있다.
자세하게 설명해보자면, 소문제에서 구한 최적의 결과가 전체 문제에서도 적용되며 이는 변하지 않을 때만 DP를 사용할 수 있다는 것이다.</p>

<p><br /></p>

<h4 id="dp의-2가지-구현-방식">DP의 2가지 구현 방식</h4>

<p>DP를 적용하는 단계에서 구현을 할 때, 보통 두 가지 방법이 있다. 각각 Top-Down방식과 Botton-Up방식이다.</p>

<p><strong>Botton-Up</strong>방식은 말 그대로 초기조건을 기반으로 차곡차곡 데이터를 쌓아가 큰 문제의 결과를 도출하는 과정이다. 보통 반복문을 사용한다. 예를 들어 메모이제이션을 위한 배열 dp[]가 있었다면, dp[0] 부터 차례로 값을 채운다. Bottom-Up에 한하여 이러한 값 채우기를 본 떠 메모이제이션을 Tabulation이라 부르기도 한다.</p>

<p><strong>Top-Down</strong>방식은 주로 재귀함수를 사용하며 dp[n]값을 찾기 위한 재귀 함수의 호출이 dp<a href="또는 초기 조건까지">0</a> 내려간 다음 결과들이 재귀 함수에 맞물리며 재활용되는 방식이다.</p>

<p>이번 문제는 Botton-Up방식을 활용하여 풀어보았다.</p>

<p><br /><br /></p>

<h3 id="dp를-활용한-풀이---botton-up">DP를 활용한 풀이 - Botton-Up</h3>

<hr />

<p>자, 이제 DP를 이용해 LIS의 길이를 구해서 제외해야할 병사의 수를 구하는 코드를 작성해보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">seq</span><span class="o">;</span>
<span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span><span class="o">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>주어진 병사의 전투력을 담을 int 배열 seq와 dp를 static 키워드로 선언하여 main 메소드 바깥에서도 사용할 수 있도록 선언하였다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
<span class="n">seq</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
<span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>첫번째 줄에서 병사의 수 N을 입력받은 후, seq 배열과 dp 배열을 N과 같은 크기로 초기화한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">seq</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>두번째 줄에서 병사의 전투력을 공백 기준으로 입력받게 되는데 StringTokenizer를 이용해 seq 배열에 병사의 전투력을 입력순으로 저장한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="c1">// 모든 부분 수열의 길이는 1이기에 먼저 1로 초기화</span>
    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="c1">//</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">seq</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">seq</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]+</span><span class="mi">1</span><span class="o">);;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>기본적인 LIS라면 <strong>오름차순 형식(최장 증가)</strong>의 부분 수열을 구해야 하겠지만 이번 병사 배치하기 문제에서는 <strong>내림차순으로 정렬된 형태(최장 감소)</strong>의 부분 수열들 중의 최대의 길이를 가지는 부분 수열을 구해야 한다.</p>

<p>그래서 0부터 N-1 만큼 탐색하면서 주어진 배열에서 인덱스(i)를 한 칸씩(+=1) 늘려가면서 확인한다.
그리고 중첩 for문에서 i보다 작은 인덱스(j)들을 하나씩 살펴 보면서 <code class="language-plaintext highlighter-rouge">seq[j]</code>가 <code class="language-plaintext highlighter-rouge">seq[i]</code>보다 큰 값이라면, <strong><code class="language-plaintext highlighter-rouge">dp[i]</code> 를 새로 저장</strong>하면 된다.</p>

<p>여기서 dp[i]를 변경하는 값의 기준은 아래와 같다.</p>

<ul>
  <li>i번째 인덱스에서 끝나는 최장 감소 부분 수열의 마지막에 <code class="language-plaintext highlighter-rouge">seq[i]</code>를 추가했을 때의 LIS 길이와, 추가하지 않고 기존의 <code class="language-plaintext highlighter-rouge">dp[i]</code> 값 둘 중에 더 큰 값(길이가 긴 값)으로 <code class="language-plaintext highlighter-rouge">dp[i]</code> 값을 변경하면 된다.</li>
</ul>

<p>위와 같이 dp 배열을 채우면, dp 배열의 최댓값이 LIS의 길이가 되어 최댓값을 출력하면 된다.
이 때는, 바로 최장 감소 부분 수열을 구하기 위해 max라는 변수에 최대값을 저장하였다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="no">N</span> <span class="o">-</span> <span class="n">max</span> <span class="o">+</span> <span class="s">"\n"</span><span class="o">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>마지막으로 제외시킬 병사들의 수를 출력해야 한다.
결국 입력값 N에서 앞서 구한 max 값을 뺄셈한 값이 남아있는 병사들의 수가 된다.</p>

<p><br /></p>

<h3 id="이분-탐색읋-활용한-풀이---추가할-예정">이분 탐색읋 활용한 풀이 - 추가할 예정</h3>

<hr />

<p>앞에서 살펴본 DP를 통해 LIS를 구하는 방법의 시간복잡도는 <strong>O(n^2)</strong>가 되는데, 이는 굉장이 비효율적이다. 그래서 시간복잡도를 줄이기 위해 <strong>이분 탐색</strong>을 활용해보려 한다.</p>

<blockquote>
  <p><em>입력 값이 백만 개 정도만 되어도 O(n^2)의 알고리즘은 실행시간이 10초 이상 소요된다고 알려져 있다.</em></p>
</blockquote>

<p>LIS의 형태를 유지하기 위해 주어진 배열의 인덱스를 하나씩 살펴보면서 그 숫자가 들어갈 위치를 이분탐색으로 탐색해서 넣는다.
이분탐색은 일반적으로 시간복잡도가 O(logn)으로 알려져 있으므로, 위의 문제를 O(blogs)의 시간복잡도로 해결할 수 있게 된다.</p>

<p><br /></p>

<h3 id="작성코드---dp">작성코드 - DP</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.BufferedReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.BufferedWriter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStreamReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.OutputStreamWriter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.StringTokenizer</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>

        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">seq</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">dp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>

        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">seq</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">seq</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">seq</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                    <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">dp</span><span class="o">[</span><span class="n">j</span><span class="o">]+</span><span class="mi">1</span><span class="o">);;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">dp</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="o">}</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="no">N</span> <span class="o">-</span> <span class="n">max</span> <span class="o">+</span> <span class="s">"\n"</span><span class="o">);</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="작성코드---이분-탐색">작성코드 - 이분 탐색</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>

<hr />

<ul>
  <li>LIS라는 최장 증가 부분 수열을 구하는 알고리즘에 대해서 알아볼 수 있었다.</li>
  <li>DP를 풀 때 Botton-Up방식으로는 풀어보았지만, 재귀 호출을 주로 다루는 Top-down 방식으로도 풀어보아야 겠다.</li>
  <li>
    <p>dp 배열을 Integer 배열로 선언할 수 도 있었는데, 이유는 DP를 통해 반복을 하며 dp배열의 원소가 null일 때를 비교해야 하기 때문이다. 이 때, int 배열에서도 0으로 비교하면 되겠지만, Collections.max() 메소드로 LIS의 최대 길이를 구하기 위해 dp 배열을 List로 변환해야 하는데, int배열은 List로 변환되지 않기 때문이다.</p>
  </li>
  <li>int 배열이 List로 변환되지 않는 이유는 int[] 배열은 기본 자료형(primitive type)의 배열이기에 Arrays.asList() 메소드를 통해 List로 변환할 수 없다. 이는 Arrays.asList() 메소드가 매개변수로 전달된 객체를 배열이 아닌 컬렉션(Collection) 형태로 반환하기 때문이다.</li>
</ul>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/18353">문제 링크</a>에서 참조바랍니다.</li>
  <li><a href="https://velog.io/@kimdukbae/BOJ-11053-%EA%B0%80%EC%9E%A5-%EA%B8%B4-%EC%A6%9D%EA%B0%80%ED%95%98%EB%8A%94-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4-Python">LIS 이미지 출처</a></li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[18353번 - 병사 배치하기]]></summary></entry><entry><title type="html">[Java] 백준(실버-3) 18310번 - 안테나</title><link href="http://localhost:4000/java/156-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-3) 18310번 - 안테나" /><published>2023-03-20T00:00:00+09:00</published><updated>2023-03-20T00:00:00+09:00</updated><id>http://localhost:4000/java/156-post</id><content type="html" xml:base="http://localhost:4000/java/156-post/"><![CDATA[<p><br /></p>

<center><img src="/assets/images/baekjoon/18310.png" width="100%" /></center>

<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<p>이번 문제는 <strong>그리디 알고리즘과 정렬</strong>을 알고 있다면 쉽게 풀 수 있는 문제이다.</p>

<h4 id="그리디-알고리즘이란">그리디 알고리즘이란?</h4>

<p><strong>그리디 알고리즘(Greedy Algorithm)</strong>은 최적해를 구하는 데 사용되는 방법 중 하나이다.
가장 직관적인 알고리즘 설계 패러타임 중 하나이며, <strong>매번 단계에서 선택할 때마다 가장 좋은 답을 선택</strong>하는 기법이다. 지금 선택한 것을 앞으로의 남은 선택에 영향을 끼칠지 고려하지 않는다는 전제이며, 전반적으로 적절한 결과를 도출하자는 알고리즘 기법이다. 항상 최적의 답을 구하는 것은 아니지만 어느정도 최적의 답에 근사한 결과를 빠르게 구할 수 있다는 장점이 있다. 특정 상황에서는 그리디 알고리즘이 최적의 답을 보장할 수도 있다.</p>

<p><img src="/assets/images/baekjoon/18310-attach01.png" width="100%" /></p>

<h3 id="문제-분석">문제 분석</h3>

<p>처음엔 단순히 집들의 평균거리를 구해서 평균과 가장 가까운 집을 선택하면 될 것이라 생각했지만 아니었다. <br /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>N = 5
1 6 9 9 9
</pre></td></tr></tbody></table></code></pre></div></div>

<p><img src="/assets/images/baekjoon/18310-attach02.png" width="100%" /></p>

<p>위 예제를 보면 평균을 구하면 6.8이므로 가장 가까운 건 <code class="language-plaintext highlighter-rouge">6</code>이지만, 6의 거리 차이의 합은 <code class="language-plaintext highlighter-rouge">14</code>이고 9의 거리의 차이는 실제로 <code class="language-plaintext highlighter-rouge">11</code>이기에 <code class="language-plaintext highlighter-rouge">6</code>이 아닌 <code class="language-plaintext highlighter-rouge">9</code>일 때 최소 거리의 합이 충족된다.
따라서 평균 값으로 구하면 안된다는 것을 알 수 있었다.</p>

<ul>
  <li>처음 <code class="language-plaintext highlighter-rouge">1</code>의 위치에 있을 때 차이의 합은 <code class="language-plaintext highlighter-rouge">29(0+5+8+8+8)</code> 이다.</li>
  <li><code class="language-plaintext highlighter-rouge">2</code>의 위치에 있다면 <code class="language-plaintext highlighter-rouge">26(1+4+7+7+7)</code> 이다.</li>
  <li><code class="language-plaintext highlighter-rouge">3</code>의 위치라면 <code class="language-plaintext highlighter-rouge">23(2+3+6+6+6)</code> 이다.</li>
  <li><code class="language-plaintext highlighter-rouge">4</code>의 위치라면 <code class="language-plaintext highlighter-rouge">20(3+2+5+5+5)</code> 이다.</li>
  <li><code class="language-plaintext highlighter-rouge">5</code>의 위치라면 <code class="language-plaintext highlighter-rouge">17(4+1+4+4+4)</code> 이다.</li>
  <li><code class="language-plaintext highlighter-rouge">6</code>의 위치라면 <code class="language-plaintext highlighter-rouge">14(5+0+3+3+3)</code> 이다.</li>
  <li><code class="language-plaintext highlighter-rouge">7</code>의 위치에 있다면 <code class="language-plaintext highlighter-rouge">13(6+1+2+2+2)</code> 이다.</li>
  <li><code class="language-plaintext highlighter-rouge">8</code>의 위치에 있다면 <code class="language-plaintext highlighter-rouge">12(7+2+1+1+1)</code>이다.</li>
  <li><code class="language-plaintext highlighter-rouge">9</code>의 위치라면 <code class="language-plaintext highlighter-rouge">11(8+3+0+0+0)</code> 이다.</li>
</ul>

<p>즉,<code class="language-plaintext highlighter-rouge">1</code>부터 순회하면 현재 위치보다 좌측 지점의 수만큼 <code class="language-plaintext highlighter-rouge">+N</code>이 되고, 현재 위치보다 우측 지점의 수만큼 <code class="language-plaintext highlighter-rouge">-M</code>이 되는 식이다. <br />
그런데 문제에서 요구하는 것은 집이 위치한 곳에만 안테나 설치가 가능하다. 고로 <strong>주어지는 집들의 번호가 여러개일 때 항상 중위값에 위치한 집에 안테나를 설치</strong>하는 것이 가장 적절하다.</p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>이번 문제는 주어진 집들 중 모든 집까지의 거리의 합이 최소가 되는 집을 찾는 문제이기 때문에 결국 <strong>가운데에 위치한 집이 최적의 선택</strong>이 된다. 그 이유는, 모든 집까지의 거리의 합이 최소가 되어야 하므로 중간에 위치한 집이 다른 집들로부터의 거리가 가장 적기 때문이다.</p>

<p>즉, <strong>정렬 후 중간에 위치한 값을 출력</strong>해주면 된다. 그런데 문제에서는 <code class="language-plaintext highlighter-rouge">여러 개의 값이 도출될 경우 가장 작은 값</code>을 원한다고 했으니 N이 짝수일 때와 홀수 일때 기준으로 나누어서 중간 값을 구하면 된다.
예를 들어 5개라면 3번째 값, 6개라면 3번째 값을 출력하면 되는데, 인덱스로 따지면 <code class="language-plaintext highlighter-rouge">N/2-1</code> 인덱스의 값을 출력해주면 된다.</p>

<ul>
  <li>N이 홀수일 때: arr[N/2]</li>
  <li>N이 짝수일 떄: arr[N/2-1]</li>
</ul>

<p><br /></p>

<p>이제 코드를 작성해보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
<span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>N을 입력받고 N만큼의 크기를 가지는 배열을 하나 선언하자. 그리고 N만큼 공백 기준으로 입력받으면서 배열에 집들의 위치를 저장한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">);</span>
<span class="k">if</span><span class="o">(</span><span class="no">N</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="no">N</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="o">]+</span><span class="s">"\n"</span><span class="o">);</span>
<span class="k">else</span> <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="no">N</span><span class="o">/</span><span class="mi">2</span><span class="o">]+</span><span class="s">"\n"</span><span class="o">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>배열의 중간 값을 찾기 위해서 오름차순 정렬을 먼저 진행한다. <br />
그리고 N이 짝수라면 <code class="language-plaintext highlighter-rouge">arr[N/2-1]</code>로 중간값을 찾을 수 있고, 홀수라면 <code class="language-plaintext highlighter-rouge">arr[N/2]</code>로 중간값을 찾으면 된다.</p>

<p>따라서, 주어진 집들을 오름차순으로 정렬한 후, 중간에 위치한 집을 선택하면 최적의 선택이 되어 모든 집까지의 거리의 합이 최소가 된다. <br />
위와 같이 그리디 알고리즘을 사용하여 이 문제를 해결하였다.</p>

<p><br /><br /></p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.BufferedReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.BufferedWriter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStreamReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.OutputStreamWriter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.StringTokenizer</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>

        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>

        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="c1">// 오름차순 정렬을 실시하여 배열의 중위값을 반환해야합니다</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">);</span>

        <span class="c1">// 중위값은 N이 짝수인지, 홀수인지에 따라 나뉘어지므로 이 부분을 구분하여 답을 출력해야합니다</span>
        <span class="k">if</span><span class="o">(</span><span class="no">N</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="no">N</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="o">]+</span><span class="s">"\n"</span><span class="o">);</span>
        <span class="k">else</span> <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="no">N</span><span class="o">/</span><span class="mi">2</span><span class="o">]+</span><span class="s">"\n"</span><span class="o">);</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>

<ul>
  <li>이 문제에서도 가운데에 위치한 집이 최적의 선택이기 때문에 매 순간 최적인 선택을 하는 알고리즘인 그리디 알고리즘을 활용할 수 있었다.</li>
</ul>

<h3 id="출처">출처</h3>

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/18310">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[18310번 - 안테나]]></summary></entry><entry><title type="html">[Java] 백준(골드-5) 2023번 - 신기한 소수</title><link href="http://localhost:4000/java/155-post/" rel="alternate" type="text/html" title="[Java] 백준(골드-5) 2023번 - 신기한 소수" /><published>2023-03-15T00:00:00+09:00</published><updated>2023-03-15T00:00:00+09:00</updated><id>http://localhost:4000/java/155-post</id><content type="html" xml:base="http://localhost:4000/java/155-post/"><![CDATA[<p><br /></p>

<center><img src="/assets/images/baekjoon/2023_attach01.png" width="100%" /></center>
<center><img src="/assets/images/baekjoon/2023_attach02.png" width="100%" /></center>

<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />
<p>이번 <code class="language-plaintext highlighter-rouge">신기한 소수</code> 문제는 소수를 구하는 방법과 재귀를 잘 고려해야 한다. <br />
소수를 판별하기 위해 제곱근까지 순회하는 방식을 이용하였고, 각 자리수별로 소수인지를 알아내기 위해서 재귀를 사용하였다. <br /></p>

<h4 id="에라토스테네스의-체">에라토스테네스의 체</h4>

<p><br />
<img src="/assets/images/baekjoon/2023_attach03.gif" width="60%" />
<br /></p>

<p>에라토스테네스의 체는 <code class="language-plaintext highlighter-rouge">소수가 되는 수의 배수를 지우면 남은 건 소수가 된다.</code>라는 원리의 알고리즘이라고 보면 된다. <br />
그래서, 소수가 무엇인지 찾을 필요가 없으며 2부터 자기 자신을 제외한 배수를 지우면 된다.</p>

<p><br /></p>

<h4 id="에라토스테네스의-체를-이용한-소수-배열을-만들-경우-메모리-초과-발생">에라토스테네스의 체를 이용한 소수 배열을 만들 경우 메모리 초과 발생</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
<span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="nc">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
<span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="nc">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="no">N</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

<span class="kt">boolean</span><span class="o">[]</span> <span class="n">prime_arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">end</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
<span class="n">prime_arr</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">prime_arr</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="nc">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">end</span><span class="o">);</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">prime_arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">+=</span><span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">prime_arr</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>​위처럼 에라토스네테스의 체를 이용해 소수 배열을 만들어 두고 문제를 풀려했으나 <strong>메모리 초과가 발생</strong>하였다.</p>

<p>그래서 문제 요구사항을 다시 살펴보았다.</p>
<ul>
  <li>시간 제한: 2초</li>
  <li>메모리 제한: 4MB</li>
</ul>

<p>이 문제는 <strong>메모리 제한이 4MB</strong>밖에 되지 않기 때문에 에라토스테네스의 체 알고리즘을 이용해서 배열에 <strong>소수 판별을 저장한 배열을 사용한</strong>다면 N이 8까지 주어질 수 있어, <strong>천만 자리수까지 고려해야 하기에 메모리 초과가 발생</strong>하게 되었다고 판단하였다. 또한, 위 코드는 시간 복잡도가 <strong>O(NloglogN)</strong>으로, 지금처럼 n이 매우 큰 경우라면 시간초과가 추가적으로 발생할 우려가 있었다.</p>

<p>그래서 에라토스테네스의 체를 소수 배열을 만드는 것에 이용하는 것이 아니라 <strong>재귀함수를 이용해 모든 수를 탐색하며 소수 판별을 하는데 이용</strong>해야 한다.</p>

<p><br /></p>

<h4 id="문제-분석-및-아이디어-도출">문제 분석 및 아이디어 도출</h4>
<p>일단 N은 1부터 8까지의 범윌를 가지고 있으며 1이면 1자리수, 2이면 2자리수 형식의 범위를 나타낸다. 또한, 이 문제의 핵심은 <strong>자릿수를 하나씩 붙여가는 과정에서 수 대부분을 쉽게 가지 칠 수 있다는 점</strong>이다.</p>
<ul>
  <li>몇 자리수가 됐든, 소수가 되려면 <strong>왼쪽부터 1자리 수가 소수</strong>여야만 한다. 즉 신기한 소수의 <strong>첫째 자리 수는 소수인 <code class="language-plaintext highlighter-rouge">2,3,5,7</code> 중의 하나이고 이 경우에만 다음 자릿수를 붙여가면 된다.</strong></li>
</ul>

<p>첫째 자리 수부터 살펴보자.</p>

<p>소수인 2에 0~9까지 다음 자릿수를 붙여준다면 <code class="language-plaintext highlighter-rouge">23</code>과 <code class="language-plaintext highlighter-rouge">29</code>를 제외한 <code class="language-plaintext highlighter-rouge">20,21,22,24,25,26,27,28</code> 는 소수가 아니기 때문에 걸러낼 수 있다. 이렇게 <strong>소수가 아니라면 다음 자리수를 붙일 필요가 없다.</strong> 결국, 소수가 되는 <code class="language-plaintext highlighter-rouge">23</code>과 <code class="language-plaintext highlighter-rouge">29</code>의 경우에만 다음 자릿수를 붙여가면 된다.</p>

<p>주어진 예제와 같이 N이 4일 경우를 살펴보자.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="rouge-code"><pre>// N = 4
// 1000 ~ 9999 까지 중에서 모든 신기한 소수를 출력해야 한다.
1
2 -&gt; 소수
    20
    21
    22
    23 -&gt; 소수
        230
        231
        232
        233 -&gt; 소수
            2330
            2331
            2332
            2333 -&gt; 신기한 소수(length = 4 = N)
            ...
        ...
    24
    25
    26
    27
    28
    29 -&gt; 소수
3 -&gt; 소수
    30
    ...
4
5 -&gt; 소수
    50
    ...
6
7 -&gt; 소수
    70
    ...
8
9
</pre></td></tr></tbody></table></code></pre></div></div>

<p>2가 아닌 나머지 3,5,7의 경우에도 동일하게 진행하면 된다.
그렇게 이 과정을 반복하며 N의 자리까지 자릿수를 붙여가며 만들어진 수가 <strong>N만큼의 길이를 가졌을 때 그 수가 소수라면 앞에서 자리수 별로 소수 여부를 판별하고 지나왔기에 신기한 소수일 수밖에 없는 것</strong>이다.</p>

<p><br /></p>

<p>위에서 짠 아이디어를 토대로 코드를 작성해보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="no">N</span><span class="o">;</span>
    <span class="o">...</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>먼저 입력받을 N을 재귀 메소드에서 사용하기 위해 static 키워드를 붙여서 Main 클래스의 모든 메소드에서 사용할 수 있도록 선언하였다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
    <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
    <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
    <span class="n">recursion</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
    <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>main 메소드에서는 N을 입력받고 recursion이라는 재귀메소드를 호출하였다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="c1">// 재귀를 통해 N만큼 자리수를 붙여가기</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">recursion</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
        <span class="k">return</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">isPrime</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">str</span> <span class="o">+</span> <span class="n">i</span><span class="o">)))</span> <span class="o">{</span>
            <span class="n">recursion</span><span class="o">(</span><span class="n">str</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>recursion 재귀 메소드를 살펴보자.</p>

<p>str 변수에 <code class="language-plaintext highlighter-rouge">""</code>과 같은 빈 문자열을 받아와서 실행되며, 1부터 9까지의 문자를 이 str 문자열 변수에 붙여가는데, <strong>str 변수에 1부터 9까지 붙여가면서 해당 문자열이 소수인지를 검증</strong>한다. <br />
만약 소수라면 str+i 라는 수가 소수이기에 str+i라는 문자열을 파라미터로 함수를 재귀 호출한다. 이 과정을 반복하면서 <strong>str의 길이가 N만큼 채워졌다면 신기한 소수가 된 것이기에 출력하고 재귀를 종료</strong>한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="c1">// 에라토스테네스의 체로 소수 판별하기</span>
<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isPrime</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">sqrt</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="nc">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">sqrt</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>마지막으로 소수를 판별하는 로직이다. 앞서 말했듯 해당 범위 수의 제곱근까지만큼만 순회하면서 소수를 판별하도록 하였다.
1은 소수가 아니기에 false를 반환하고, 2부터 i의 제곱근까지 순회하면서 소수인 수를 걸러낸다.</p>

<blockquote>
  <p>이 떄, 여기서 i를 제곱근까지만 반복하는 이유는 <strong>i의 제곱이 n보다 크면, i와 n/i 중 하나는 반드시 n의 제곱근보다 작기 때문</strong>이다.
예를 들어, 121의 약수를 구하려면 1부터 11까지 모두 확인해야 하는데, 11보다 큰 약수는 이미 11보다 작은 약수를 통해 구할 수 있기 때문에 11까지만 확인하면 된다. 따라서, i를 제곱근까지만 반복하면, n의 제곱근보다 큰 약수는 확인할 필요가 없어지므로, 반복 횟수를 줄여 연산 속도를 향상시킬 수 있는 것이다.</p>
</blockquote>

<p><br /><br /></p>

<h3 id="작성코드">작성코드</h3>
<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.BufferedReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStreamReader</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="no">N</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="n">recursion</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="c1">// 재귀를 통해 N만큼 자리수를 붙여가기</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">recursion</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span><span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
			<span class="k">return</span><span class="o">;</span>
		<span class="o">}</span>
		<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
			<span class="k">if</span><span class="o">(</span><span class="n">isPrime</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">str</span> <span class="o">+</span> <span class="n">i</span><span class="o">)))</span> <span class="o">{</span>
				<span class="n">recursion</span><span class="o">(</span><span class="n">str</span> <span class="o">+</span> <span class="n">i</span><span class="o">);</span>
			<span class="o">}</span>
		<span class="o">}</span>
	<span class="o">}</span>

    <span class="c1">// 에라토스테네스의 체로 소수 판별하기</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isPrime</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">sqrt</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="nc">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">sqrt</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<ul>
  <li>에라토스테네스의 체를 이용해 소수 배열을 만들어 사용하는 것이 아니라, 소수를 판별하기 위한 방법으로 사용해볼 수 있었다.</li>
  <li>아직 공부가 더 필요하지만, 재귀함수를 이용해 깊이 우선 탐색인 DFS를 구현할 수 있었다.</li>
</ul>

<h3 id="출처">출처</h3>
<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/2023">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[2023번 - 신기한 소수]]></summary></entry><entry><title type="html">[Java] LeetCode(Easy) - 771. Jewels and Stones</title><link href="http://localhost:4000/java/154-post/" rel="alternate" type="text/html" title="[Java] LeetCode(Easy) - 771. Jewels and Stones" /><published>2023-03-14T00:00:00+09:00</published><updated>2023-03-14T00:00:00+09:00</updated><id>http://localhost:4000/java/154-post</id><content type="html" xml:base="http://localhost:4000/java/154-post/"><![CDATA[<p><br /></p>
<center><img src="/assets/images/leetcode/771_01.png" width="100%" /></center>
<p><br /></p>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />
<p>이번 771번 문제는 단순하다. 문제에서 주어지는 문자열의 길이도 50자 이하이기 때문에 굉장히 관대하다.</p>

<h4 id="아이디어-도출">아이디어 도출</h4>
<ul>
  <li>jewels 문자열을 쪼개어 하나씩 보관한다.</li>
  <li>stones 문자열의 각 문자별로 순회하여 앞서 쪼갠 jewels의 문자가 포함되는지 확인한다.</li>
  <li>jewels에서 쪼갠 문자가 포함될 경우 카운트를 증가시킨다.</li>
</ul>

<p><br /></p>

<p>이번 문제에서 사용한 자료구조는 <code class="language-plaintext highlighter-rouge">ArrayList</code>, <code class="language-plaintext highlighter-rouge">HashMap</code> 2가지와 문자열 순회시 일반 <code class="language-plaintext highlighter-rouge">for문</code>과 <code class="language-plaintext highlighter-rouge">foreach문</code>을 활용하였다.</p>

<h4 id="arraylist와-for문을-활용한-풀이">ArrayList와 for문을 활용한 풀이</h4>
<p>코드가 간단하기 때문에 코드를 먼저 살펴보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numJewelsInStones</span><span class="o">(</span><span class="nc">String</span> <span class="n">jewels</span><span class="o">,</span> <span class="nc">String</span> <span class="n">stones</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">jewels</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">jewels</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">stones</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">stones</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)))</span> <span class="n">cnt</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>jewels 문자열을 쪼개서 담을 ArrayList를 하나 생성하고 카운트를 셀 cnt 변수를 선언한다. <br />
그리고 jewels 각 문자만큼 순회하면서 ArrayList에 담는다. 그러고 stones의 각 문자만큼 순회하면서 ArrayList에 포함된 문자인지 <strong>contains 메소드</strong>로 확인하여 카운트를 세면 된다.</p>

<p><br /></p>

<h4 id="foreach문으로-변경">foreach문으로 변경</h4>
<p>위 코드에서 사용한 for문을 foreach문으로 고쳐보았다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numJewelsInStones</span><span class="o">(</span><span class="nc">String</span> <span class="n">jewels</span><span class="o">,</span> <span class="nc">String</span> <span class="n">stones</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">jewels_arr</span> <span class="o">=</span> <span class="n">jewels</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">stones_arr</span> <span class="o">=</span> <span class="n">stones</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">jewels_arr</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">stones_arr</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">c</span><span class="o">))</span> <span class="n">cnt</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>앞에서 본 코드와 동일한 로직이지만 char 타입 변수로 순회하기 위해 입력 문자열 jewels와 stones를 char형 배열을 만들어 사용한다는 차이점이 있다.</p>

<p><br /></p>

<h4 id="arraylist가-아닌-hashmap-활용">ArrayList가 아닌 HashMap 활용</h4>
<p>마지막으로 ArrayList가 아닌 HashMap으로 풀어보았다. 주어지는 문자열의 길이가 길어진다면 HashMap이 더 유리할 수 있기 때문이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numJewelsInStones</span><span class="o">(</span><span class="nc">String</span> <span class="n">jewels</span><span class="o">,</span> <span class="nc">String</span> <span class="n">stones</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">hm</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">jewels_arr</span> <span class="o">=</span> <span class="n">jewels</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">stones_arr</span> <span class="o">=</span> <span class="n">stones</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">jewels_arr</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">hm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">stones_arr</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">hm</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">c</span><span class="o">))</span> <span class="n">cnt</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>ArrayList와는 다르게 put 메소드로 HashMap에 jewels의 각 문자를 집어넣고 <strong>containsKey 메소드</strong>로 HashMap 포함여부를 확인한다.</p>

<p><br /></p>

<h3 id="실행-시간-차이">실행 시간 차이</h3>
<p>ArrayList보다는 HashMap이 더 빠를 줄 알았으나 오히려 ArrayList가 근소하지만 더 빠른 시간을 보여주었다.</p>

<h4 id="arraylist">ArrayList</h4>
<p><img src="/assets/images/leetcode/771_02.png" width="8%" /></p>

<h4 id="hashmap">HashMap</h4>
<p><img src="/assets/images/leetcode/771_03.png" width="8%" /></p>

<p>왜 HashMap이 더 느린 시간이 걸렸을까?</p>

<p>이유를 찾아보니, <strong>ArrayList의 경우 내부적으로 배열을 사용</strong>하고 있기 때문에 <strong>contains 메소드는 내부적으로 순차 탐색을 수행</strong>한다. 이 때, 이 문제에서 요구하는 문자열 길이가 짧기 때문에 한번에 비교할 수 있는 원소들이 많다. 그래서 일반적으로 <strong>원소의 개수가 적을 때는 ArrayList의 contains 메소드가 더 빠를 수 있다</strong>고 한다.</p>

<p>반면에, <strong>HashMap의 경우 내부적으로 해시 테이블을 사용</strong>하고 있고, <strong>해시 테이블은 해시 함수를 이용하여 원소를 저장하고 탐색</strong>한다. 이 떄, 문자열 길이가 짧아도 해시 함수를 계산하는 과정이 추가적으로 필요하기 때문에 <strong>ArrayList에 비해 성능이 떨어질 수 있다</strong>고 한다.</p>

<p>하지만, 이는 일반적인 경우이며 상황에 따라 다를 수 있음을 유의해야 한다. 예를 들어, <strong>원소의 개수가 매우 많고 문자열 길이가 짧은 경우에는 HashMap의 containsKey 메소드가 더 빠를 수 있다.</strong></p>

<p>결국 어떤 자료구조를 선택해야 하는지는 문제의 유형 및 데이터의 특성에 따라 달라지기 때문에, 여러 가지 자료구조 성능에 대해서 어느정도 알고 있어야 한다고 느끼게 되었다.</p>

<p><br /><br /></p>

<h3 id="작성-코드---arraylist-및-for문-활용">작성 코드 - ArrayList 및 for문 활용</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numJewelsInStones</span><span class="o">(</span><span class="nc">String</span> <span class="n">jewels</span><span class="o">,</span> <span class="nc">String</span> <span class="n">stones</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">jewels</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">jewels</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">stones</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">stones</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)))</span> <span class="n">cnt</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="작성코드---arraylist-및-foreach문-활용">작성코드 - ArrayList 및 foreach문 활용</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numJewelsInStones</span><span class="o">(</span><span class="nc">String</span> <span class="n">jewels</span><span class="o">,</span> <span class="nc">String</span> <span class="n">stones</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">jewels_arr</span> <span class="o">=</span> <span class="n">jewels</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">stones_arr</span> <span class="o">=</span> <span class="n">stones</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">jewels_arr</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">stones_arr</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">c</span><span class="o">))</span> <span class="n">cnt</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="작성코드---hashmap-및-foreach-활용">작성코드 - HashMap 및 foreach 활용</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numJewelsInStones</span><span class="o">(</span><span class="nc">String</span> <span class="n">jewels</span><span class="o">,</span> <span class="nc">String</span> <span class="n">stones</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">hm</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">jewels_arr</span> <span class="o">=</span> <span class="n">jewels</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">stones_arr</span> <span class="o">=</span> <span class="n">stones</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">jewels_arr</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">hm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">stones_arr</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">hm</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">c</span><span class="o">))</span> <span class="n">cnt</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<ul>
  <li>ArrayList와 HashMap 자료구조의 성능에 대해서 공부할 수 있었고, for문과 foreach문을 사용하는 이유를 알 수 있었다.</li>
</ul>

<h3 id="출처">출처</h3>
<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://leetcode.com/problems/jewels-and-stones/">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[Easy - 771. Jewels and Stones]]></summary></entry><entry><title type="html">[Java] 프로그래머스(level-2) - 괄호 회전하기</title><link href="http://localhost:4000/java/153-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-2) - 괄호 회전하기" /><published>2023-03-08T00:00:00+09:00</published><updated>2023-03-08T00:00:00+09:00</updated><id>http://localhost:4000/java/153-post</id><content type="html" xml:base="http://localhost:4000/java/153-post/"><![CDATA[<p><br /></p>
<center><img src="/assets/images/programmers/20230308_01.png" width="100%" /></center>
<center><img src="/assets/images/programmers/20230308_02.png" width="100%" /></center>
<p><br /></p>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />
<p>이번 <code class="language-plaintext highlighter-rouge">괄호 회전하기</code> 문제는 <strong>괄호를 검증</strong>하는 것이 가장 주요하다고 볼 수 있다. <br />
그런데, 그냥 하나의 소괄호 <code class="language-plaintext highlighter-rouge">()</code>만 검증하는 것이 아니라 중괄호 <code class="language-plaintext highlighter-rouge">{}</code>와 대괄호 <code class="language-plaintext highlighter-rouge">[]</code> 까지 올바른 괄호대로 포함되어 있는지를 확인해야 한다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>
<ul>
  <li>먼저 주어진 괄호 문자열을 왼쪽으로 한 문자씩 문자열 길이만큼 회전시킨다.
    <ul>
      <li>문자열의 길이와 반복문 인덱스를 활용하여 문자열을 회전시킨다.</li>
    </ul>
  </li>
  <li>왼쪽으로 한 문자씩 회전시킨 문자열마다 올바른 괄호 문자열인지를 검증한다.</li>
  <li>주어진 문자열을 회전시켜서 만들어진 문자열마다 올바른 괄호 문자열인지를 세어서 반환하면 된다.</li>
</ul>

<p><br /></p>

<p>아이디어는 이외로 단순하다. 바로 코드를 작성해보자.</p>

<h4 id="문자열-회전시키기">문자열 회전시키기</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">rotate</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>먼저 주어진 문자열 s를 가지고 왼쪽으로 한 문자씩 회전시키기 위해서 <code class="language-plaintext highlighter-rouge">substring()</code> 메소드를 사용한다. <br />
s의 길이만큼 반복하며 <strong>현재 인덱스에서 문자열 길이만큼 자른 뒤, 0번째부터 현재 인덱스까지 자른다면</strong>, 왼쪽으로 하나씩 회전된 문자열을 만들 수 있게 된다.</p>

<blockquote>
  <p><em>예를 들어 <code class="language-plaintext highlighter-rouge">(){}[]</code> 라는 예제를 보면 <code class="language-plaintext highlighter-rouge">){}[](</code>로 회전하기 위해 <code class="language-plaintext highlighter-rouge">){}[]</code>와 <code class="language-plaintext highlighter-rouge">(</code>를 합해서 만들 수 있다.</em></p>
</blockquote>

<h4 id="괄호-검증하기">괄호 검증하기</h4>
<p>이제 앞에서 주어진 문자열을 왼쪽으로 회전시킨 문자열을 구했으니 회전되는 문자열마다 올바른 괄호 문자열인지 확인하면 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">rotate</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
    <span class="k">if</span><span class="o">(</span><span class="n">isBracket</span><span class="o">(</span><span class="n">rotate</span><span class="o">))</span> <span class="n">answer</span><span class="o">++;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">isBracket</code>이라는 메소드를 만들어 문자열의 괄호 여부를 boolean으로 받아와 answer를 카운트하도록 구현하였다.</p>

<h4 id="잘못된-괄호-검증">잘못된 괄호 검증</h4>
<p>사실 Stack을 사용하지 않고 Map을 활용해서 괄호를 검증할 수 있을 줄로 알아서, 이를 토대로 괄호 검증 함수를 구현하였다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isBracket</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">bracket_map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="n">bracket_map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'('</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="n">bracket_map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'['</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="n">bracket_map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'{'</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">char</span> <span class="n">ch</span> <span class="o">:</span> <span class="n">str</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">switch</span><span class="o">(</span><span class="n">ch</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">case</span> <span class="sc">'('</span><span class="o">:</span>
                <span class="n">bracket_map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'('</span><span class="o">,</span> <span class="n">bracket_map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="sc">'('</span><span class="o">,</span> <span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="sc">'{'</span><span class="o">:</span>
                <span class="n">bracket_map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'{'</span><span class="o">,</span> <span class="n">bracket_map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="sc">'{'</span><span class="o">,</span> <span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="sc">'['</span><span class="o">:</span>
                <span class="n">bracket_map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'['</span><span class="o">,</span> <span class="n">bracket_map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="sc">'['</span><span class="o">,</span> <span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="sc">')'</span><span class="o">:</span>
                <span class="k">if</span><span class="o">(</span><span class="n">bracket_map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="sc">'('</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="n">bracket_map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'('</span><span class="o">,</span> <span class="n">bracket_map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="sc">'('</span><span class="o">,</span> <span class="mi">0</span><span class="o">)-</span><span class="mi">1</span><span class="o">);</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="sc">'}'</span><span class="o">:</span>
                <span class="k">if</span><span class="o">(</span><span class="n">bracket_map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="sc">'{'</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="n">bracket_map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'{'</span><span class="o">,</span> <span class="n">bracket_map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="sc">'{'</span><span class="o">,</span> <span class="mi">0</span><span class="o">)-</span><span class="mi">1</span><span class="o">);</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="sc">']'</span><span class="o">:</span>
                <span class="k">if</span><span class="o">(</span><span class="n">bracket_map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="sc">'['</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="n">bracket_map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'['</span><span class="o">,</span> <span class="n">bracket_map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="sc">'['</span><span class="o">,</span> <span class="mi">0</span><span class="o">)-</span><span class="mi">1</span><span class="o">);</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">default</span><span class="o">:</span>
                <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kt">int</span> <span class="n">small</span> <span class="o">=</span> <span class="n">bracket_map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="sc">'('</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">medium</span> <span class="o">=</span> <span class="n">bracket_map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="sc">'{'</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">big</span> <span class="o">=</span> <span class="n">bracket_map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="sc">'['</span><span class="o">);</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">small</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">medium</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">big</span> <span class="o">==</span> <span class="mi">0</span><span class="o">);</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>HashMap에 <code class="language-plaintext highlighter-rouge">(</code>, <code class="language-plaintext highlighter-rouge">{</code>, <code class="language-plaintext highlighter-rouge">[</code>를 key로 값은 빈도수로 삽입해서 <strong>열린 괄호가 나올 때는 해당 키의 값을 1씩 증가</strong>시키고 <strong>닫힌 괄호가 나왔을 때는 해당 키의 값을 1씩 감소</strong>시켰다.</p>

<p>그리고 Map에 존재하는 <code class="language-plaintext highlighter-rouge">(</code>, <code class="language-plaintext highlighter-rouge">{</code>, <code class="language-plaintext highlighter-rouge">[</code> key에 대한 값들이 모두 0이라면 열린 괄호와 닫힌 괄호의 짝이 잘 맞으니 true를 반환하게 된다.</p>

<p>해당 메소드를 추가하여 테스트 해보니 정상적으로 예제 테스트케이스들이 통과하였고, 제출을 하였으나 테스트 케이스 14번에서 실패하게 되었다. <br />
이유를 살펴보니, 고려하지 못한 검증 조건이 있다는 것을 깨달았다.</p>

<h4 id="자료구조를-stack으로-수정">자료구조를 Stack으로 수정</h4>
<p>고려히지 못한 검증 조건은 주어진 문자열이 <strong>올바른</strong> 괄호 문자열이냐는 것이다. <br />
예를 들어 <code class="language-plaintext highlighter-rouge">({)}</code> 라는 예제를 보면 <code class="language-plaintext highlighter-rouge">(</code>와 <code class="language-plaintext highlighter-rouge">{</code> 모두 열린 괄호와 닫힌 괄호가 한 쌍씩 존재하지만, 올바른 위치에 배치되어 있지 않다. <br /></p>

<p>열린 괄호 <code class="language-plaintext highlighter-rouge">(</code>가 들어갔으면  닫힌 괄호 <code class="language-plaintext highlighter-rouge">)</code>가 나왔을 때 <code class="language-plaintext highlighter-rouge">(</code>가 나와야 하는데, 내가 짠 Map을 활용한 로직에는 <strong>짝은 맞출 수 있으나 올바른 배치로 이루어진 문자열인지에 대한 검증은 하지 못하고 있었던 것</strong>이다. 결국 Map으로는 이를 구현하기가 어렵다고 느껴져 자료구조를 Stack으로 수정하였다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">str</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
    <span class="k">switch</span> <span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">case</span> <span class="sc">'('</span><span class="o">:</span> <span class="k">case</span> <span class="sc">'{'</span><span class="o">:</span> <span class="k">case</span> <span class="sc">'['</span><span class="o">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="sc">')'</span><span class="o">:</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">()</span> <span class="o">!=</span> <span class="sc">'('</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="sc">'}'</span><span class="o">:</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">()</span> <span class="o">!=</span> <span class="sc">'{'</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="sc">']'</span><span class="o">:</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">()</span> <span class="o">!=</span> <span class="sc">'['</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="k">return</span> <span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Stack으로 괄호 문자열 검증하는 것은 이전에도 많이 해보아서 굉장히 쉽게 구현해낼 수 있었다. <br />
간단하게 정리하자면 소괄호, 중괄호, 대괄호의 <strong>열린 괄호가 나온다면 스택에 삽입하고 닫힌 괄호가 나올 때는 스택의 맨 위의 괄호와 일치하는 괄호인지를 확인</strong>하면 된다.</p>

<p>이렇게 고친 코드를 제출하니 정상적으로 14번 테스트케이스까지 모든 테스트케이스를 정상적으로 통과하였다.</p>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">rotate</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">isBracket</span><span class="o">(</span><span class="n">rotate</span><span class="o">))</span> <span class="n">answer</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">answer</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isBracket</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">str</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">switch</span> <span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">case</span> <span class="sc">'('</span><span class="o">:</span> <span class="k">case</span> <span class="sc">'{'</span><span class="o">:</span> <span class="k">case</span> <span class="sc">'['</span><span class="o">:</span>
                    <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="k">case</span> <span class="sc">')'</span><span class="o">:</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">()</span> <span class="o">!=</span> <span class="sc">'('</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="k">case</span> <span class="sc">'}'</span><span class="o">:</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">()</span> <span class="o">!=</span> <span class="sc">'{'</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="k">case</span> <span class="sc">']'</span><span class="o">:</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">()</span> <span class="o">!=</span> <span class="sc">'['</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        
        <span class="c1">// String s = "[](){}";</span>
        <span class="c1">// String s = "}]()[{";</span>
        <span class="c1">// String s = "{{{}";</span>
        <span class="c1">// String s = "(){{))";</span>
        <span class="c1">// String s = "(){{]]";</span>
        <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"{(})"</span><span class="o">;</span>
        
        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<ul>
  <li>문자열을 회전시키기 위해 substring() 메소드를 적절히 활용할 수 있었다.</li>
  <li>Stack을 사용하지않고 Map으로도 올바른 괄호 문자열 검증을 할 수 있을 줄 알았지만 마땅히 아이디어가 떠오르지 않아 Stack을 자료구조로 사용하였다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 2 - 괄호 회전하기]]></summary></entry><entry><title type="html">[Java] 2차원 배열 - 달팽이 만들기</title><link href="http://localhost:4000/java/152-post/" rel="alternate" type="text/html" title="[Java] 2차원 배열 - 달팽이 만들기" /><published>2023-03-07T00:00:00+09:00</published><updated>2023-03-07T00:00:00+09:00</updated><id>http://localhost:4000/java/152-post</id><content type="html" xml:base="http://localhost:4000/java/152-post/"><![CDATA[<p><br /></p>

<h3 id="문제">문제</h3>
<hr />
<p>아래 와 같은 형태로 데이터를 저장하는 이차원 배열을 생성하세요.</p>

<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FyD8yH%2FbtqvbObYz0O%2FwxKKf03EbLNSpxpkSKJihk%2Fimg.png" width="50%" /></p>

<p><br />
<br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />
<p>주어진 문제 보기와 같이 달팽이 모양의 2차원 배열을 만들어야 한다. <br />
여기서 배열을 잘 살펴보면, 안쪽으로 말려 들어가는 달팽이 집과 같은 모양을 보이고 있음을 알 수 있다.</p>

<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbcCJsu%2FbtqvbJvcqgU%2FsdaR8KzGdhKEAPUVymHkSK%2Fimg.png" width="50%" /></p>

<p>이 원리를 코드로 구현하기 위한 아이디어를 생각해보자.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>
<p>정사각형 형태의 배열이기에 가로 열과 세로 행은 같다고 보고, 2차원 배열 안에 채워지는 숫자를 어떻게 채워갈지 정해보자.</p>

<ol>
  <li>1부터 5까지는 첫번째 행에 오른쪽으로 채워지며 5부터 9까지는 5번째 열에 아래로 채워진다.</li>
  <li>10부터 13까지는 5번째 행에서 왼쪽으로 채워지며, 13부터 16까지는 1번째 열에서 위로 채워진다.</li>
  <li>16부터 19까지는 2번째 행에서 오른쪽으로 채워지며, 19부터 21까지는 4번째 열에서 아래로 채워진다.</li>
  <li>21부터 23까지는 4번째 행에서 왼쪽으로 채워지며, 23부터 24까지는 2번째 열에서 위로 채워진다.</li>
  <li>마지막으로 24에서 25로 3번째 행에서 채워지게 된다.</li>
</ol>

<p>여기서 총 <strong>5번의 과정</strong>을 통해 1부터 25까지 달팽이 모양으로 2차원 배열을 채우게 되는데 이 5번이라는 것은 정사각형의 행, 열과 동일한 숫자임을 알 수 있다.</p>

<p>이 때, 5번 만큼 배열을 채울 때 일반적인 배열의 순서대로 <strong>오른쪽이나 아래로 채워지는 경우</strong>와, 배열의 순서와는 반대인 <strong>왼쪽이나 위로 채워지는 경우</strong>를 분기하여 채우도록 하면 된다. 그리고 채워질 수는 계속해서 증가시키며 행*열만큼의 수가 되도록 하면 된다.</p>

<h4 id="오른쪽이나-아래로-채워지는-경우">오른쪽이나 아래로 채워지는 경우</h4>
<p>위 <code class="language-plaintext highlighter-rouge">1번</code> 과정과 같이 원래 순서대로 자연스럽게 채워야 하는 경우를 살펴보자. <br />
먼저 열에 값을 오른쪽 방향으로 채운 뒤, 행에 값을 아래 방향으로 아래와 같이 채우게 된다.</p>

<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbwWAhk%2FbtqvbHD9Zlv%2FNPKqcYw2WgdMKhgFi3sVZk%2Fimg.png" width="30%" /></p>

<p>i가 행 인덱스, j가 열 인덱스라고 한다면 <strong>i는 0행으로 고정시키고, j만 1씩 증가</strong>시켜서 1~5까지 첫 행을 채워주어야 한다. <br />
그리고 첫 행 채우기가 끝나면 <strong>열 인덱스 j를 고정시키고, i만 1씩 증가</strong>하며 채워주어야 한다. <br />
단, 첫 열을 채울 때는 5-1번만큼 반복하여 6부터 9까지만 채우면 된다는 점을 유의해야 한다.</p>

<h4 id="왼쪽이나-위로-채워지는-경우">왼쪽이나 위로 채워지는 경우</h4>
<p>1번 과정대로 배열을 채웠다면 10부터 13까지, 14부터 16까지는 반대 방향으로 배열을 채워야 한다. <br />
이 때는 열 인덱스인 j를 1씩 감소시켜서 채워야 하기 때문에 <strong>방향을 반대로 바꿔줄 변수</strong>가 하나 있어야 한다.</p>

<p><br /></p>

<p>문제 예시처럼 가로 5, 세로 5 크기를 가지는 정사각형을 채우려면 위 과정을 5번 반복하여 달팽이 배열을 채울 수 있게 된다. <br />
아이디어가 생각보다 복잡해보이지만 필자가 장황하게 늘어놓은 점도 없지 않기에 코드를 작성하면서 이해하는 것이 더 쉬울 수 있다.</p>

<p>자 그럼 이제 코드를 작성해보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="kt">int</span><span class="o">[][]</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">col</span><span class="o">][</span><span class="n">row</span><span class="o">];</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">// row start index</span>
<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="c1">// col start index</span>
<span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// snail number</span>
<span class="kt">int</span> <span class="n">direction</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// i with j switch direction(1 or -1)</span>
<span class="kt">int</span> <span class="n">repeat</span> <span class="o">=</span> <span class="n">row</span><span class="o">;</span> <span class="c1">// repeat count</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>달팽이 모양대로 채워줄 2차원 배열 answr를 선언한다.
그리고 i는 행 인덱스, j는 열 인덱스를 의미하고 tmp는 각 배열에 채워줄 숫자 값이 된다.</p>

<blockquote>
  <p><em>j가 -1부터 시작하는 이유는, 행을 고정하고 열을 증가시키며 배열에 채워줄 때 배열의 범위를 벗어나지 않도록 하기 위함이다.</em></p>
</blockquote>

<p>direction 변수는 <strong>방향이 바뀔 시 사용될 스위치 변수</strong>이며, repeat는 몇 번을 반복해야 하는지를 알려주는 <code class="language-plaintext highlighter-rouge">반복 인덱스</code>라고 보면 된다.</p>

<blockquote>
  <p><em>여기서는 정사각형이기 때문에 행과 열의 크기가 같기에 둘 중 아무거나 repeat로 선언해도 무방하다.</em></p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="k">while</span><span class="o">(</span><span class="n">repeat</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>기본적으로 repeat가 0이 될 때까지 반복하면 된다. 문제 예시대로라면 5번을 반복하게 된다. <br />
while문에서 2차원 배열을 채우는 반복문을 작성해주면 되며, while문의 <strong>탈출 조건은 반복 인덱스인 repeat가 0과 작거나 같아지는 순간</strong>이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">l</span><span class="o">&lt;</span><span class="n">repeat</span><span class="o">;</span> <span class="n">l</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">tmp</span><span class="o">++;</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="n">direction</span><span class="o">;</span>
    <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
<span class="o">}</span>
<span class="n">repeat</span><span class="o">--;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>앞에서 구상한 아이디어대로 행 인덱스인 i를 고정해둔 채 j를 1씩 증가시키며 첫 행을 1부터 채워준다. <br />
이 때, 열을 고정시키고 행을 증가시켜야 하는데 행의 첫번째 값은 이전에 채워졌으므로, 채워진 값 이후로 배열을 채우기 위해 repeat 변수를 1 감소시킨다.</p>

<blockquote>
  <p>1부터 5까지 5번을 반복하며 첫 행에 채워진다.</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">m</span><span class="o">&lt;</span><span class="n">repeat</span><span class="o">;</span> <span class="n">m</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">tmp</span><span class="o">++;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">direction</span><span class="o">;</span>
    <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
    
<span class="o">}</span>
<span class="n">direction</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>다음으로는 행 인덱스만 변경하며 배열을 채워주어야 하기 때문에 j를 고정해둔 채 행 인덱스인 i를 1씩 증가시키며 열 값을 채워준다.</p>

<blockquote>
  <p>6부터 9까지 4번을 반복하며 마지막 열에 채워진다.</p>
</blockquote>

<p>이제 다시 배열의 행부터 값을 채워야 하는데 <strong>왼쪽이나 위 방향인 반대로 채워야 하기 때문에 열 인덱스인 j를 1씩 감소</strong>시켜야 한다.
그래서 선언해둔 스위치 변수인 <strong>direction을 -1로 바꾸어주면</strong> 된다.</p>

<p><br /></p>

<p>이렇게 while문 안에서 두가지의 반복 과정을 진행하며 repeat 반복 변수가 0 이하가 된다면 while문을 종료된다.</p>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">col</span><span class="o">][</span><span class="n">row</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// row start index</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="c1">// col start index</span>
        <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// snail number</span>
        <span class="kt">int</span> <span class="n">direction</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// i with j switch direction(1 or -1)</span>
        <span class="kt">int</span> <span class="n">repeat</span> <span class="o">=</span> <span class="n">row</span><span class="o">;</span> <span class="c1">// repeat count</span>

        <span class="k">while</span><span class="o">(</span><span class="n">repeat</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">l</span><span class="o">&lt;</span><span class="n">repeat</span><span class="o">;</span> <span class="n">l</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">tmp</span><span class="o">++;</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="n">direction</span><span class="o">;</span>
                <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">repeat</span><span class="o">--;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">m</span><span class="o">&lt;</span><span class="n">repeat</span><span class="o">;</span> <span class="n">m</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">tmp</span><span class="o">++;</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">direction</span><span class="o">;</span>
                <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
                
            <span class="o">}</span>
            <span class="n">direction</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">:</span> <span class="n">answer</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">arr</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="n">col</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<ul>
  <li>행과 열을 탐색하는 순서를 전환하기 위해 양수와 음수를 이용할 수 있었고, 열을 고정시키고 행을 1씩 증가시켜서 열 값을 채워주고 행을 고정시키고 열 값을 1씩 증가시켜서 행 값을 채워줄 수 있었다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[2차원 배열 응용 - 달팽이 만들기]]></summary></entry><entry><title type="html">[Java] LeetCode(Easy) - 819. Most Common Word</title><link href="http://localhost:4000/java/151-post/" rel="alternate" type="text/html" title="[Java] LeetCode(Easy) - 819. Most Common Word" /><published>2023-03-06T00:00:00+09:00</published><updated>2023-03-06T00:00:00+09:00</updated><id>http://localhost:4000/java/151-post</id><content type="html" xml:base="http://localhost:4000/java/151-post/"><![CDATA[<p><br /></p>
<center><img src="/assets/images/leetcode/819_01.png" width="100%" /></center>
<center><img src="/assets/images/leetcode/819_02.png" width="100%" /></center>
<p><br /></p>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />
<p>이번 819번 문제는 <code class="language-plaintext highlighter-rouge">Most Common Word</code>, 즉 가장 흔한 단어를 찾는 문제이다. <br />
문제 풀이의 핵심은 <strong>정규식 및 Map</strong>을 활용하는 것이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>
<p>문제 그대로 주어진 문자열을 토대로 빈도수가 많은 단어를 반환하면 되는데, 먼저 문제에서 요구하는 <strong>특정 문자열을 필터링</strong>하여 단어 배열을 만드는 것이 중요하다. <br /></p>

<ul>
  <li>단어별로 빈도수를 담기 위해 Map을 사용한다.</li>
  <li>주어진 단어의 빈도수를 세기 위해서 문자열을 소문자로 변환한다.</li>
  <li>문자열에서 주어진 단락을 기준으로 단어 배열을 만든다.
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">!</code>, <code class="language-plaintext highlighter-rouge">?</code>, <code class="language-plaintext highlighter-rouge">'</code>, <code class="language-plaintext highlighter-rouge">,</code>, <code class="language-plaintext highlighter-rouge">;</code>, <code class="language-plaintext highlighter-rouge">.</code>라는 문자들과 공백 문자인 ` ` 까지</strong> 포함시켜 잘라야 한다.</li>
    </ul>
  </li>
  <li>단어 배열을 만들었다면, 해당 단어 배열을 순회하면서 단어들의 빈도수를 세어 Map에 담는다.
    <ul>
      <li>이 때, <strong>banned 배열에 포함된 단어라면 카운트를 세지 않도록</strong> 한다.</li>
    </ul>
  </li>
  <li>단어들의 빈도수를 담은 Map에서 가장 많은 빈도수를 가진 단어를 찾으면 된다.</li>
</ul>

<p><br /></p>

<p>이제 아이디어를 토대로 코드를 작성해보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="nc">String</span><span class="o">[]</span> <span class="n">words</span> <span class="o">=</span> <span class="n">paragraph</span><span class="o">.</span><span class="na">toLowerCase</span><span class="o">().</span><span class="na">split</span><span class="o">(</span><span class="s">"[!?,;'\\.\\s]+"</span><span class="o">);</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
<span class="nc">String</span> <span class="n">answer</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>먼저 주어진 paragraph 문자열을 소문자로 변환하고 공백 문자 및 문제에서 요구하는 문자를 기준으로 단어를 구분하기 위해 정규식을 활용하였다. <br /></p>

<h4 id="단락-필터링을-위한-정규식">단락 필터링을 위한 정규식</h4>
<p>문제에서 요구하는 <code class="language-plaintext highlighter-rouge">!</code>, <code class="language-plaintext highlighter-rouge">?</code>, <code class="language-plaintext highlighter-rouge">'</code>, <code class="language-plaintext highlighter-rouge">,</code>, <code class="language-plaintext highlighter-rouge">;</code>, <code class="language-plaintext highlighter-rouge">.</code>라는 문자들과 공백 문자인 ` ` 문자를 기준으로 자르기 위해서는 어떻게 해야할까? <br />
바로 정규식을 이용하여 손쉽게 해당 문자를 기준으로 문자열을 구분할 수 있도록 할 수 있다.</p>

<p>사용한 정규식을 살펴보면 <code class="language-plaintext highlighter-rouge">String[] words = paragraph.toLowerCase().split("[!?,;'\\.\\s]+");</code> 과 같다.
이 떄 <code class="language-plaintext highlighter-rouge">.</code>과 ` ` 공백문자에 정규식 안에 \를 사용하여 .와 \s를 이스케이프(escape) 처리해 주었다.</p>

<p>이 정규식은 <code class="language-plaintext highlighter-rouge">!</code>, <code class="language-plaintext highlighter-rouge">?</code>, <code class="language-plaintext highlighter-rouge">'</code>, <code class="language-plaintext highlighter-rouge">,</code>, <code class="language-plaintext highlighter-rouge">;</code>, <code class="language-plaintext highlighter-rouge">.</code> 문자와 공백문자 ` `를 구분자로 사용한다는 것을 의미한다. <br /></p>

<blockquote>
  <p><em>여기서 <strong>[]는 문자 클래스</strong>를 나타내며, 안에 들어가는 문자들 중 <strong>하나라도 매치되면 분리 기준으로 사용</strong>하겠다는 뜻이다. 또한 <strong>+는 해당 문자들이 하나 이상 연속으로 나타날 때 매치되는 것을 의미</strong>한다.</em></p>
</blockquote>

<p>아무튼, 위와 같이 정규식을 활용하여 특정 단락에 속하는 문자를 기준으로 구분하여 split 메소드를 이용해 문자로 잘라서 배열로 만들 수 있었다. <br />
다음으로 문자를 key로 문자들의 빈도수를 value로 담을 count HashMap을 하나 생성하고 가장 많은 빈도수를 보인 단어를 반환할 String 변수 answer를 null로 초기화한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span> <span class="o">:</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Boolean</span> <span class="n">possiable</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="n">ban</span> <span class="o">:</span> <span class="n">banned</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">word</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">ban</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">possiable</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">if</span><span class="o">(</span><span class="n">possiable</span><span class="o">)</span> <span class="n">count</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">count</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>이제 구분해낸 소문자 단어들을 순회하며 빈도수를 세도록 하자. <br />
이 때, 해당 단어가 금지어라면 카운트를 할 필요가 없다. 그렇기에 <strong>Boolean 변수를 하나 두어서 이중 for문으로 해당 단어가 금지어인지를 확인</strong>하면 된다.</p>

<p>만약 금지어라면 카운트를 셀 필요가 없기 때문에 <code class="language-plaintext highlighter-rouge">break;</code>로 이중 for문을 탈출하면 된다. 그리고 Boolean 변수가 false이기 때문에 count HashMap에 넣지 않는다. <br />
만약 금지어가 아니라면 카운트를 세야 하기 때문에 count HashMap에 해당 단어 문자를 key 값으로, 빈도수를 <strong>getOrDefault로</strong> 찾아와서 value 값으로 삽입한다.</p>

<p>그러면 구분해낸 단어들의 빈도수가 count HashMap에 온전히 담길 것이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span> <span class="o">:</span> <span class="n">count</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">answer</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">answer</span><span class="o">))</span> <span class="n">answer</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>마지막으로 count를 가지고 가장 많은 빈도수를 보인 단어를 찾으면 된다. <br />
가장 많은 value를 가진 key값을 구하면 되기 때문에 count를 순회하면서 answer에 최대 value를 가지는 값을 담으면 된다.</p>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">mostCommonWord</span><span class="o">(</span><span class="nc">String</span> <span class="n">paragraph</span><span class="o">,</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">banned</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">words</span> <span class="o">=</span> <span class="n">paragraph</span><span class="o">.</span><span class="na">toLowerCase</span><span class="o">().</span><span class="na">split</span><span class="o">(</span><span class="s">"[!?,;'\\.\\s]+"</span><span class="o">);</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="nc">String</span> <span class="n">answer</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="n">w</span> <span class="o">:</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">word</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">"\\W"</span><span class="o">,</span> <span class="s">""</span><span class="o">);</span>
            <span class="nc">Boolean</span> <span class="n">possiable</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="n">ban</span> <span class="o">:</span> <span class="n">banned</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">word</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">ban</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">possiable</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">possiable</span><span class="o">)</span> <span class="n">count</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">count</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span> <span class="o">:</span> <span class="n">count</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">answer</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">answer</span><span class="o">))</span> <span class="n">answer</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">answer</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<ul>
  <li>정규식을 이용하여 문자열을 원하는 패턴으로 구분할 수 있었다. 앞으로 문자열 치환이 필요할 경우 항상 정규식을 이용할 수 있는지 확인해보자.</li>
</ul>

<h3 id="출처">출처</h3>
<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://leetcode.com/problems/most-common-word/">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[Easy - 819. Most Common Word]]></summary></entry><entry><title type="html">[Java] 프로그래머스(level-2) - 주식 가격</title><link href="http://localhost:4000/java/150-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-2) - 주식 가격" /><published>2023-03-05T00:00:00+09:00</published><updated>2023-03-05T00:00:00+09:00</updated><id>http://localhost:4000/java/150-post</id><content type="html" xml:base="http://localhost:4000/java/150-post/"><![CDATA[<p><br /></p>
<center><img src="/assets/images/programmers/20230305_01.png" width="100%" /></center>
<p><br /></p>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />
<p>이번 <code class="language-plaintext highlighter-rouge">주식 가격</code> 문제는 필자의 가독성이 부족한 것인지, 도저히 지문 자체가 이해가 안되어 지문을 이해하는 것이 더 어려웠다. <br />
이 때, 다른 분의 지문 해석 글이 지문을 이해하는데 큰 도움이 되었기 때문에 해당 <a href="https://school.programmers.co.kr/questions/20326?question=20326">링크</a>를 공유한다.</p>

<p>해당 글에서는 아래와 같이 지문을 이해하기 쉽게 알려주었다.</p>

<p><br /></p>

<p><strong>문제설명</strong> <br />
n초 간의 주가를 초 단위로 기록한 배열 prices가 매개변수로 주어질 때, 각 초의 주가를 기준으로 해당 초 부터 n초 사이에 가격이 떨어지지 않은 시간은 몇 초인지 배열에 담아 return 하도록 solution 함수를 완성하세요.</p>

<p><strong>제한사항</strong> <br />
prices의 각 가격은 1 이상 10,000 이하인 자연수입니다. <br />
prices의 길이 n은 2 이상 100,000 이하입니다. (2 &lt;= n &lt;= 100,000)</p>

<p><strong>입출력 예</strong> <br /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>prices : [1, 2, 3, 2, 3]
return : [4, 3, 1, 1, 0]
</pre></td></tr></tbody></table></code></pre></div></div>

<p><strong>입출력 예 설명</strong> <br /></p>
<ul>
  <li>1초의 주가는 1이며 1초부터 5초까지 총 4초간 주가를 유지했습니다.</li>
  <li>2초의 주가는 2이며 2초부터 5초까지 총 3초간 주가를 유지했습니다.</li>
  <li>3초의 주가는 3이며 4초의 주가는 2로 주가가 떨어졌지만 3초에서 4초가 되기 직전까지의 1초간 주가가 유지 된것으로 봅니다. 따라서 5초까지 총 1초간 주가를 유지했습니다.</li>
  <li>4초의 주가는 2이며 4초부터 5초까지 총 1초간 주가를 유지했습니다.</li>
  <li>5초의 주가는 3이며 5초 이후로는 데이터가 없으므로 총 0초간 주가를 유지했습니다.</li>
</ul>

<p><br /></p>

<h4 id="문제에-활용할-자료구조">문제에 활용할 자료구조</h4>
<p>위에서 살펴본 지문을 통해 이해한 후에는 새로운 의문점이 생겼다. 바로 해당 문제의 유형이 <code class="language-plaintext highlighter-rouge">스택/큐</code> 문제로 지정되어 있었다는 것이다.<br />
굳이 큐를 활용해서 peek한 원소와 나머지 원소를 비교해가며 할 수는 있겠지만 필자는 그냥 단순하게 배열을 활용하는 것이 좋을 것 같아 배열을 활용하여 풀었다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>
<p>지문을 잘 이해했다면 문제의 솔루션을 찾는 건 생각보다 쉽다.</p>

<ul>
  <li>주어진 prices의 길이를 통해 1초부터 N초까지 각 원소의 정수값을 유지하고 있는지를 줌점으로 보면 된다.</li>
  <li>prices의 원소를 순회하며 중첩 for문을 통해 <strong>해당 원소와 다음 원소와의 증감 여부를 비교</strong>하면 된다.
    <ul>
      <li>이 때, <strong>현재 원소가 다음 원소보다 작으면 주식 가격이 올라가는 중</strong>이기 때문에 또 다음 원소와 비교할 수 있도록 1초씩 증가시키고 다음 순회로 넘기면 된다.</li>
      <li>만약 현재 원소가 다음 원소보다 크다면, 즉 주식 가격이 하락했다면 <strong>하락되기 직전까지의 1초간은 주가가 유지된 것</strong>으로 보기 때문에 1초를 포함한 후 해당 순회를 멈춘다.</li>
    </ul>
  </li>
  <li>위 과정을 반복하며 prices의 각 원소마다 중첩 for문을 통해 구한 주식가격 유지시간 값을 반환할 배열에 담으면 된다.</li>
</ul>

<p><br /></p>

<p>생각해낸 아이디어는 복잡할 수 있지만, 앞서 말했듯이 지문을 잘 이해했다면 간단할 수 있다. <br />
그럼 바로 코드를 작성해보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kt">int</span><span class="o">[]</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>먼저 prices의 길이만큼 그대로 반환할 것이니 answer 배열을 prices의 길이와 동일하게 선언하자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">term</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">prices</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="n">term</span><span class="o">++;</span>
        <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">prices</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">term</span><span class="o">++;</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">term</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>주어진 prices를 통해 1초부터 [prices.length]초까지 가격이 떨어지지 않은 시간은 몇 초인지를 구하기 위한 로직은 다음과 같다.</p>

<ol>
  <li>중첩 for문을 통해 prices의 해당 원소와 다음 원소들을 순회하며 비교한다.</li>
  <li>이 때, 각 원소마다 몇 초만큼인지를 구할 term 변수를 선언한다.</li>
  <li>현재 원소(가격)가 다음 원소보다 작으면 주가가 상승하고 있다는 것이기에 term을 1 증가시키고 다음 원소를 순회하도록 한다.</li>
  <li>만약, 현재 원소(가격)가 다음 원소보다 크다면 주가가 하락했다는 것이기에 term을 1 증가시킨 후, <strong>현재 순회에서 멈추고 1초 뒤의 주가를 비교하도록</strong> 한다.</li>
  <li>그 밖의 상황일 경우 쓸데없이 이중 for문을 순회할 필요가 없기 때문에 순회를 종료시킨다.</li>
</ol>

<blockquote>
  <p><em>중첩 for문에서 j를 <code class="language-plaintext highlighter-rouge">i+1</code>부터 순회하도록 구현한 이유는 <strong>같은 원소끼리는 비교할 필요가 없기 때문</strong>이다.</em></p>
</blockquote>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">)</span> <span class="o">{</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">term</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">prices</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="n">term</span><span class="o">++;</span>
                <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">prices</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
                    <span class="n">term</span><span class="o">++;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">else</span> <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">term</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">};</span>
        <span class="c1">// int[] prices = new int[]{5,4,3,2,5};</span>
        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">prices</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<ul>
  <li>중첩 for문 내에서 특정 조건에서는 순회를 이어가고, 특정 조건에서는 순회를 멈추도록 하는 로직을 통해 스택이나 큐를 활용하지 않고도 해당 문제를 풀 수 있었다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 2 - 주식 가격]]></summary></entry></feed>