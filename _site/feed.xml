<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-07-07T17:29:27+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">lango’s DevLog</title><subtitle>developer</subtitle><author><name>lango</name></author><entry><title type="html">[Java] 프로그래머스(level-2) - 땅따먹기</title><link href="http://localhost:4000/java/211-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-2) - 땅따먹기" /><published>2023-07-07T00:00:00+09:00</published><updated>2023-07-07T00:00:00+09:00</updated><id>http://localhost:4000/java/211-post</id><content type="html" xml:base="http://localhost:4000/java/211-post/"><![CDATA[<p><br /></p>

<center><img src="/assets/images/programmers/" width="100%" /></center>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />

<p>이 문제는 <strong>동적 계획법, DP</strong> 를 이용한 방법으로 적은 수의 라인으로 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="그리디-완전탐색">그리디? 완전탐색?</h4>

<p>사실, 문제를 보고 그리디 알고리즘이나 완전탐색으로 접근하려 했으나 두 가지 모두 문제 통과는 어렵다고 판단하였다.</p>

<p>그리디 알고리즘을 적용할 경우 최선의 값을 선택하기에 좋은 솔루션으로 생각할 수도 있겠지만, 문제에서 주어지는 행에서의 최대값을 선택한다고 마지막 행까지의 덧셈을 통해 최댓값이 구해지는 것은 아니다. 아래 예시를 보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span>
<span class="o">[</span><span class="mi">9</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">6</span><span class="o">]</span>
<span class="o">[</span><span class="mi">10</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">]</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>위 배열을 보면 4 -&gt; 9 -&gt; 4 로 최대값을 선택하면서 내려왔다면 값은 17이다.
다만, 4 -&gt; 7-&gt; 10 이나 3 -&gt; 8 -&gt; 10을 선택하면서 내려왔다면 21이라는 최대값을 만들 수 있다.</p>

<blockquote>
  <p>여기서 알 수 있는 점은 <strong>매 행에서 최대값을 선택하는 그리디 알고리즘을 적용하는 것은 적절하지 않다</strong>는 것이다!</p>
</blockquote>

<p>또한 <strong>N의 범위는 최대 100,000이기에 완전 탐색을 이용하기엔 시간초과</strong>가 걸린다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>그렇다면 행마다 한번씩 내려가면서, 최고의 합을 기록하며 내려간다면 어떻게 될까? 위에서 살펴 본 배열을 한 번더 예시로 들어보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span>
<span class="o">[</span><span class="mi">9</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">6</span><span class="o">]</span>
<span class="o">[</span><span class="mi">10</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">]</span>

<span class="c1">// 두번째 행을 최고의 합으로 갱신</span>
<span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span>
<span class="o">[</span><span class="mi">13</span><span class="o">(</span><span class="mi">9</span><span class="o">+</span><span class="mi">4</span><span class="o">),</span> <span class="mi">11</span><span class="o">(</span><span class="mi">8</span><span class="o">+</span><span class="mi">3</span><span class="o">),</span> <span class="mi">11</span><span class="o">(</span><span class="mi">7</span><span class="o">+</span><span class="mi">4</span><span class="o">),</span> <span class="mi">10</span><span class="o">(</span><span class="mi">6</span><span class="o">+</span><span class="mi">4</span><span class="o">)]</span>
<span class="o">[</span><span class="mi">10</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">]</span>

<span class="c1">// 마지막 행을 최고의 합으로 갱신</span>
<span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span>
<span class="o">[</span><span class="mi">13</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">11</span><span class="o">,</span> <span class="mi">10</span><span class="o">]</span>
<span class="o">[</span><span class="mi">21</span><span class="o">(</span><span class="mi">10</span><span class="o">+</span><span class="mi">11</span><span class="o">),</span> <span class="mi">17</span><span class="o">(</span><span class="mi">4</span><span class="o">+</span><span class="mi">13</span><span class="o">),</span> <span class="mi">15</span><span class="o">(</span><span class="mi">2</span><span class="o">+</span><span class="mi">13</span><span class="o">),</span> <span class="mi">14</span><span class="o">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">13</span><span class="o">)]</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>위와 같이 내려오면서 land 배열의 각 자리마다 이전 행의 최대값을 더해주면서 내려온다면 마지막 행에서 21이라는 최대값을 반환하기만 된다는 것을 알 수 있다.</p>

<p>결국, 위와 같은 방법으로 <strong>배열의 각 자리를 갱신하면서 마지막 행에서 가장 큰 값을 가진 값을 반환</strong>하면 된다!</p>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre></td><td class="rouge-code"><pre>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">land</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">land</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

        <span class="cm">/**
         * 행을 한번씩 내려가면서, 내려올때의 최고의 합을 land에 기록해나간다.
         * 
         * 배열의 2번째 행부터 현재 칸과 이전 행의 최댓값을 더한 값으로 갱신해나간다.
         * 이때, 이전에 최댓값이 된 칸의 경우 같은 칸을 더하지 않도록 한다.
         */</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">+=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">],</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">2</span><span class="o">],</span> <span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">3</span><span class="o">]));</span>
            <span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">+=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">2</span><span class="o">],</span> <span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">3</span><span class="o">]));</span>
            <span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">2</span><span class="o">]</span> <span class="o">+=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">],</span> <span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">3</span><span class="o">]));</span>
            <span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">3</span><span class="o">]</span> <span class="o">+=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">],</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">1</span><span class="o">],</span> <span class="n">land</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="mi">2</span><span class="o">]));</span>
        <span class="o">}</span>

        <span class="c1">// 마지막 행 중 최대값을 구하여 반환한다.</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">land</span><span class="o">[</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">answer</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">answer</span><span class="o">,</span> <span class="n">num</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>

        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        
        <span class="c1">// int[][] land = new int[][]{{1,2,3,5},</span>
        <span class="c1">//                         {5,6,7,8},</span>
        <span class="c1">//                         {4,3,2,1}};</span>

        <span class="c1">// int[][] land = new int[][]{{1,1,1,1},</span>
        <span class="c1">//                             {2,2,2,3},</span>
        <span class="c1">//                             {3,3,3,6},</span>
        <span class="c1">//                             {4,4,4,7}};</span>

        <span class="kt">int</span><span class="o">[][]</span> <span class="n">land</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[][]{{</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">},</span>
                                    <span class="o">{</span><span class="mi">9</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">7</span><span class="o">,</span><span class="mi">6</span><span class="o">},</span>
                                    <span class="o">{</span><span class="mi">10</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">}};</span>

        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">land</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<ul>
  <li>
    <hr />
  </li>
</ul>

<p><br /></p>

<h3 id="출처">출처</h3>
<p>-
—</p>

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://school.programmers.co.kr/learn/courses/30/lessons/12913">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 2 - 땅따먹기]]></summary></entry><entry><title type="html">[Java] 백준(골드-5) 15686번 - 치킨 배달</title><link href="http://localhost:4000/java/212-post/" rel="alternate" type="text/html" title="[Java] 백준(골드-5) 15686번 - 치킨 배달" /><published>2023-07-07T00:00:00+09:00</published><updated>2023-07-07T00:00:00+09:00</updated><id>http://localhost:4000/java/212-post</id><content type="html" xml:base="http://localhost:4000/java/212-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 <strong>DFS를 통한 백트래킹</strong>을 이용해 풀 수 있다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>문제 풀이를 위해 생각한 아이디어는 다음과 같다.</p>

<ol>
  <li>집과 치킨집의 위치를 미리 저장한다.</li>
  <li>M개만큼 뽑은 치킨집은 방문 여부를 체크하여 도시의 치킨 거리를 구할 때 사용한다.</li>
  <li>M개의 치킨집을 모두 뽑았다면, 모든 집의 위치에서 최소거리에 있는 치킨집과의 거리을 구한다.</li>
  <li>그렇게 모든 치킨집과의 최소거리를 계산한다면, 모든 도시의 치킨거리 중 최솟값을 구하면 된다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
</pre></td><td class="rouge-code"><pre><span class="kn">package</span> <span class="nn">java_study</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// 방문배열과 입력배열</span>
    <span class="kd">static</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">map</span><span class="o">;</span>
    
    <span class="c1">// 집과 치킨집 좌표를 저장할 List</span>
    <span class="kd">static</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">house</span><span class="o">;</span>
    <span class="kd">static</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">chicken</span><span class="o">;</span>
    
    <span class="c1">// 입력배열의 크기인 N과 깊이 M</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="no">N</span><span class="o">,</span> <span class="no">M</span><span class="o">;</span>

    <span class="c1">// 도시의 치킨거리 최솟값을 저장할 변수</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">result</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
        
        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

        <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">N</span><span class="o">];</span> 
        <span class="n">house</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">chicken</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>


        <span class="cm">/**
         * 위치들을 입력받으며 house, chicken List 초기화
         */</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                
                <span class="c1">// 집의 위치와 치킨집의 위치를 저장</span>
                <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">house</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">});</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">chicken</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">});</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 치킨집 크기만큼 방문 배열을 초기화</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">chicken</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>  
        
        <span class="c1">// 최솟값을 구해야 하므로 result를 Integer.MAX_VALUE 값으로 초기화</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

        <span class="c1">// DFS 재귀함수 호출</span>
        <span class="n">recursion</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 백트래킹을 진행할 DFS 재귀함수
     * depth(깊이)가 M과 같아지면 선택한 치킨집과 집과의 치킨 거리를 구한다.
     * 치킨거리 중 최솟값을 누적시키며, 모든 도시의 치킨 거리 중 최솟값을 구한다.
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">recursion</span><span class="o">(</span><span class="kt">int</span> <span class="n">depth</span><span class="o">,</span> <span class="kt">int</span> <span class="n">at</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="k">if</span><span class="o">(</span><span class="n">depth</span> <span class="o">==</span> <span class="no">M</span><span class="o">)</span> <span class="o">{</span>            
            
            <span class="c1">// 도시의 치킨거리</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">house</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

                <span class="c1">// 집과 치킨 집 중 방문한 치킨집의 모든 거리를 비교하며 최소거리를 구한다.</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">chicken</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
                        <span class="c1">// 해당 집의 치킨 거리 |r1-c1|+|r2-c2|</span>
                        <span class="kt">int</span> <span class="n">distance</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">house</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)[</span><span class="mi">0</span><span class="o">]</span> <span class="o">-</span> <span class="n">chicken</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">)[</span><span class="mi">0</span><span class="o">])</span>
                                    <span class="o">+</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">house</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">chicken</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">j</span><span class="o">)[</span><span class="mi">1</span><span class="o">]);</span>
                        <span class="n">min</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">min</span><span class="o">,</span> <span class="n">distance</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">min</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="n">result</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">sum</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>

        <span class="o">}</span>

        <span class="c1">// 백트래킹 탐색 진행</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">at</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">chicken</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="c1">// 방문 여부를 통해 가지치기</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="n">recursion</span><span class="o">(</span><span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
                <span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>

        <span class="o">}</span>
        
    <span class="o">}</span>    

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/15686">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[15686번 - 치킨 배달]]></summary></entry><entry><title type="html">[Java] 백준(골드-4) 2110번 - 공유기 설치</title><link href="http://localhost:4000/java/210-post/" rel="alternate" type="text/html" title="[Java] 백준(골드-4) 2110번 - 공유기 설치" /><published>2023-07-06T00:00:00+09:00</published><updated>2023-07-06T00:00:00+09:00</updated><id>http://localhost:4000/java/210-post</id><content type="html" xml:base="http://localhost:4000/java/210-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 <strong>이분 탐색</strong>를 잘 응용한다면 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>이분 탐색 구현도 구현이지만, N개의 집 좌표들에서 C개의 공유기를 설치하는데 최대한 설치되는 집의 거리를 벌려야 한다.</p>

<blockquote>
  <p>이 때, 중요한 점은 <strong>설치된 집과 설치될 집간의 최소거리</strong>를 잘 고려해야 한다.</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>1(집) 2 3 4 5(집) 6 7 8(집) 9 10 ...
</pre></td></tr></tbody></table></code></pre></div></div>

<p>위와 같이 <code class="language-plaintext highlighter-rouge">1, 5, 8</code> 위치에 집이 있을 경우 공유기를 1 위치인 집에 먼저 설치했다고 가정하자.</p>

<ul>
  <li>두번 째 집의 위치는 5로 첫번째 집과 4만큼 거리가 떨어져 있다.</li>
  <li>세번 째 집의 위치는 8로 두번째 집과 3만큼 거리가 떨어져 있다.</li>
</ul>

<p>이를 보면 왜 최소거리가 이 문제에서 중요한지 알 수 있을 것이다. 바로 <strong>직전에 공유기가 설치되었던 집과의 거리를 비교하며 최소 거리보다 먼 위치에 있는 집에 공유기를 설치</strong>해야 문제에서 요구하는 집 간의 거리를 벌릴 수 있게 되는 것이다.</p>

<blockquote>
  <p><strong>직전에 공유기를 설치한(가장 최근에 설치한) 집과 현재 집과의 거리를 기준</strong>으로 판단해야 한다.</p>
</blockquote>

<p>결국, 첫번째 집부터 공유기를 설치한 후, 첫번째 집부터 두번째 집에서 구해진 최초의 최소 거리를 기준으로 나머지 집들을 비교해가며 <strong>설치 해야할 공유기 대수(C)</strong>만큼 설치해나가면 되는 것이다.</p>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
        
        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="kt">int</span> <span class="no">C</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

        <span class="c1">// 집들의 위치를 담을 배열</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="o">}</span>
        
        <span class="c1">// 이분 탐색을 하기 위해 사전 정렬</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">arr</span><span class="o">);</span>

        <span class="c1">// 최소거리가 가지는 최소값</span>
        <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="c1">// 최소거리가 가지는 최대값</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="no">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// Upper Bound 형식으로 이분탐색 진행</span>
        <span class="k">while</span><span class="o">(</span><span class="n">min</span> <span class="o">&lt;</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>

            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">min</span> <span class="o">+</span> <span class="n">max</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

            <span class="cm">/**
             * mid 거리에 대해서 설치 가능한 공유기 대수가 C개 미만일 경우
             * 거리를 좁혀야 하기 때문에 max를 mid로 갱신하여 줄인다.
             * 
             * 반대로, 설치 가능한 공유기 대수가 C개 초과일 경우
             * 거리를 벌리면서 최소거리가 가질 수 있는 최대거리를 찾아야 하기 때문에 min을 mid+1 값으로 늘린다.
             */</span>
            <span class="k">if</span><span class="o">(</span><span class="n">ableInstall</span><span class="o">(</span><span class="n">mid</span><span class="o">)</span> <span class="o">&lt;</span> <span class="no">C</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">max</span> <span class="o">=</span> <span class="n">mid</span><span class="o">;</span>
            <span class="o">}</span> 
            <span class="k">else</span> <span class="o">{</span>
                <span class="n">min</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>

        <span class="o">}</span>
        
        <span class="c1">// Upper Bound를 통해 탐색 값을 초과하기에 1을 뺀다.</span>
        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">((</span><span class="n">min</span><span class="o">-</span><span class="mi">1</span><span class="o">)+</span><span class="s">"\n"</span><span class="o">);</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">int</span> <span class="nf">ableInstall</span><span class="o">(</span><span class="kt">int</span> <span class="n">distance</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// 첫번째 집은 무조건 설치하는 것을 가정한다.</span>
        <span class="kt">int</span> <span class="n">installCnt</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="c1">// 직전에 설치한 집의 위치(최초는 첫번째 집)</span>
        <span class="kt">int</span> <span class="n">lastPos</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">arr</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>

            <span class="c1">// 현재 탐색하는 집의 위치</span>
            <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>

            <span class="cm">/**
             * 현재 탐색하는 집의 위치가 직전에 설치한 집의 위치와의 거리가 최소거리(distance)보다 크거나 같을 경우
             * 1. 현재 집에 공유기를 설치할 수 있으므로 installCnt를 1 늘려준다.
             * 2. 직전에 설치한 집의 위치인 lastPos를 갱신한다.
             */</span>
            <span class="k">if</span><span class="o">(</span><span class="n">pos</span> <span class="o">-</span> <span class="n">lastPos</span> <span class="o">&gt;=</span> <span class="n">distance</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">installCnt</span><span class="o">++;</span>
                <span class="n">lastPos</span> <span class="o">=</span> <span class="n">pos</span><span class="o">;</span>
            <span class="o">}</span>
            
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">installCnt</span><span class="o">;</span>

    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/2110">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[2110번 - 공유기 설치]]></summary></entry><entry><title type="html">[Java] 백준(브론즈-2) 5585번 - 거스름돈</title><link href="http://localhost:4000/java/208-post/" rel="alternate" type="text/html" title="[Java] 백준(브론즈-2) 5585번 - 거스름돈" /><published>2023-07-04T00:00:00+09:00</published><updated>2023-07-04T00:00:00+09:00</updated><id>http://localhost:4000/java/208-post</id><content type="html" xml:base="http://localhost:4000/java/208-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이 문제는 <strong>그리디 알고리즘</strong>를 이용해 푸는 대표적인 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>이 문제를 풀 수 있는 솔루션은 다음과 같다.</p>

<ol>
  <li>500, 100, 50, 10, 5, 1엔으로 이루어진 동전 목록을 선언한다.</li>
  <li>타로가 지불할 돈인 입력 값을 1000에서 뺄셈하여 반환할 거스름돈을 구한다.</li>
  <li>500엔부터 1엔까지 순서대로 동전 목록을 순회하며 해당 동전으로 거스름돈을 나눈 몫이 동전 개수가 된다.</li>
  <li>동전 개수를 구할 때마다 거스름돈을 빼주고, 총 동전개수에 더해준다.</li>
</ol>

<blockquote>
  <p>500엔부터 1엔까지 내림차순으로 순회하는 이유는 <strong>거스름돈 동전 개수를 최소화</strong>하기 위함이다.</p>
</blockquote>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
        
        <span class="c1">// 거스름돈으로 반환할 500, 100, 50, 10, 5, 1엔 동전 목록</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">coinList</span><span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="n">coinList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">500</span><span class="o">);</span>
        <span class="n">coinList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
        <span class="n">coinList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">50</span><span class="o">);</span>
        <span class="n">coinList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
        <span class="n">coinList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
        <span class="n">coinList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>

        <span class="c1">// 입력한 가격을 1000원에서 뺄셈하여 거스름돈 준비</span>
        <span class="kt">int</span> <span class="n">price</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">-</span><span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        
        <span class="c1">// 거스름돈으로 반환할 모든 동전의 개수</span>
        <span class="kt">int</span> <span class="n">totalCoinCnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="cm">/**
         * 동전 목록을 순회하며 거스름돈으로 줄 동전의 개수를 구한다.
         */</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">coinList</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">coinCnt</span> <span class="o">=</span> <span class="n">price</span> <span class="o">/</span> <span class="n">coinList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">price</span> <span class="o">-=</span> <span class="n">coinCnt</span> <span class="o">*</span> <span class="n">coinList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
            <span class="n">totalCoinCnt</span> <span class="o">+=</span> <span class="n">coinCnt</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">totalCoinCnt</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/5585">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[5585번 - 거스름돈]]></summary></entry><entry><title type="html">[Java] 백준(실버-3) 9095번 - 1,2,3 더하기</title><link href="http://localhost:4000/java/207-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-3) 9095번 - 1,2,3 더하기" /><published>2023-07-04T00:00:00+09:00</published><updated>2023-07-04T00:00:00+09:00</updated><id>http://localhost:4000/java/207-post</id><content type="html" xml:base="http://localhost:4000/java/207-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이 문제는 <strong>DP</strong>를 활용해 점화식을 세워서 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>이 문제에서는 1, 2, 3의 합을 이용해 N을 구하는 경우의 수를 구해야 하기 때문에, 먼저 1, 2, 3을 만들 수 있는 경우의 수를 구해야 한다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>1 = {1} =&gt; 1개
2 = {1+1, 2} =&gt; 2개
3 = {1+1+1, 1+2, 2+1, 3} =&gt; 4개
4 = ?
</pre></td></tr></tbody></table></code></pre></div></div>
<p>위와 같이 1,2,3일 때의 경우의 수는 1개, 2개, 4개인 것을 알 수 있다. 그러면 <code class="language-plaintext highlighter-rouge">N=4</code>일 경우는 어떻게 구할까?</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>4 = (1+3) + (2+2) + (3+1)
</pre></td></tr></tbody></table></code></pre></div></div>

<p>잘 살펴보면 위처럼 1, 2, 3의 각 경우의 수에 <code class="language-plaintext highlighter-rouge">+1</code>, <code class="language-plaintext highlighter-rouge">+2</code>, <code class="language-plaintext highlighter-rouge">+3</code>을 해주면 4일 때의 경우의 수를 구할 수 있다. 결국 1, 2, 3일 때의 경우의 수는 알고 있기 때문에 이를 이용하여 N이 4일 때나 5일 때의 경우의 수를 구할 수 있게 된다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>5 = (1+4) + (2+3) + (3+2)
</pre></td></tr></tbody></table></code></pre></div></div>

<p>하나의 예를 추가로 들어 <code class="language-plaintext highlighter-rouge">N=5</code>일 경우도 1, 2, 3의 경우의 수에 <code class="language-plaintext highlighter-rouge">+4</code>, <code class="language-plaintext highlighter-rouge">+3</code>, <code class="language-plaintext highlighter-rouge">+2</code>를 해주면 구할 수 있는 것으로 보아 이제는 점화식을 구할 수 있다.</p>

<blockquote>
  <p>점화식 <br />
<code class="language-plaintext highlighter-rouge">D[n] = D[n-3] + D[n-2] + D[n-1]</code></p>
</blockquote>

<p>마지막으로, 이 점화식을 이용해 N일 때마다의 경우의 수를 테스트케이스마다 출력하면 된다.</p>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="no">D</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">11</span><span class="o">];</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
        
        <span class="kt">int</span> <span class="no">T</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="c1">// 1,2,3일 때, 경우의 수를 기록</span>
        <span class="no">D</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="no">D</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="no">D</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="no">D</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>

        <span class="cm">/**
         * DP 점화식
         * D[i] = D[i-3] + D[i-2] + D[i-1]
         * N의 범위가 11까지기에 4부터 11까지의 경우의 수를 구한다.
         */</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">4</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">11</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">3</span><span class="o">]</span> <span class="o">+</span> <span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="o">]</span> <span class="o">+</span> <span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">T</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
            <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">]+</span><span class="s">"\n"</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/9095">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[9095번 - 1,2,3 더하기]]></summary></entry><entry><title type="html">[Java] 백준(실버-1) 2468번 - 안전 영역</title><link href="http://localhost:4000/java/209-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-1) 2468번 - 안전 영역" /><published>2023-07-04T00:00:00+09:00</published><updated>2023-07-04T00:00:00+09:00</updated><id>http://localhost:4000/java/209-post</id><content type="html" xml:base="http://localhost:4000/java/209-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 <strong>BFS</strong>를 이용한 그래프 탐색을 이용해 풀 수 있다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>BFS를 통해 탐색하면서 <strong>연결된 노드의 개수를 구하는 것</strong>과 <strong>높이별로 탐색을 구분하여 진행</strong>해야 한다는 점을 유의하면 쉽게 풀 수 있다.</p>

<ol>
  <li>높이정보를 입력받으며 높이별 목록을 만든다.</li>
  <li>구한 높이별로 배열을 탐색하며 BFS를 호출하여 연결된 노드를 구한다.
    <blockquote>
      <p>이때, 높이별로 2차원배열을 탐색하니 시간복잡도는 <code class="language-plaintext highlighter-rouge">O(N^3)</code>이 된다.</p>
    </blockquote>
  </li>
  <li>BFS의 호출횟수가 해당 높이의 안전영역의 개수가 되므로 <strong>높이별로 안전영역의 개수를 센다.</strong></li>
  <li>모든 높이를 순회하며 가장 높은 안전영역의 개수를 구하면 된다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// 상, 하, 좌, 우로 탐색할 dx, dy 배열 선언</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dx</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>

    <span class="c1">// 방문 여부를 기록할 배열 선언</span>
    <span class="kd">static</span> <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">visited</span><span class="o">;</span>
    
    <span class="c1">// 높이 여부를 담을 배열 선언</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">arr</span><span class="o">;</span>

    <span class="c1">// 배열 크기인 N*M의 N, M</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="no">N</span><span class="o">,</span> <span class="no">M</span><span class="o">;</span>

    <span class="c1">// 높이별 안전영역 갯수를 담을 변수</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">safeZoneCnt</span><span class="o">;</span>

    <span class="c1">// 모든 높이 중 가장 많은 안전영역 개수를 담을 변수</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">maxSafeZoneCnt</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
        
        <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="no">M</span> <span class="o">=</span> <span class="no">N</span><span class="o">;</span>

        <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">M</span><span class="o">];</span>

        <span class="c1">// 모든 높이를 담을 hashSet</span>
        <span class="nc">TreeSet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">heights_set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeSet</span><span class="o">&lt;&gt;();</span>

        <span class="cm">/**
         * 입력받는 높이 정보를 arr 배열에 삽입
         * 이때, 높이정보를 hashSet에 함께 삽입
         */</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="no">M</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span> 
                <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                <span class="n">heights_set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 높이정보를 담은 hashSet을 ArrayList에 담는다.</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">heights</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="n">heights_set</span><span class="o">);</span>
        
        <span class="c1">// 모든 안전영역 개수중 가장 많은 안전영역을 구하기 위해 초기화</span>
        <span class="n">maxSafeZoneCnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// 높이마다 순회</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">heights</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>

            <span class="c1">// 높이마다 방문 여부를 비교해야 하기 때문에 높이별로 방문 배열 초기화</span>
            <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">M</span><span class="o">];</span>
            
            <span class="c1">// 높이별 안전영역 개수를 구하기 위해 safeZoneCnt 초기화</span>
            <span class="n">safeZoneCnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

            <span class="cm">/**
             * 높이마다 arr 배열을 순회하면서 BFS를 호출
             * BFS 호출횟수가 안전영역의 개수가 된다.
             * BFS 호출 이후 해당 높이만큼 잠겨야 하기에 해당 원소들을 0으로 갱신
             */</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">x</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">x</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">y</span><span class="o">&lt;</span><span class="no">M</span><span class="o">;</span> <span class="n">y</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">safeZoneCnt</span><span class="o">++;</span>
                        <span class="no">BFS</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
                    <span class="o">}</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">heights</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="n">arr</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">])</span> <span class="o">{</span>
                        <span class="n">arr</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="c1">// 높이별로 구한 안전영역의 개수 중 가장 높은 값을 maxSafeZoneCnt에 저장</span>
            <span class="n">maxSafeZoneCnt</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">maxSafeZoneCnt</span><span class="o">,</span> <span class="n">safeZoneCnt</span><span class="o">);</span>

        <span class="o">}</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">maxSafeZoneCnt</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/**
     * BFS 함수
     */</span> 
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">BFS</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">});</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">now</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">dir</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">dir</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">;</span> <span class="n">dir</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">now</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">dx</span><span class="o">[</span><span class="n">dir</span><span class="o">];</span>
                <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">now</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">dy</span><span class="o">[</span><span class="n">dir</span><span class="o">];</span>
                <span class="k">if</span><span class="o">(</span><span class="n">isRange</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">});</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isRange</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">&lt;</span><span class="no">N</span> <span class="o">&amp;&amp;</span> <span class="n">y</span><span class="o">&lt;</span><span class="no">M</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/2468">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[2468번 - 안전 영역]]></summary></entry><entry><title type="html">[Java] 프로그래머스(level-2) - 오픈채팅방</title><link href="http://localhost:4000/java/206-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-2) - 오픈채팅방" /><published>2023-07-03T00:00:00+09:00</published><updated>2023-07-03T00:00:00+09:00</updated><id>http://localhost:4000/java/206-post</id><content type="html" xml:base="http://localhost:4000/java/206-post/"><![CDATA[<p><br /></p>

<center><img src="/assets/images/programmers/" width="100%" /></center>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />

<p>이 문제는 <strong>HashMap</strong>을 활용하면 풀 수 있는 간단한 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>문제를 살펴보면, 출력해야하는 채팅방 관리 기록은 사용자마다 가장 최신의 닉네임을 반영하고 있다. 여기서 바로 <strong>HashMap을 활용해 사용자마다 최신의 닉네임을 갱신</strong>해두면 된다는 것을 알 수 있다.</p>

<p>사용자마다 갱신한 닉네임을 구한다면 <strong>입장하는 <code class="language-plaintext highlighter-rouge">Enter</code>, 퇴장하는 <code class="language-plaintext highlighter-rouge">Leave</code> 마다 해당 닉네임으로 기록</strong>을 남기면 된다.</p>

<p>그래서 결국 닉네임을 갱신하는 순회와 기록을 남기는 순회까지 총 <strong>O(2N)의 시간복잡도를 가지도록 구현</strong>하면 된다.</p>

<p><br /></p>

<ul>
  <li>record 배열을 순회하며, <code class="language-plaintext highlighter-rouge">Enter</code>일 경우, HashMap에 사용자를 key로, 닉네임을 value로 삽입한다.</li>
  <li><code class="language-plaintext highlighter-rouge">Change</code>일 경우, HashMap에 사용자를 key로, 닉네임을 value로 삽입하여 사용자의 닉네임을 갱신한다.</li>
  <li>다시 record 배열을 순회하며 <code class="language-plaintext highlighter-rouge">Enter</code>일 경우 hashMap의 닉네임으로 입장 기록을 남기고, <code class="language-plaintext highlighter-rouge">Leave</code>일 경우 hashMap의 닉네임으로 퇴장 기록을 남긴다.</li>
</ul>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
</pre></td><td class="rouge-code"><pre>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nc">String</span><span class="o">[]</span> <span class="nf">solution</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">record</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">userMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="n">input</span> <span class="o">:</span> <span class="n">record</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">String</span><span class="o">[]</span> <span class="n">split</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">split</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="s">"Enter"</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">userMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">split</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">split</span><span class="o">[</span><span class="mi">2</span><span class="o">]);</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">split</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="s">"Change"</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">userMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">split</span><span class="o">[</span><span class="mi">1</span><span class="o">],</span> <span class="n">split</span><span class="o">[</span><span class="mi">2</span><span class="o">]);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="n">input</span> <span class="o">:</span> <span class="n">record</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">String</span><span class="o">[]</span> <span class="n">split</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">split</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="s">"Enter"</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">userMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">split</span><span class="o">[</span><span class="mi">1</span><span class="o">])</span> <span class="o">+</span> <span class="s">"님이 들어왔습니다."</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">split</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="s">"Leave"</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">userMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">split</span><span class="o">[</span><span class="mi">1</span><span class="o">])</span> <span class="o">+</span> <span class="s">"님이 나갔습니다."</span><span class="o">);</span>
            <span class="o">}</span>
            
        <span class="o">}</span>

        <span class="nc">String</span><span class="o">[]</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[</span><span class="n">result</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">result</span><span class="o">.</span><span class="na">size</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
        
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        
        <span class="nc">String</span><span class="o">[]</span> <span class="n">record</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[]{</span><span class="s">"Enter uid1234 Muzi"</span><span class="o">,</span>
                                       <span class="s">"Enter uid4567 Prodo"</span><span class="o">,</span>
                                       <span class="s">"Leave uid1234"</span><span class="o">,</span>
                                       <span class="s">"Enter uid1234 Prodo"</span><span class="o">,</span>
                                       <span class="s">"Change uid4567 Ryan"</span><span class="o">};</span>

        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">record</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<ul>
  <li>
    <hr />
  </li>
</ul>

<p><br /></p>

<h3 id="출처">출처</h3>
<p>-
—</p>

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://school.programmers.co.kr/learn/courses/30/lessons/42888">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 2 - 오픈채팅방]]></summary></entry><entry><title type="html">[Java] 백준(실버-4) 1026번 - 보물</title><link href="http://localhost:4000/java/204-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-4) 1026번 - 보물" /><published>2023-06-30T00:00:00+09:00</published><updated>2023-06-30T00:00:00+09:00</updated><id>http://localhost:4000/java/204-post</id><content type="html" xml:base="http://localhost:4000/java/204-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이 문제는 배열 <strong>정렬</strong>을 통해 풀 수 있는 간단한 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>A 배열과 B 배열을 어떻게 정렬해야 <code class="language-plaintext highlighter-rouge">A[0]*B[0]+...+A[N]*B[N]</code>의 값을 최소로 할 수 있을까?</p>

<p>조금만 생각해보면 쉽게 알 수 있다. 바로 <strong>곱해지는 수를 작게 만들면</strong> 된다. 아래 예시를 보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="mi">5</span>
<span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">6</span> <span class="mi">0</span> 
<span class="mi">2</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">3</span> <span class="mi">1</span>
<span class="o">=</span> <span class="mi">2</span><span class="o">+</span><span class="mi">7</span><span class="o">+</span><span class="mi">8</span><span class="o">+</span><span class="mi">18</span><span class="o">+</span><span class="mi">1</span> <span class="o">=</span> <span class="mi">35</span>

<span class="c1">// A 배열은 내림차순으로, B 배열은 오름차순으로 정렬</span>
<span class="mi">5</span>
<span class="mi">6</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span>
<span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">7</span> <span class="mi">8</span>
<span class="o">=</span> <span class="mi">6</span><span class="o">+</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="o">+</span><span class="mi">7</span><span class="o">+</span><span class="mi">0</span> <span class="o">=</span> <span class="mi">18</span> 
</pre></td></tr></tbody></table></code></pre></div></div>

<p>위처럼 곱해지는 수가 작게 되도록 <strong>A 배열은 내림차순</strong>으로, <strong>B 배열은 오름차순</strong>으로 정렬하여 S 함수식을 적용하니 최솟값을 구할 수 있었다.</p>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
        
        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="nc">Integer</span><span class="o">[]</span> <span class="no">A</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Integer</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="no">B</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>

        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="o">}</span>

        <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="no">B</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="o">}</span>

        <span class="cm">/**
         * A, B 배열 정렬
         * (A[0]*B[0])+(A[N]*B[N]) 값을 최소로 만드러면 B 원소의 최대값일 수록 작은 값을 곱해야 한다.
         * 이를 위해 B를 오름차순으로 정렬한 뒤, A를 내림차순으로 정렬한다.
         * 이때, A를 내림차순 정렬하기 위해 Integer형의 배열로 사용한다.
         */</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="no">A</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>
            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">o1</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">o2</span> <span class="o">-</span> <span class="n">o1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">});</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="no">B</span><span class="o">);</span>

        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="no">A</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">*</span> <span class="no">B</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/1026">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[1026번 - 보물]]></summary></entry><entry><title type="html">[Java] 백준(실버-2) 1541번 - 잃어버린 괄호</title><link href="http://localhost:4000/java/203-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-2) 1541번 - 잃어버린 괄호" /><published>2023-06-30T00:00:00+09:00</published><updated>2023-06-30T00:00:00+09:00</updated><id>http://localhost:4000/java/203-post</id><content type="html" xml:base="http://localhost:4000/java/203-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이 문제는 <strong>그리디 알고리즘</strong> 유형의 문제 중 하나이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>주어진 문자열 식을 보고 괄호를 쳐서 식의 결과를 가장 최솟값으로 나오도록 해야한다. 어떻게 괄호를 쳐 식의 결과를 최소로 만들 수 있을까?</p>

<p>하나의 예시를 보자.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>input = 30-70-20+40-10+100+30-35
30 - 70 - (20+40) - (10+100+30) - 35 = -275
</pre></td></tr></tbody></table></code></pre></div></div>

<p>위 예시를 보면 알겠지만 핵심 포인트는 바로 <strong>덧셈 부분을 먼저 계산</strong> 하는 것이다. 이를 통해 문제 해결을 위한 아이디어는 다음과 같다.</p>

<p><br /></p>

<ol>
  <li>뺄셈(-)을 기준으로 주어진 문자열 식을 분할한다.</li>
  <li>분할된 문자열 각각을 하나의 원소로 모두 더해준다.</li>
  <li>뺄셈으로 분할된 원소들을 뺄셈해준다.</li>
</ol>

<p><br /></p>

<p>추가적으로 문제 풀이시 유의해야 할 것은 다음과 같다.</p>

<ul>
  <li><strong>식의 첫번째 수는 양수</strong>인 점을 유의해야 하기 때문에, 첫번째 수를 초기값으로 설정하도록 해야 한다.</li>
  <li>split() 메서드 사용시 PatternSyntaxException 예외 방지를 위해 <strong>”\+” 로 escape 처리</strong> 해야한다.</li>
</ul>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
        
        <span class="nc">String</span> <span class="n">input</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">split_minus</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">"-"</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">split_minus</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            
            <span class="c1">// 뺄셈으로 나뉜 수들을 더할 num 변수 선언 및 초기화</span>
            <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            
            <span class="c1">// 그냥 "+"으로 split 메서드를 사용하면 + 문자는 메타문자라서 PatternSyntaxException 에러가 발생한다.</span>
            <span class="c1">// 그래서 + 문자를 이용하기 위해 "\\+"로 escape 처리를 한다.</span>
            <span class="c1">// 이후, +로 분할된 원소를 모두 num에 더해준다.</span>
            <span class="nc">String</span><span class="o">[]</span> <span class="n">split_plus</span> <span class="o">=</span> <span class="n">split_minus</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">split</span><span class="o">(</span><span class="s">"\\+"</span><span class="o">);</span>
            <span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="n">num_plus</span> <span class="o">:</span> <span class="n">split_plus</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">num</span> <span class="o">+=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">num_plus</span><span class="o">);</span>
            <span class="o">}</span>
            
            <span class="c1">// 첫번째 수는 양수이기에 초기값으로 설정한다.</span>
            <span class="c1">// 첫번째 수가 아니라면 모두 뺄셈해준다.</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">min</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">min</span> <span class="o">-=</span> <span class="n">num</span><span class="o">;</span>
            <span class="o">}</span>

        <span class="o">}</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">min</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/1541">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[1541번 - 잃어버린 괄호]]></summary></entry><entry><title type="html">[Java] 백준(골드-4) 1715번 - 카드 정렬하기</title><link href="http://localhost:4000/java/205-post/" rel="alternate" type="text/html" title="[Java] 백준(골드-4) 1715번 - 카드 정렬하기" /><published>2023-06-30T00:00:00+09:00</published><updated>2023-06-30T00:00:00+09:00</updated><id>http://localhost:4000/java/205-post</id><content type="html" xml:base="http://localhost:4000/java/205-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이 문제는 <strong>우선순위 큐</strong>를 활용해 풀 수 있는 문제 중 하나이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>먼저 카드뭉치를 비교하기 위해서는 두 수의 합을 구하고 비교해야 한다. 문제의 예제 테스트케이스를 보면 <code class="language-plaintext highlighter-rouge">(10+20) + (30 + 40) = 100</code> 처럼, 앞의 두 수를 더한 값을 뒤의 수와 합해가야 한다.</p>

<p>이로 인해, 카드 수를 더해가는 연산마다 가장 작은 값을 누적시켜야 한다는 것을 알 수 있다. 이때, 왜 우선순위 큐를 사용해야 하는 걸까?</p>

<blockquote>
  <p>두 수를 더하고 큐에 다시 삽입해가는 것은 동일하지만, 단순히 <strong>기본 큐를 사용하게 되면 맨 뒤로 삽입되는 값이 있기에 연산에 바로 사용할 수 없다.</strong> 우선순위 큐는 <strong>낮은 숫자부터 꺼낼 수 있다는 특징</strong>을 가지기에 큐가 아닌 우선순위 큐를 이용해 가장 작은 값의 합을 누적시킬 수 있게 된다.</p>
</blockquote>

<p>최소한의 비교를 하기 위해서는 낮은 값부터 먼저 더해야 하므로 오름차순으로 정렬된 상태에서 값을 더하기 위해 우선순위 큐를 사용해야 한다. 여기서 오름차순으로 정렬된 상태라는 것은 우선순위 큐에서는 낮은 수부터 꺼내오며 덧셈할 수 있다는 의미이다.</p>

<p>우선순위 큐를 이용해 문제 해결을 위한 아이디어는 다음과 같다.</p>

<ol>
  <li>while문을 사용하여 더한 값을 계속해서 우선순위 큐에 넣어준다.</li>
  <li>우선순위 큐의 원소가 1개만 남았다면 더 이상 더할 수가 없다는 것으로 간주하고 연산을 종료한다.</li>
</ol>

<p><br /></p>

<p>또한, 문제 풀이시 자료형과 관련하여 고려해야 할 점은 다음과 같다.</p>
<blockquote>
  <p>최악의 경우 100,000개의 N이 주어지는데 1~100000을 다 더해도 int 범위를 초과하기 때문에 long을 사용해야 한다.</p>
</blockquote>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
        
        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">pq</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;();</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="nc">Long</span><span class="o">.</span><span class="na">parseLong</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">()));</span>
        <span class="o">}</span>
        
        <span class="c1">// N의 범위가 최대 100,000이기 때문에 int형이 아닌 long형을 사용한다.</span>
        <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// 우선순위 큐의 원소가 2개 이상 있어야 비교할 수 있다.</span>
        <span class="k">while</span><span class="o">(</span><span class="n">pq</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 우선순위가 높은 낮은 숫자부터 우선순위 큐에서 2개를 꺼낸다.</span>
            <span class="kt">long</span> <span class="n">now</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="kt">long</span> <span class="n">next</span> <span class="o">=</span> <span class="n">pq</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            
            <span class="c1">// 두 수를 더해주고 더한 수를 result에 더해간다.</span>
            <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">now</span> <span class="o">+</span> <span class="n">next</span><span class="o">;</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">sum</span><span class="o">;</span>
            
            <span class="c1">// 두수를 더한 수를 우선순위 큐 마지막에 삽입한다.</span>
            <span class="n">pq</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">sum</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/1715">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[1715번 - 카드 정렬하기]]></summary></entry></feed>