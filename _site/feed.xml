<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-07-25T13:44:25+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">lango’s DevLog</title><subtitle>developer</subtitle><author><name>lango</name></author><entry><title type="html">[Java] 백준(골드-5) 10026번 - 적록색약</title><link href="http://localhost:4000/java/234-post/" rel="alternate" type="text/html" title="[Java] 백준(골드-5) 10026번 - 적록색약" /><published>2023-07-25T00:00:00+09:00</published><updated>2023-07-25T00:00:00+09:00</updated><id>http://localhost:4000/java/234-post</id><content type="html" xml:base="http://localhost:4000/java/234-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이 문제는 <strong>너비 우선 탐색 BFS</strong>를 이용해 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>정수를 이용하는 다른 BFS와 달리 문자열을 통해 조건을 부여해야 하는 문제이기에 조건을 잘 선정해야 한다. 필자는 <strong>일반적인 사람이 보았을 떄 구역의 개수를 먼저 센 후, 적록색약 사람이 보았을 때 구역의 개수를 세는 순서로 BFS를 이용</strong>했다.</p>

<p>또한, 구역의 개수는 BFS 함수의 호출횟수가 된다. 이를 위해 생각한 아이디어는 다음과 같다.</p>

<ol>
  <li>입력 배열을 순회하며 R, G, B 구역의 개수를 BFS 탐색으로 센다.</li>
  <li>적록색약은 R, G를 구분하지 않으니 입력 배열의 G를 R로 변경한다.</li>
  <li>R과 B만 존재하는 배열을 순회하며 R, B 구역의 개수를 BFS 탐색으로 센다.</li>
  <li>먼저 센 R, G, B 구역의 개수와 이후에 센 R, B 구역의 개수를 저장한 값을 출력한다.</li>
</ol>

<blockquote>
  <p>위 아이디어를 위해 이중 for문을 여러개 쓰다보니 시간복잡도 측면에서 <code class="language-plaintext highlighter-rouge">O(4n^2)</code> 으로 좋지는 못한 것 같다. 개선한다면 BFS 함수에 파라미터를 추가해서 적록색약의 탐색인지, 일반 탐색인지를 추가로 부여해서 하는 방법도 있을 것 같다.</p>
</blockquote>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dx</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>

    <span class="kd">static</span> <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">visited</span><span class="o">;</span>
    <span class="kd">static</span> <span class="nc">String</span><span class="o">[][]</span> <span class="n">arr</span><span class="o">;</span>

    <span class="kd">static</span> <span class="kt">int</span> <span class="no">N</span><span class="o">;</span>

    <span class="kd">static</span> <span class="kt">int</span> <span class="n">cnt_all</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">cnt_red_green</span><span class="o">;</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
        
        <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="c1">// 입력 문자열 배열과 방문배열 선언</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">N</span><span class="o">];</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">N</span><span class="o">];</span>

        <span class="c1">// 일반 구역 개수와 적녹색약의 구역 개수를 셀 변수 초기화</span>
        <span class="n">cnt_all</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">cnt_red_green</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// 입력 배열을 채운다.</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">String</span><span class="o">[]</span> <span class="n">input</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">().</span><span class="na">split</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">input</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 먼저 R,G,B 구역의 개수를 센다.</span>
        <span class="c1">// 이떄, R, G, B 구역의 개수는 BFS의 호출횟수가 된다.</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="s">"R"</span><span class="o">))</span> <span class="o">{</span>
                        <span class="no">BFS</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="s">"R"</span><span class="o">);</span>
                        <span class="n">cnt_all</span><span class="o">++;</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="s">"G"</span><span class="o">)){</span>
                        <span class="no">BFS</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="s">"G"</span><span class="o">);</span>
                        <span class="n">cnt_all</span><span class="o">++;</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="s">"B"</span><span class="o">)){</span>
                        <span class="no">BFS</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="s">"B"</span><span class="o">);</span>
                        <span class="n">cnt_all</span><span class="o">++;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 적녹색약 구역의 개수를 세기 위해 방문 배열을 다시 초기화한다.</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">N</span><span class="o">];</span>

        <span class="c1">// 적녹색약의 구역을 세기 위해 입력배열의 G를 R로 갱신한다.</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="s">"G"</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="s">"R"</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="c1">// 마지막으로 R,B 구역의 개수를 센다.</span>
        <span class="c1">// R, B 구역의 개수는 BFS의 호출횟수가 된다.</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="s">"R"</span><span class="o">))</span> <span class="o">{</span>
                        <span class="no">BFS</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="s">"R"</span><span class="o">);</span>
                        <span class="n">cnt_red_green</span><span class="o">++;</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="s">"B"</span><span class="o">)){</span>
                        <span class="no">BFS</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="s">"B"</span><span class="o">);</span>
                        <span class="n">cnt_red_green</span><span class="o">++;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">cnt_all</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">cnt_red_green</span> <span class="o">+</span> <span class="s">"\n"</span><span class="o">);</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">BFS</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="nc">String</span> <span class="n">color</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">});</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">now</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">dir</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">dir</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">;</span> <span class="n">dir</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">now</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">dx</span><span class="o">[</span><span class="n">dir</span><span class="o">];</span>
                <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">now</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">dy</span><span class="o">[</span><span class="n">dir</span><span class="o">];</span>
                <span class="k">if</span><span class="o">(</span><span class="n">isRange</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">].</span><span class="na">equals</span><span class="o">(</span><span class="n">color</span><span class="o">))</span> <span class="o">{</span>
                        <span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">});</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isRange</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">&lt;</span><span class="no">N</span> <span class="o">&amp;&amp;</span> <span class="n">y</span><span class="o">&lt;</span><span class="no">N</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/10026">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[10026번 - 적록색약]]></summary></entry><entry><title type="html">[Java] 백준(골드-5) 5430번 - AC</title><link href="http://localhost:4000/java/235-post/" rel="alternate" type="text/html" title="[Java] 백준(골드-5) 5430번 - AC" /><published>2023-07-25T00:00:00+09:00</published><updated>2023-07-25T00:00:00+09:00</updated><id>http://localhost:4000/java/235-post</id><content type="html" xml:base="http://localhost:4000/java/235-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이 문제는 자료구조 중 <strong>양쪽 연산이 가능한 Deque(덱)</strong>을 이용해 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>덱을 이용하는 이유는 바로 시간초과를 피하기 위함이다. 필자는 아무 생각 없이 문제 제약사항을 읽지 않고 배열을 뒤집는 R 함수의 과정에서 Collections.reverse() 메소드를 이용해 풀었더니 <strong>시간초과가 발생</strong>했다.</p>

<p>그런데 문제를 조금 만 더 자세히 살펴보면, 주어진 배열을 뒤집을 필요가 없다는 것을 알 수 있었다. 아래 예시를 살펴보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">],</span> <span class="n">front</span><span class="o">=</span><span class="mi">1</span>

<span class="mi">1</span><span class="o">.</span> <span class="no">R</span> <span class="n">함수</span> <span class="n">실행</span>
<span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">4</span><span class="o">]</span> <span class="n">front</span><span class="o">=</span><span class="mi">4</span>

<span class="mi">2</span><span class="o">.</span> <span class="no">D</span> <span class="n">함수</span> <span class="n">실행</span>
<span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">]</span> <span class="n">front</span><span class="o">=</span><span class="mi">3</span>

<span class="mi">2</span><span class="o">.</span> <span class="no">D</span> <span class="n">함수</span> <span class="n">실행</span>
<span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">]</span> <span class="n">front</span><span class="o">=</span><span class="mi">2</span>

<span class="o">=&gt;</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>덱을 이용하면 위와 같이 배열을 뒤집는 과정을 구현할 필요없이 양쪽의 원소를 제거하는 메소드를 통해 뒤집는 것과 유사한 동작을 구현할 수 있다. 이를 통해 도출한 아이디어는 다음과 같다.</p>

<ol>
  <li>Deque에 주어진 정수 배열을 담는다.</li>
  <li>함수 문자열 p를 순회하며 <strong>R 함수시에는 스위치 변수를 변경</strong>해주고, 이 스위치 변수를 통해 D 함수를 수행한다.</li>
  <li>D 함수를 수행할 때, 빈 덱에서 원소를 제거하려고 하면 <code class="language-plaintext highlighter-rouge">error</code> 문자열을 결과에 담는다.</li>
  <li>모든 D 함수를 수행했다면 <strong>스위치 변수를 통해 오름차순으로 담을지 내림차순으로 담을지를 결정</strong>하여 결과에 담으면 된다.</li>
</ol>

<p>위 아이디어대로 구현하면 간단하게 풀 수 있다.</p>

<blockquote>
  <p>정답률 16%에서 멈추고 틀렸습니다가 나올 수 있다. 이 때 덱의 사이즈를 고려해서 양쪽 제거 연산을 수행해야 하므로 덱의 원소가 하나라도 있을 경우에만 양쪽 제거 연산을 수행하도록 구현하였다.</p>
</blockquote>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// 전역으로 사용할 Deque 선언</span>
    <span class="kd">static</span> <span class="nc">ArrayDeque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">d</span><span class="o">;</span>

    <span class="c1">// 각 테스트케이스별 결과를 담을 StringBuilder 선언</span>
    <span class="kd">static</span> <span class="nc">StringBuilder</span> <span class="n">sb</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="cm">/**
         * Deque을 활용해 R 함수를 구현하는 것이 핵심이다.
         */</span>

        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
        
        <span class="kt">int</span> <span class="no">T</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">T</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>

            <span class="c1">// 주어진 배열 원소를 담아 연산을 수행할 Deque</span>
            <span class="n">d</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayDeque</span><span class="o">&lt;&gt;();</span>

            <span class="c1">// 결과를 담을 문자열</span>
            <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

            <span class="c1">// 입력으로 주어지는 함수, 배열의 길이, 배열 원소</span>
            <span class="nc">String</span> <span class="n">p</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
            <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
            <span class="nc">String</span> <span class="n">input_nums</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>

            <span class="c1">// 주어진 배열이 함수를 수행할 수 있는 원소가 있을 경우만 연산을 수행한다.</span>
            <span class="k">if</span><span class="o">(</span><span class="n">length</span><span class="o">&gt;</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// 주어진 배열 파싱하여 Deque에 답는다.</span>
                <span class="n">input_nums</span> <span class="o">=</span> <span class="n">input_nums</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">input_nums</span><span class="o">.</span><span class="na">length</span><span class="o">()-</span><span class="mi">1</span><span class="o">);</span>
                <span class="nc">String</span><span class="o">[]</span> <span class="n">nums</span> <span class="o">=</span> <span class="n">input_nums</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">","</span><span class="o">);</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="n">d</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">j</span><span class="o">]));</span>
                <span class="o">}</span>
            <span class="o">}</span>
            
            <span class="cm">/**
             * 함수 수행 - R, D
             * R일 때 Collections.reverse() 메소드를 사용하면 시간초과가 발생한다.
             * Deque의 특성을 이용해 양쪽으로 front를 변경해가며 연산을 수행하면 된다.
             */</span>
            <span class="no">AC</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">d</span><span class="o">);</span>

            <span class="c1">// AC 함수 호출을 통해 쌓인 StringBuilder 출력.</span>
            <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">sb</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
            
        <span class="o">}</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/**
     * R 함수시 스위치만 해준 후, Deque에 D 연산으로 양쪽 제거를 먼저 한다.
     * D 연산이 모두 종료된 후 스위치변수와 Deque 원소를 통해 내림차순이나 오름차순 정렬을 해준다.
     */</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">AC</span><span class="o">(</span><span class="nc">String</span> <span class="n">p</span><span class="o">,</span> <span class="nc">ArrayDeque</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">d</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="nc">String</span><span class="o">[]</span> <span class="n">cmds</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">""</span><span class="o">);</span>
        
        <span class="c1">// R 함수를 수행하기 위해 양쪽으로 스위치하기 위한 변수</span>
        <span class="kt">boolean</span> <span class="n">reverse</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="n">cmd</span> <span class="o">:</span> <span class="n">cmds</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// R 함수로 인해 뒤집어야 할 경우 스위치한다.</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cmd</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"R"</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">reverse</span> <span class="o">=</span> <span class="o">!</span><span class="n">reverse</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="cm">/**
             * D 함수일 경우 빈 덱을 삭제하려고 할 경우 error를 담는다.
             * 
             */</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">cmd</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"D"</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">reverse</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">d</span><span class="o">.</span><span class="na">pollLast</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"error"</span><span class="o">);</span>
                        <span class="k">return</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">d</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"error"</span><span class="o">);</span>
                        <span class="k">return</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="cm">/**
         * D 연산 종료 후 배열 원소를 정렬하여 저장한다. 
         * reverse==true라면 마지막 수 저장후, 내핌차순(덱의 역방향) 정렬
         * reverse==false라면 첫번째 수 저장후, 오름차순(덱의 정방향) 정렬
         * 이떄, Duque의 원소가 1개 이상 있어야 한다.
         */</span>
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"["</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">d</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">reverse</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">d</span><span class="o">.</span><span class="na">pollLast</span><span class="o">());</span>
                <span class="k">while</span><span class="o">(!</span><span class="n">d</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">","</span> <span class="o">+</span> <span class="n">d</span><span class="o">.</span><span class="na">pollLast</span><span class="o">());</span>
                <span class="o">}</span>
            <span class="o">}</span> 
            <span class="k">else</span> <span class="o">{</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">d</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">());</span>
                <span class="k">while</span><span class="o">(!</span><span class="n">d</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">","</span> <span class="o">+</span> <span class="n">d</span><span class="o">.</span><span class="na">pollFirst</span><span class="o">());</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"]"</span><span class="o">);</span>

    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/5430">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[5430번 - AC]]></summary></entry><entry><title type="html">[Java] 백준(실버-3) 11727번 - 2×n 타일링 2</title><link href="http://localhost:4000/java/233-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-3) 11727번 - 2×n 타일링 2" /><published>2023-07-24T00:00:00+09:00</published><updated>2023-07-24T00:00:00+09:00</updated><id>http://localhost:4000/java/233-post</id><content type="html" xml:base="http://localhost:4000/java/233-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이 문제는 <strong>동적 계획법(DP)</strong>를 이용해 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>이번 문제는 이전에 풀었던 <a href="https://langoustinee.github.io/java/226-post/">2xn 타일링</a> 문제와 흠사한 방법으로 풀 수 있다.</p>

<p>2xn 타일링 문제가 피보나치 수열의 형태를 띄고있었다면 이번에는 그 형태가 다르다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="no">N</span><span class="o">=</span><span class="mi">1</span>
<span class="mi">1</span><span class="n">x2</span> <span class="o">=&gt;</span> <span class="o">|</span>
<span class="n">총</span> <span class="mi">1</span><span class="n">가지의</span> <span class="n">방법</span>

<span class="no">N</span><span class="o">=</span><span class="mi">2</span>
<span class="mi">2</span><span class="n">x2</span> <span class="o">=&gt;</span> <span class="n">ㅁ</span>
<span class="mi">1</span><span class="n">x2</span> <span class="o">=&gt;</span> <span class="o">||</span>
<span class="mi">2</span><span class="n">x1</span> <span class="o">=&gt;</span> <span class="o">=</span>
<span class="n">총</span> <span class="mi">3</span><span class="n">가지의</span> <span class="n">방법</span>

<span class="no">N</span><span class="o">=</span><span class="mi">3</span>
<span class="mi">2</span><span class="n">x2</span><span class="o">,</span> <span class="mi">1</span><span class="n">x2</span> <span class="o">=&gt;</span> <span class="n">ㅁ</span><span class="o">|,</span> <span class="o">|</span><span class="n">ㅁ</span>
<span class="mi">1</span><span class="n">x2</span><span class="o">,</span> <span class="mi">2</span><span class="n">x1</span> <span class="o">=&gt;</span> <span class="o">|||,</span> <span class="o">=|,</span> <span class="o">|=</span>
<span class="n">총</span> <span class="mi">5</span><span class="n">가지의</span> <span class="n">방법</span>

</pre></td></tr></tbody></table></code></pre></div></div>
<p>위 내용을 잘 살펴보면, N이 3일 때는 N=2일 때 타일에 2x1 타일이 세로로 하나 붙은 형태를 가지고 있고, N=1일 때 타일에 2x1 타일이 가로로 2개 붙어있거나, 2x2 타일이 붙은 형태를 지니고 있음을 알 수 있다.</p>

<p>이전 문제에서는 N-2의 타일에 붙이는 타일은 2x1 타일을 가로로 2개 붙인 경우만 가능했었으나, 2x2 타일이 추가되면서 경우의 수가 늘어났다고 볼 수 있다.</p>

<p>따라서, 점화식은 다음과 같이 표현할 수 있다.</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">dp[n]=dp[n−1]+2×dp[n−2]</code></p>
</blockquote>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// DP 테이블 선언</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="no">D</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
        
        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="no">D</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 2X0은 0가지, 2X1은 1가지, 2X2은 3가지 경우의 수가 있다.</span>
        <span class="no">D</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="no">D</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        
        <span class="c1">// N이 1일 경우가 있기 때문에 예외처리를 해준다.</span>
        <span class="k">if</span><span class="o">(</span><span class="no">N</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="no">D</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="c1">// 재귀함수 호출한다.</span>
        <span class="n">recursion</span><span class="o">(</span><span class="no">N</span><span class="o">);</span>

          <span class="c1">// DP 테이블에 저장된 N번째 값을 출력한다.</span>
        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">]+</span><span class="s">"\n"</span><span class="o">);</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/**
     * N=1일 때는 1가지, N=2일 때는 3가지, N=3일 때는 5가지의 방법이 있다.
     * 고로, 점화식은 (N-1) + 2 * (N-2)가 된다.
     */</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="nf">recursion</span><span class="o">(</span><span class="kt">int</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>    
        <span class="o">}</span>
        <span class="k">return</span> <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="n">recursion</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">recursion</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">2</span><span class="o">)))</span> <span class="o">%</span> <span class="mi">10007</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/11727">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[11727번 - 2×n 타일링 2]]></summary></entry><entry><title type="html">[Java] 백준(실버-3) 2579번 - 계단 오르기</title><link href="http://localhost:4000/java/232-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-3) 2579번 - 계단 오르기" /><published>2023-07-24T00:00:00+09:00</published><updated>2023-07-24T00:00:00+09:00</updated><id>http://localhost:4000/java/232-post</id><content type="html" xml:base="http://localhost:4000/java/232-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이 문제는 <strong>동적 계획법(DP)</strong>를 이용해 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>이 문제에서는 Top-Down 방식과 Bottom-Up 방식 중 <strong>Top-Down 방식으로 풀기 위해 재귀를 이용</strong>했다.</p>

<p>먼저 문제의 제약사항은 다음과 같다.</p>

<ul>
  <li>계단은 한 번에 한 계단, 두 계단씩만 오를 수 있다</li>
  <li>연속된 3개의 계단을 밟으면 안된다</li>
</ul>

<p>위 조건을 토대로 N번째 계단을 밟는 경우를 따져보면 <strong>N-3을 밟고 N-1번 계단을 밟고 오는 경우</strong>와 <strong>N-2번을 밟고 오는 경우</strong> 2가지가 존재한다. 위 2가지 말고는 연속으로 3개의 계단을 밟는 것은 불가능하기 때문에 이외의 경우는 존재하지 않는다.</p>

<p>또한, 계단의 점수가 입력된 배열을 arr, DP 테이블을 D라고 한다면, 마지막 칸은 무조건 밟아야 하므로 N번째 계단을 밟았을 때의 점화식을 다음과 같이 도출할 수 있다.</p>

<blockquote>
  <p>3번째 전의 칸을 밟고 1번째 전의 칸을 밝고 오는 경우와 2번째 전의 칸을 밝고 오는 경우 중 더 큰 점수 값 + N번째 칸의 점수 값 <br />
<code class="language-plaintext highlighter-rouge">D[N] = Math.max(recursion(N-3)+arr[N-1], recursion(N-2)) + arr[N]</code></p>
</blockquote>

<blockquote>
  <p>유의할 점은 <strong>1,2,3번째 계단의 경우 점화식을 대입할 때 3번째 전의 칸이 존재하지 않는다.</strong> 이러한 예외를 방지하기 위해 N이 2 이상일 경우 DP 테이블의 0,1,2 번째 값을 갱신해주어야 한다.</p>
</blockquote>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// DP 테이블 선언</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="no">D</span><span class="o">;</span>
    
    <span class="c1">// 계단의 점수를 담을 배열</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="c1">// 최대 점수를 내려면 최대한 계단을 많이 밟아야 한다.</span>
        <span class="c1">// 고로, 1 계단씩 2번 이동한 후 2 계단씩 1번 이동을 반복해야 한다.</span>

        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
        
        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="no">D</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>

        <span class="c1">// DP 테이블 초기화</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        <span class="o">}</span>

        <span class="c1">// 0번째와 1번째 계단의 점수를 미리 갱신한다.</span>
        <span class="no">D</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
        <span class="no">D</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>

        <span class="cm">/**
         * N이 1일 수도 있기에 그에 대한 예외 처리를 해준다.
         * N-3이 존재하지 않는 경우를 대비
         */</span>
        <span class="k">if</span><span class="o">(</span><span class="no">N</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
            <span class="no">D</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">arr</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">recursion</span><span class="o">(</span><span class="no">N</span><span class="o">);</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>

        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/**
     * N번째 계단을 밟아가는 경우의 수 중에서 최대점수를 가지는 경우를 구한다.
     * N-3번째 계단을 밟고 N-1번째 계단을 밝고 오는 경우와 N-2번을 밝고 오는 경우 2가지 경우에 대해서 재귀호출한다.
     * N-1번째 계단을 밝는 경우를 재귀 호출하지 않는 이유는 밟은 계단인지 여부가 연속되지 않도록 하기 위함이다.
     * N-2와 N-3에 대해서만 재귀호출해야한다.
     * 그래서, N번째 칸의 최대 점수는 두칸 전의 메모이제이션 값과 셋째 칸 전의 메모이제이션 값 + 첫째 칸 전의 값 중 더 큰 값이 된다.
     */</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="nf">recursion</span><span class="o">(</span><span class="kt">int</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">recursion</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">2</span><span class="o">),</span> <span class="n">recursion</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">3</span><span class="o">)</span> <span class="o">+</span> <span class="n">arr</span><span class="o">[</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">])</span> <span class="o">+</span> <span class="n">arr</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/2579">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[2579번 - 계단 오르기]]></summary></entry><entry><title type="html">[Java] 백준(실버-2) 11279번 - 최대 힙</title><link href="http://localhost:4000/java/231-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-2) 11279번 - 최대 힙" /><published>2023-07-22T00:00:00+09:00</published><updated>2023-07-22T00:00:00+09:00</updated><id>http://localhost:4000/java/231-post</id><content type="html" xml:base="http://localhost:4000/java/231-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이 문제는 주어진대로 <strong>최대 힙을 우선순위 큐를 이용</strong>해 구현하면 되는 간단한 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>우선순위 큐를 이용했던 이전 문제 <a href="https://langoustinee.github.io/java/230-post/">최소 힙</a>과 동일한 풀이 방법으로 풀 수 있다.</p>

<p>최소 힙은 PriorityQueue의 기본 값으로 설정되어 있어 그냥 선언만 해도 최소 힙을 구현할 수 있었으나 최대 힙의 경우 추가적인 설정이 필요하다. 필자가 최대 힙을 구하기 위해 설정한 방법은 2가지이다.</p>

<ol>
  <li>Collections 패키지의 reverseOrder() 메소드 이용하기</li>
  <li>Comparator 클래스를 상속받아 compare() 메소드 오버라이딩하기</li>
</ol>

<p>2가지 방법 모두 우선순위 큐의 우선순위를 높은 순으로 설정할 수 있는 방법들이니 자유롭게 원하는 것을 선택하여 풀면 된다.</p>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
        
        <span class="c1">// Collections 패키지의 reverseOrder() 메소드로 우선순위를 높은 순으로 설정할 수 있다.</span>
        <span class="c1">// PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;(Collections.reverseOrder());</span>
        
        <span class="c1">// Comparator 클래스를 상속받아 compare() 메소드를 오버라이딩하여 우선순위를 높은 순으로 설정한다.</span>
        <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;(</span><span class="k">new</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>

            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">o1</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">o1</span> <span class="o">&gt;</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">o1</span> <span class="o">&lt;</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">else</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            
        <span class="o">});</span>

        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
            
            <span class="c1">// 만약 입력값이 0보다 큰 자연수라면 우선순위 큐에 삽입.</span>
            <span class="k">if</span><span class="o">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// 0일 때 우선순위 큐가 비어있다면 0을, 비어있지 않다면 가장 높은 수를 꺼낸다.</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">()+</span><span class="s">"\n"</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"0"</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
            <span class="o">}</span>
            
        <span class="o">}</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/11279">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[11279번 - 최대 힙]]></summary></entry><entry><title type="html">[Java] 백준(실버-2) 1927번 - 최소 힙</title><link href="http://localhost:4000/java/230-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-2) 1927번 - 최소 힙" /><published>2023-07-22T00:00:00+09:00</published><updated>2023-07-22T00:00:00+09:00</updated><id>http://localhost:4000/java/230-post</id><content type="html" xml:base="http://localhost:4000/java/230-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이 문제는 주어진대로 <strong>최소 힙을 우선순위 큐를 이용</strong>해 구현하면 되는 간단한 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>이 문제에서 요구하는 최소 힙을 어떻게 우선순위 큐로 구현할 수 있는 걸까?</p>

<p>일반적인 큐(Queue)는 FIFO(First in - First Out) 구조로, 먼저 들어온 데이터가 먼저 나가는 구조이다. 그런데 <strong>우선순위 큐(Priority Queue)는 들어간 순서와는 상관없이 우선순위가 높은 데이터가 먼저 나오는 구조</strong>로 이루여져있다.</p>

<blockquote>
  <p>우선순위 큐인 PriorityQueue를 선언할 때, 인자로 Comparator 클래스를 넣어서 우선순위의 기준을 설정할수 있다. 다만 이번 문제에서는 기본값인 최소 힙을 구현하기에 별도의 Comparator 설정 없이 풀 수 있다.</p>
</blockquote>

<p>따라서 이러한 우선순위 큐를 이용하면 쉽게 최소 힙을 구현할 수 있다.</p>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>

        <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;();</span>

        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
            
            <span class="c1">// 만약 입력값이 0보다 큰 자연수라면 우선순위 큐에 삽입.</span>
            <span class="k">if</span><span class="o">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// 0일 때 우선순위 큐가 비어있다면 0을, 비어있지 않다면 가장 작은 수를 꺼낸다.</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">()+</span><span class="s">"\n"</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"0"</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
            <span class="o">}</span>
            
        <span class="o">}</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/1927">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[1927번 - 최소 힙]]></summary></entry><entry><title type="html">[Java] 백준(실버-1) 1074번 - Z</title><link href="http://localhost:4000/java/229-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-1) 1074번 - Z" /><published>2023-07-20T00:00:00+09:00</published><updated>2023-07-20T00:00:00+09:00</updated><id>http://localhost:4000/java/229-post</id><content type="html" xml:base="http://localhost:4000/java/229-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이 문제는 <strong>분할 정복 재귀</strong>를 이용해 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>이 문제는 배열을 사분면으로 나누고, 입력받은 R, C의 위치가 몇 번째 사분면에 속하는지 알아내는 것이 중요하다.</p>

<ol>
  <li>입력받은 N을 통해 2의 거듭제곱 N 값으로 배열 한 변의 길이(size)를 구한다.</li>
  <li>재귀를 호출하면서 현재 R, C의 위치가 몇 사분면에 속하는지 확인한 후 방문순서를 갱신한다.
    <blockquote>
      <p>1사분면의 위치라면 방문 순서를 갱신할 필요가 없고, 2사분면일 경우 <strong>1사분면의 위치 <code class="language-plaintext highlighter-rouge">(size*size)/4</code></strong> 를, 3사분면일 경우 <strong>1,2사분면의 모든 위치 <code class="language-plaintext highlighter-rouge">((size*size)/4) * 2</code></strong>를, 4사분면일 경우 <strong>1,2,3사분면의 위치 <code class="language-plaintext highlighter-rouge">((size*size)/4) * 3</code></strong>를 모두 더해준다.</p>
    </blockquote>
  </li>
  <li>R, C의 위치가 몇 사분면인지 확인하여 방문 순서를 갱신했다면, R, C의 위치를 찾기 위해 해당 사분면의 시작점으로 배열을 절반씩 줄여가면서 재귀 호출해준다.</li>
  <li>위 과정을 반복하면서 길이(size)가 1이 된다면 R, C의 위치를 찾은 것이니 재귀를 종요하고 이전까지 갱신했던 방문순서를 출력하면 된다.</li>
</ol>

<p>말로 설명하면 이해하기 어려울 수  있으니 예시를 몇 가지 들어보자.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>N=3,R=7,C=7일 경우 size=8, newSize=4 이다.
(R&gt;=newSize &amp;&amp; C&gt;=newSize) 조건을 만족하기에 4사분면에 속한다.
7행 7열은 63번째로 방문하게 된다.

N=3,R=3,C=7일 경우 size=8, newSize=4 이다.
(R&lt;newSize &amp;&amp; C&gt;=newSize) 조건을 만족하기에 2사분면에 속한다.
3행 7열은 31번째로 방문하게 된다.
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>이때, 1사분면 중 0행 0열은 어차피 0번째로 방문하여 방문 순서가 0번째기에 1사분면 조건에서 방문 순서를 갱신할 필요는 없다.</p>
</blockquote>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">static</span> <span class="kt">int</span> <span class="n">result</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>

        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="kt">int</span> <span class="no">R</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="kt">int</span> <span class="no">C</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

        <span class="c1">// 분할정복 재귀 문제</span>
        
        <span class="c1">// N이 1보다 크다면, NXN 배열을 4사분면으로 두어 재귀로 탐색을 한다.</span>
        <span class="c1">// N=2이면 4X4, N=3이면 8X8 배열이 된다.</span>

        <span class="c1">// 1,2,3,4 사분면을 탐색하며 R, C가 어디범위에 속해있는지 확인한다.</span>
        <span class="c1">// R, C의 사분면이 어디인지 파악했다면, 해당 사분면만 재귀 호출을 한다.</span>
        <span class="c1">// size를 절반씩 나눠가면서 해당 사분면에서 R, C 값을 찾아간다.</span>
        <span class="c1">// size가 1이 된다면 R,C를 찾은 것이기에 값을 저장하고 return 하면 된다.</span>

        <span class="c1">// 배열의 크기를 2의 N승 형태의 거듭제곱으로 정한다.</span>
        <span class="c1">// 즉 여기서의 size는 한 변의 길이가 된다.</span>
        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="nc">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="no">N</span><span class="o">);</span>

        <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// 재귀함수를 통해 result에 방문 순서를 갱신한다.</span>
        <span class="n">recursion</span><span class="o">(</span><span class="no">R</span><span class="o">,</span> <span class="no">C</span><span class="o">,</span> <span class="n">size</span><span class="o">);</span>

        <span class="c1">// 갱신된 방문 순서가 담긴 result를 출력한다.</span>
        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 사분면을 탐색해가며 R,C를 찾을 재귀함수
     */</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">recursion</span><span class="o">(</span><span class="kt">int</span> <span class="no">R</span><span class="o">,</span> <span class="kt">int</span> <span class="no">C</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="c1">// 가장 작은 단위로 사분면을 쪼개어 </span>
        <span class="k">if</span><span class="o">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="c1">// R,C의 위치가 어떤 사분면인지 확인하기 위해 배열을 절반으로 줄인다.</span>
        <span class="kt">int</span> <span class="n">newSize</span> <span class="o">=</span> <span class="n">size</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

        <span class="cm">/**
         * 특정 사분면 파악
         * 1사분면: R &lt; newSize 그리고 C &lt; newSize
         * 2사분면: R &lt; newSize 그리고 C &gt;= newSize 
         * 3사분면: R &gt;= newSize 그리고 C &lt; newSize
         * 4사분면: R &gt;= newSIze 그리고 C &gt;= newSize
         * 
         * 방문 순서
         * R과 C의 위치가 1사분면이면 방문 순서를 기록하지 않았기에 그대로 둔다.
         * R과 C의 위치가 2사분면이라면, 1 사분면을 모두 방문해야 하므로 result에 (size * size / 4) 값을 더해준다.
         * R과 C의 위치가 3사분면이라면, 1,2 사분면을 모두 방문해야 하므로 result에  (size * size / 4 * 2) 값을 더해준다.
         * R과 C의 위치가 4사분면이라면, 1,2,3 사분면을 모두 방문해야 하므로 result에 (size * size / 4 * 3) 값을 더해준다.
         */</span>

        <span class="k">if</span><span class="o">(</span><span class="no">R</span> <span class="o">&lt;</span> <span class="n">newSize</span> <span class="o">&amp;&amp;</span> <span class="no">C</span> <span class="o">&lt;</span> <span class="n">newSize</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 1사분면 위치일 경우</span>
            <span class="n">recursion</span><span class="o">(</span><span class="no">R</span><span class="o">,</span> <span class="no">C</span><span class="o">,</span> <span class="n">newSize</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="no">R</span> <span class="o">&lt;</span> <span class="n">newSize</span> <span class="o">&amp;&amp;</span> <span class="no">C</span> <span class="o">&gt;=</span> <span class="n">newSize</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 2사분면 위치일 경우</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="o">(</span><span class="n">size</span> <span class="o">*</span> <span class="n">size</span><span class="o">)</span> <span class="o">/</span> <span class="mi">4</span><span class="o">;</span>
            <span class="n">recursion</span><span class="o">(</span><span class="no">R</span><span class="o">,</span> <span class="no">C</span><span class="o">-</span><span class="n">newSize</span><span class="o">,</span> <span class="n">newSize</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="no">R</span> <span class="o">&gt;=</span> <span class="n">newSize</span> <span class="o">&amp;&amp;</span> <span class="no">C</span> <span class="o">&lt;</span> <span class="n">newSize</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 3사분면 위치일 경우</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="o">((</span><span class="n">size</span> <span class="o">*</span> <span class="n">size</span><span class="o">)</span> <span class="o">/</span> <span class="mi">4</span><span class="o">)</span> <span class="o">*</span> <span class="mi">2</span><span class="o">;</span>
            <span class="n">recursion</span><span class="o">(</span><span class="no">R</span><span class="o">-</span><span class="n">newSize</span><span class="o">,</span> <span class="no">C</span><span class="o">,</span> <span class="n">newSize</span><span class="o">);</span>

        <span class="o">}</span>
        <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="no">R</span> <span class="o">&gt;=</span> <span class="n">newSize</span> <span class="o">&amp;&amp;</span> <span class="no">C</span> <span class="o">&gt;=</span> <span class="n">newSize</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 4사분면 위치일 경우</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="o">((</span><span class="n">size</span> <span class="o">*</span> <span class="n">size</span><span class="o">)</span> <span class="o">/</span> <span class="mi">4</span><span class="o">)</span> <span class="o">*</span> <span class="mi">3</span><span class="o">;</span>
            <span class="n">recursion</span><span class="o">(</span><span class="no">R</span><span class="o">-</span><span class="n">newSize</span><span class="o">,</span> <span class="no">C</span><span class="o">-</span><span class="n">newSize</span><span class="o">,</span> <span class="n">newSize</span><span class="o">);</span>
        <span class="o">}</span>

    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/1074">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[1074번 - Z]]></summary></entry><entry><title type="html">[Java] 백준(실버-1) 14940번 - 쉬운 최단거리</title><link href="http://localhost:4000/java/228-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-1) 14940번 - 쉬운 최단거리" /><published>2023-07-19T00:00:00+09:00</published><updated>2023-07-19T00:00:00+09:00</updated><id>http://localhost:4000/java/228-post</id><content type="html" xml:base="http://localhost:4000/java/228-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이 문제는 <strong>너비 우선 탐색인 BFS</strong>를 이용해 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>BFS 문제를 여러 번 풀어봤다면 어떤 식으로 문제 해결을 할 수 있을지 금방 알 수 있을 것이다! 풀이를 위한 아이디어는 다음과 같다.</p>

<ol>
  <li>도달할 수 없는 땅의 위치(-1)일 경우 -1로 갱신하기 위해 미리 새로운 배열의 모든 원소를 -1로 초기화한다.</li>
  <li>기존 지도를 입력받으며 갈 수 없는 땅의 위치(0)와 목표 지점 2의 위치(2)일 경우 0으로 먼저 갱신한다.</li>
  <li>그리고 목표 지점 2의 위치를 구하고 2의 위치부터 BFS 함수를 통해 너비 우선 탐색을 진행한다.</li>
  <li>지도의 위치별로 2로부터의 거리를 갱신하기 위해 새로운 배열에 이동거리를 갱신한다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    
    
    <span class="c1">// 상,하,좌,우로 탐색하기 위한 dx,dy 배열</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dx</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>

    <span class="c1">// 위치를 입력받을 기존 지도와 이동거리를 기록할 새로운 지도 배열 선언</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">arr</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">result</span><span class="o">;</span>

    <span class="c1">// 방문 배열 선언</span>
    <span class="kd">static</span> <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">visited</span><span class="o">;</span>

    <span class="c1">// 지도의 크기 변수</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="no">N</span><span class="o">,</span> <span class="no">M</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>

        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        
        <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

        <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">M</span><span class="o">];</span>
        <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">M</span><span class="o">];</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">M</span><span class="o">];</span>

        <span class="c1">// 도달할 수 없는 땅의 위치를 구하기 위해 새로운 지도의 모든 원소를 미리 -1로 설정해둔다.</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="no">M</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 목표 지점 2의 위치를 구하기 위한 좌표 변수</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="no">M</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                
                <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                
                <span class="c1">// 목표 지점 2의 위치를 구하고 새로운 지도에 해당 위치를 갱신한다.</span>
                <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
                <span class="o">}</span>
                
                <span class="c1">// 새로운 지도에 갈 수 없는 땅의 위치(0)을 갱신한다.</span>
                <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="o">}</span>

            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// BFS 함수를 통해 기존 지도를 탐색하며 새로운 지도에 목표 지점을 기준으로 이동거리를 갱신한다.</span>
        <span class="no">BFS</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">:</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">num</span><span class="o">+</span><span class="s">" "</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"\n"</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">BFS</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">});</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">now</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">dir</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">dir</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">;</span> <span class="n">dir</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">now</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">dx</span><span class="o">[</span><span class="n">dir</span><span class="o">];</span>
                <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">now</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">dy</span><span class="o">[</span><span class="n">dir</span><span class="o">];</span>
                <span class="k">if</span><span class="o">(</span><span class="n">isRange</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">});</span>
                        <span class="c1">// 새로운 지도에 목표지점으로부터 현재 위치까지의 이동거리를 갱신한다.ㅁ</span>
                        <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">result</span><span class="o">[</span><span class="n">now</span><span class="o">[</span><span class="mi">0</span><span class="o">]][</span><span class="n">now</span><span class="o">[</span><span class="mi">1</span><span class="o">]]+</span><span class="mi">1</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isRange</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">&lt;</span><span class="no">N</span> <span class="o">&amp;&amp;</span> <span class="n">y</span><span class="o">&lt;</span><span class="no">M</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/14940">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[14940번 - 쉬운 최단거리]]></summary></entry><entry><title type="html">[Java] 백준(실버-2) 2630번 - 색종이 만들기</title><link href="http://localhost:4000/java/227-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-2) 2630번 - 색종이 만들기" /><published>2023-07-17T00:00:00+09:00</published><updated>2023-07-17T00:00:00+09:00</updated><id>http://localhost:4000/java/227-post</id><content type="html" xml:base="http://localhost:4000/java/227-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이 문제는 <strong>재귀</strong>를 이용한 <strong>분할 정복</strong> 과정을 통해 풀 수 있는 문제 중 하나이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>문제에서 요구하는 내용은 하얀색과 파란색 정사각형 색종이의 개수이다. 그런데, 부분 색종이는 모두 같은 색으로 이루어져야 한다.
만약, 같은 색상으로 이루어진 색종이가 아닐 경우 색종이를 잘라야 한다. 이떄, 색종이를 자를 때는 절반인 <code class="language-plaintext highlighter-rouge">1/2</code> 씩 잘라서 새로운 색종이로 만들어야 한다.</p>

<p>이를 통해 생각해낸 아이디어는 다음과 같다.</p>

<ol>
  <li>재귀를 통해 현재 색종이가 같은 색상으로 이루어졌는지, 다른 색상이 하나라도 있는지 확인하고, 다른 색상이 있다면 색종이를 분할한다.</li>
  <li>색종이를 분할할 때, <strong>4등분(크기 절반)으로 분할하여 1번 과정을 반복</strong>한다.(재귀 호출)</li>
  <li>분할해낸 색종이가 모두 같은 색상으로 이루어졌다면, 해당 색상의 개수를 1 증가시키고 재귀 함수는 종료한다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">arr</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">w</span><span class="o">,</span> <span class="n">b</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>

        <span class="c1">// 첫째줄에는 하얀색 색종이(0)의 개수, 둘째줄에는 파란 색종이(1)의 개수를 출력</span>

        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">N</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="c1">// 하얀색, 파란색 색종이의 개수를 세기 위해 0으로 초기화</span>
        <span class="n">w</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="n">recursion</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="no">N</span><span class="o">);</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">w</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">b</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">recursion</span><span class="o">(</span><span class="kt">int</span> <span class="n">r</span><span class="o">,</span> <span class="kt">int</span> <span class="n">c</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// 1. 현재 파티션의 색종이가 모두 같은 색으로 이루어졌다면 개수를 1 증가시키고 함수를 종료한다.</span>
        <span class="k">if</span><span class="o">(</span><span class="n">isEquals</span><span class="o">(</span><span class="n">r</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">size</span><span class="o">))</span> <span class="o">{</span>
            
            <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">w</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">b</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 2. 만약 현재 파티션이 다른 색으로 이루어졌다면, 4등분한 후 다시 확인한다.</span>
        <span class="kt">int</span> <span class="n">newSize</span> <span class="o">=</span> <span class="n">size</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">;</span>
        <span class="n">recursion</span><span class="o">(</span><span class="n">r</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">newSize</span><span class="o">);</span>
        <span class="n">recursion</span><span class="o">(</span><span class="n">r</span><span class="o">+</span><span class="n">newSize</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">newSize</span><span class="o">);</span>
        <span class="n">recursion</span><span class="o">(</span><span class="n">r</span><span class="o">,</span> <span class="n">c</span><span class="o">+</span><span class="n">newSize</span><span class="o">,</span> <span class="n">newSize</span><span class="o">);</span>
        <span class="n">recursion</span><span class="o">(</span><span class="n">r</span><span class="o">+</span><span class="n">newSize</span><span class="o">,</span> <span class="n">c</span><span class="o">+</span><span class="n">newSize</span><span class="o">,</span> <span class="n">newSize</span><span class="o">);</span>

    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isEquals</span><span class="o">(</span><span class="kt">int</span> <span class="n">r</span><span class="o">,</span> <span class="kt">int</span> <span class="n">c</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="c1">// 색종이의 첫번째 원소</span>
        <span class="kt">int</span> <span class="n">color</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">];</span>

        <span class="c1">// 해당 파티션을 순회하면서 같은 색 여부를 확인하여 결과 반환</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">r</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">r</span><span class="o">+</span><span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">c</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">c</span><span class="o">+</span><span class="n">size</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="n">color</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="c1">// 같은 색이라면 true 반환</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/2630">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[2630번 - 색종이 만들기]]></summary></entry><entry><title type="html">[Java] 백준(실버-5) 11726번 - 2×n 타일링</title><link href="http://localhost:4000/java/226-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-5) 11726번 - 2×n 타일링" /><published>2023-07-17T00:00:00+09:00</published><updated>2023-07-17T00:00:00+09:00</updated><id>http://localhost:4000/java/226-post</id><content type="html" xml:base="http://localhost:4000/java/226-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이 문제는 <strong>동적 계획법(DP)</strong>를 이용해 푼다면 쉽게 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>주어지는 N을 통해 순서대로 패턴을 그려보면 어떤 유형으로 1X2, 2X1의 직사각형을 채울 수 있는지 알 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre><span class="no">N</span> <span class="o">=</span> <span class="mi">1</span>
<span class="mi">2</span><span class="no">X1</span> <span class="n">직사각형</span> <span class="mi">1</span><span class="n">개</span> <span class="n">필요</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="n">가지</span>
<span class="n">총</span> <span class="mi">1</span><span class="n">가지의</span> <span class="n">방법</span>

<span class="no">N</span> <span class="o">=</span> <span class="mi">2</span>
<span class="mi">1</span><span class="no">X2</span> <span class="n">직시각형</span> <span class="mi">2</span><span class="n">개</span> <span class="n">필요</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="n">가지</span>
<span class="mi">2</span><span class="no">X1</span> <span class="n">직사각형</span> <span class="mi">2</span><span class="n">개</span> <span class="n">필요</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="n">가지</span>
<span class="n">총</span> <span class="mi">2</span><span class="n">가지의</span> <span class="n">방법</span>

<span class="no">N</span> <span class="o">=</span> <span class="mi">3</span>
<span class="mi">1</span><span class="no">X2</span> <span class="n">직사각형</span> <span class="mi">3</span><span class="n">개</span> <span class="n">필요</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="n">가지</span>
<span class="mi">1</span><span class="no">X2</span> <span class="n">직사각형</span> <span class="mi">1</span><span class="n">개</span><span class="o">,</span> <span class="mi">2</span><span class="no">X1</span> <span class="n">직사각형</span> <span class="mi">1</span><span class="n">개</span> <span class="n">필요</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="n">가지</span>
<span class="n">총</span> <span class="mi">3</span><span class="n">가지의</span> <span class="n">방법</span>

<span class="no">N</span> <span class="o">=</span> <span class="mi">4</span>
<span class="mi">1</span><span class="no">X2</span> <span class="n">직사각형</span> <span class="mi">4</span><span class="n">개</span> <span class="n">필요</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="n">가지</span>
<span class="mi">2</span><span class="no">X1</span> <span class="n">직사각형</span> <span class="mi">4</span><span class="n">개</span> <span class="n">필요</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="n">가지</span>
<span class="mi">1</span><span class="no">X2</span> <span class="n">직사각형</span> <span class="mi">2</span><span class="n">개</span><span class="o">,</span> <span class="mi">2</span><span class="no">X1</span> <span class="n">직사각형</span> <span class="mi">2</span><span class="n">개</span> <span class="n">필요</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="n">가지</span>
<span class="n">총</span> <span class="mi">5</span><span class="n">가지의</span> <span class="n">방법</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>자 N을 4까지만 대입해보면 두가지의 직사각형으로 만들어낼 수 있는 가짓수의 패턴이 <strong>피보나치 수열과 동일</strong>함을 알 수 있다. <code class="language-plaintext highlighter-rouge">N=5</code>일 때는 당연하게도 8가지의 방법이 필요할 것이다.</p>

<p>그렇다면 피보나치 수열에서 N번째 수를 구하는 것과 동일한 로직으로 문제를 풀면 간단하다. 이를 위한 아이디어는 다음과 같다.</p>

<ul>
  <li>DP를 이용해 피보나치 수열의 N번째 수를 피보나치 함수로 구현한다.</li>
  <li>DP 테이블을 별도로 두고 이미 구한 가짓수라면 바로 반환(메모이제이션)할 수 있도록 구성한다.</li>
</ul>

<blockquote>
  <p>이때, 유의해야 할 점은 문제의 요구사항대로 <code class="language-plaintext highlighter-rouge">방법의 수를 10,007로 나눈 나머지</code>를 출력해야 하므로 <strong>DP 테이블에 가짓수를 갱신할 때 10,007을 나눈 나머지를 저장</strong>해야 한다.</p>
</blockquote>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="no">D</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>

        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="no">D</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 2*1 일때는 1가지의 방법이 있으며, 2*2일 때는 2가지의 방법이 있다.</span>
        <span class="no">D</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="no">D</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">fibo</span><span class="o">(</span><span class="no">N</span><span class="o">);</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="kd">static</span> <span class="kt">int</span> <span class="nf">fibo</span><span class="o">(</span><span class="kt">int</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="n">fibo</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">fibo</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">2</span><span class="o">))</span> <span class="o">%</span> <span class="mi">10007</span> <span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/11726">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[11726번 - 2×n 타일링]]></summary></entry></feed>