<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-03-14T02:12:24+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">lango’s DevLog</title><subtitle>developer</subtitle><author><name>lango</name></author><entry><title type="html">[Java] LeetCode(Easy) - 771. Jewels and Stones</title><link href="http://localhost:4000/java/154-post/" rel="alternate" type="text/html" title="[Java] LeetCode(Easy) - 771. Jewels and Stones" /><published>2023-03-14T00:00:00+09:00</published><updated>2023-03-14T00:00:00+09:00</updated><id>http://localhost:4000/java/154-post</id><content type="html" xml:base="http://localhost:4000/java/154-post/"><![CDATA[<p><br /></p>
<center><img src="/assets/images/leetcode/771_01.png" width="100%" /></center>
<p><br /></p>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />
<p>이번 771번 문제는 단순하다. 문제에서 주어지는 문자열의 길이도 50자 이하이기 때문에 굉장히 관대하다.</p>

<h4 id="아이디어-도출">아이디어 도출</h4>
<ul>
  <li>jewels 문자열을 쪼개어 하나씩 보관한다.</li>
  <li>stones 문자열의 각 문자별로 순회하여 앞서 쪼갠 jewels의 문자가 포함되는지 확인한다.</li>
  <li>jewels에서 쪼갠 문자가 포함될 경우 카운트를 증가시킨다.</li>
</ul>

<p><br /></p>

<p>이번 문제에서 사용한 자료구조는 <code class="language-plaintext highlighter-rouge">ArrayList</code>, <code class="language-plaintext highlighter-rouge">HashMap</code> 2가지와 문자열 순회시 일반 <code class="language-plaintext highlighter-rouge">for문</code>과 <code class="language-plaintext highlighter-rouge">foreach문</code>을 활용하였다.</p>

<h4 id="arraylist와-for문을-활용한-풀이">ArrayList와 for문을 활용한 풀이</h4>
<p>코드가 간단하기 때문에 코드를 먼저 살펴보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numJewelsInStones</span><span class="o">(</span><span class="nc">String</span> <span class="n">jewels</span><span class="o">,</span> <span class="nc">String</span> <span class="n">stones</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">jewels</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">jewels</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">stones</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">stones</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)))</span> <span class="n">cnt</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>jewels 문자열을 쪼개서 담을 ArrayList를 하나 생성하고 카운트를 셀 cnt 변수를 선언한다. <br />
그리고 jewels 각 문자만큼 순회하면서 ArrayList에 담는다. 그러고 stones의 각 문자만큼 순회하면서 ArrayList에 포함된 문자인지 <strong>contains 메소드</strong>로 확인하여 카운트를 세면 된다.</p>

<p><br /></p>

<h4 id="foreach문으로-변경">foreach문으로 변경</h4>
<p>위 코드에서 사용한 for문을 foreach문으로 고쳐보았다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numJewelsInStones</span><span class="o">(</span><span class="nc">String</span> <span class="n">jewels</span><span class="o">,</span> <span class="nc">String</span> <span class="n">stones</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">jewels_arr</span> <span class="o">=</span> <span class="n">jewels</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">stones_arr</span> <span class="o">=</span> <span class="n">stones</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">jewels_arr</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">stones_arr</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">c</span><span class="o">))</span> <span class="n">cnt</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>앞에서 본 코드와 동일한 로직이지만 char 타입 변수로 순회하기 위해 입력 문자열 jewels와 stones를 char형 배열을 만들어 사용한다는 차이점이 있다.</p>

<p><br /></p>

<h4 id="arraylist가-아닌-hashmap-활용">ArrayList가 아닌 HashMap 활용</h4>
<p>마지막으로 ArrayList가 아닌 HashMap으로 풀어보았다. 주어지는 문자열의 길이가 길어진다면 HashMap이 더 유리할 수 있기 때문이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numJewelsInStones</span><span class="o">(</span><span class="nc">String</span> <span class="n">jewels</span><span class="o">,</span> <span class="nc">String</span> <span class="n">stones</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">hm</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">jewels_arr</span> <span class="o">=</span> <span class="n">jewels</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">stones_arr</span> <span class="o">=</span> <span class="n">stones</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">jewels_arr</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">hm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">stones_arr</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">hm</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">c</span><span class="o">))</span> <span class="n">cnt</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>ArrayList와는 다르게 put 메소드로 HashMap에 jewels의 각 문자를 집어넣고 <strong>containsKey 메소드</strong>로 HashMap 포함여부를 확인한다.</p>

<p><br /></p>

<h3 id="실행-시간-차이">실행 시간 차이</h3>
<p>ArrayList보다는 HashMap이 더 빠를 줄 알았으나 오히려 ArrayList가 근소핮디만 더 빠른 시간을 보여주었다.</p>

<h4 id="arraylist">ArrayList</h4>
<p><img src="/assets/images/leetcode/771_02.png" width="8%" /></p>

<h4 id="hashmap">HashMap</h4>
<p><img src="/assets/images/leetcode/771_03.png" width="8%" /></p>

<p>왜 HashMap이 더 느린 시간이 걸렸을까?</p>

<p>이유를 찾아보니, <strong>ArrayList의 경우 내부적으로 배열을 사용</strong>하고 있기 때문에 <strong>contains 메소드는 내부적으로 순차 탐색을 수행</strong>한다. 이 때, 이 문제에서 요구하는 문자열 길이가 짧기 때문에 한번에 비교할 수 있는 원소들이 많다. 그래서 일반적으로 <strong>원소의 개수가 적을 때는 ArrayList의 contains 메소드가 더 빠를 수 있다</strong>고 한다.</p>

<p>반면에, <strong>HashMap의 경우 내부적으로 해시 테이블을 사용</strong>하고 있고, <strong>해시 테이블은 해시 함수를 이용하여 원소를 저장하고 탐색</strong>한다. 이 떄, 문자열 길이가 짧아도 해시 함수를 계산하는 과정이 추가적으로 필요하기 때문에 <strong>ArrayList에 비해 성능이 떨어질 수 있다</strong>고 한다.</p>

<p>하지만, 이는 일반적인 경우이며 상황에 따라 다를 수 있음을 유의해야 한다. 예를 들어, <strong>원소의 개수가 매우 많고 문자열 길이가 짧은 경우에는 HashMap의 containsKey 메소드가 더 빠를 수 있다.</strong></p>

<p>결국 어떤 자료구조를 선택해야 하는지는 문제의 유형 및 데이터의 특성에 따라 달라지기 때문에, 여러 가지 자료구조 성능에 대해서 어느정도 알고 있어야 한다고 느끼게 되었다.</p>

<p><br /><br /></p>

<h3 id="작성-코드---arraylist-및-for문-활용">작성 코드 - ArrayList 및 for문 활용</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numJewelsInStones</span><span class="o">(</span><span class="nc">String</span> <span class="n">jewels</span><span class="o">,</span> <span class="nc">String</span> <span class="n">stones</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">jewels</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">jewels</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">stones</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">stones</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)))</span> <span class="n">cnt</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="작성코드---arraylist-및-foreach문-활용">작성코드 - ArrayList 및 foreach문 활용</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numJewelsInStones</span><span class="o">(</span><span class="nc">String</span> <span class="n">jewels</span><span class="o">,</span> <span class="nc">String</span> <span class="n">stones</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">jewels_arr</span> <span class="o">=</span> <span class="n">jewels</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">stones_arr</span> <span class="o">=</span> <span class="n">stones</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">jewels_arr</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">stones_arr</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">c</span><span class="o">))</span> <span class="n">cnt</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="작성코드---hashmap-및-foreach-활용">작성코드 - HashMap 및 foreach 활용</h3>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">numJewelsInStones</span><span class="o">(</span><span class="nc">String</span> <span class="n">jewels</span><span class="o">,</span> <span class="nc">String</span> <span class="n">stones</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">hm</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">jewels_arr</span> <span class="o">=</span> <span class="n">jewels</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="kt">char</span><span class="o">[]</span> <span class="n">stones_arr</span> <span class="o">=</span> <span class="n">stones</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">jewels_arr</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">hm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">stones_arr</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">hm</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">c</span><span class="o">))</span> <span class="n">cnt</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<ul>
  <li>ArrayList와 HashMap 자료구조의 성능에 대해서 공부할 수 있었고, for문과 foreach문을 사용하는 이유를 알 수 있었다.</li>
</ul>

<h3 id="출처">출처</h3>
<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://leetcode.com/problems/jewels-and-stones/">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[Easy - 771. Jewels and Stones]]></summary></entry><entry><title type="html">[Java] 프로그래머스(level-2) - 괄호 회전하기</title><link href="http://localhost:4000/java/153-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-2) - 괄호 회전하기" /><published>2023-03-08T00:00:00+09:00</published><updated>2023-03-08T00:00:00+09:00</updated><id>http://localhost:4000/java/153-post</id><content type="html" xml:base="http://localhost:4000/java/153-post/"><![CDATA[<p><br /></p>
<center><img src="/assets/images/programmers/20230308_01.png" width="100%" /></center>
<center><img src="/assets/images/programmers/20230308_02.png" width="100%" /></center>
<p><br /></p>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />
<p>이번 <code class="language-plaintext highlighter-rouge">괄호 회전하기</code> 문제는 <strong>괄호를 검증</strong>하는 것이 가장 주요하다고 볼 수 있다. <br />
그런데, 그냥 하나의 소괄호 <code class="language-plaintext highlighter-rouge">()</code>만 검증하는 것이 아니라 중괄호 <code class="language-plaintext highlighter-rouge">{}</code>와 대괄호 <code class="language-plaintext highlighter-rouge">[]</code> 까지 올바른 괄호대로 포함되어 있는지를 확인해야 한다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>
<ul>
  <li>먼저 주어진 괄호 문자열을 왼쪽으로 한 문자씩 문자열 길이만큼 회전시킨다.
    <ul>
      <li>문자열의 길이와 반복문 인덱스를 활용하여 문자열을 회전시킨다.</li>
    </ul>
  </li>
  <li>왼쪽으로 한 문자씩 회전시킨 문자열마다 올바른 괄호 문자열인지를 검증한다.</li>
  <li>주어진 문자열을 회전시켜서 만들어진 문자열마다 올바른 괄호 문자열인지를 세어서 반환하면 된다.</li>
</ul>

<p><br /></p>

<p>아이디어는 이외로 단순하다. 바로 코드를 작성해보자.</p>

<h4 id="문자열-회전시키기">문자열 회전시키기</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">rotate</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>먼저 주어진 문자열 s를 가지고 왼쪽으로 한 문자씩 회전시키기 위해서 <code class="language-plaintext highlighter-rouge">substring()</code> 메소드를 사용한다. <br />
s의 길이만큼 반복하며 <strong>현재 인덱스에서 문자열 길이만큼 자른 뒤, 0번째부터 현재 인덱스까지 자른다면</strong>, 왼쪽으로 하나씩 회전된 문자열을 만들 수 있게 된다.</p>

<blockquote>
  <p><em>예를 들어 <code class="language-plaintext highlighter-rouge">(){}[]</code> 라는 예제를 보면 <code class="language-plaintext highlighter-rouge">){}[](</code>로 회전하기 위해 <code class="language-plaintext highlighter-rouge">){}[]</code>와 <code class="language-plaintext highlighter-rouge">(</code>를 합해서 만들 수 있다.</em></p>
</blockquote>

<h4 id="괄호-검증하기">괄호 검증하기</h4>
<p>이제 앞에서 주어진 문자열을 왼쪽으로 회전시킨 문자열을 구했으니 회전되는 문자열마다 올바른 괄호 문자열인지 확인하면 된다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">rotate</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
    <span class="k">if</span><span class="o">(</span><span class="n">isBracket</span><span class="o">(</span><span class="n">rotate</span><span class="o">))</span> <span class="n">answer</span><span class="o">++;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">isBracket</code>이라는 메소드를 만들어 문자열의 괄호 여부를 boolean으로 받아와 answer를 카운트하도록 구현하였다.</p>

<h4 id="잘못된-괄호-검증">잘못된 괄호 검증</h4>
<p>사실 Stack을 사용하지 않고 Map을 활용해서 괄호를 검증할 수 있을 줄로 알아서, 이를 토대로 괄호 검증 함수를 구현하였다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isBracket</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">bracket_map</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="n">bracket_map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'('</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="n">bracket_map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'['</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="n">bracket_map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'{'</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">char</span> <span class="n">ch</span> <span class="o">:</span> <span class="n">str</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">switch</span><span class="o">(</span><span class="n">ch</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">case</span> <span class="sc">'('</span><span class="o">:</span>
                <span class="n">bracket_map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'('</span><span class="o">,</span> <span class="n">bracket_map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="sc">'('</span><span class="o">,</span> <span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="sc">'{'</span><span class="o">:</span>
                <span class="n">bracket_map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'{'</span><span class="o">,</span> <span class="n">bracket_map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="sc">'{'</span><span class="o">,</span> <span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="sc">'['</span><span class="o">:</span>
                <span class="n">bracket_map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'['</span><span class="o">,</span> <span class="n">bracket_map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="sc">'['</span><span class="o">,</span> <span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="sc">')'</span><span class="o">:</span>
                <span class="k">if</span><span class="o">(</span><span class="n">bracket_map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="sc">'('</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="n">bracket_map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'('</span><span class="o">,</span> <span class="n">bracket_map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="sc">'('</span><span class="o">,</span> <span class="mi">0</span><span class="o">)-</span><span class="mi">1</span><span class="o">);</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="sc">'}'</span><span class="o">:</span>
                <span class="k">if</span><span class="o">(</span><span class="n">bracket_map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="sc">'{'</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="n">bracket_map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'{'</span><span class="o">,</span> <span class="n">bracket_map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="sc">'{'</span><span class="o">,</span> <span class="mi">0</span><span class="o">)-</span><span class="mi">1</span><span class="o">);</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="sc">']'</span><span class="o">:</span>
                <span class="k">if</span><span class="o">(</span><span class="n">bracket_map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="sc">'['</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="n">bracket_map</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="sc">'['</span><span class="o">,</span> <span class="n">bracket_map</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="sc">'['</span><span class="o">,</span> <span class="mi">0</span><span class="o">)-</span><span class="mi">1</span><span class="o">);</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">default</span><span class="o">:</span>
                <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kt">int</span> <span class="n">small</span> <span class="o">=</span> <span class="n">bracket_map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="sc">'('</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">medium</span> <span class="o">=</span> <span class="n">bracket_map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="sc">'{'</span><span class="o">);</span>
    <span class="kt">int</span> <span class="n">big</span> <span class="o">=</span> <span class="n">bracket_map</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="sc">'['</span><span class="o">);</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">small</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">medium</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">big</span> <span class="o">==</span> <span class="mi">0</span><span class="o">);</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>HashMap에 <code class="language-plaintext highlighter-rouge">(</code>, <code class="language-plaintext highlighter-rouge">{</code>, <code class="language-plaintext highlighter-rouge">[</code>를 key로 값은 빈도수로 삽입해서 <strong>열린 괄호가 나올 때는 해당 키의 값을 1씩 증가</strong>시키고 <strong>닫힌 괄호가 나왔을 때는 해당 키의 값을 1씩 감소</strong>시켰다.</p>

<p>그리고 Map에 존재하는 <code class="language-plaintext highlighter-rouge">(</code>, <code class="language-plaintext highlighter-rouge">{</code>, <code class="language-plaintext highlighter-rouge">[</code> key에 대한 값들이 모두 0이라면 열린 괄호와 닫힌 괄호의 짝이 잘 맞으니 true를 반환하게 된다.</p>

<p>해당 메소드를 추가하여 테스트 해보니 정상적으로 예제 테스트케이스들이 통과하였고, 제출을 하였으나 테스트 케이스 14번에서 실패하게 되었다. <br />
이유를 살펴보니, 고려하지 못한 검증 조건이 있다는 것을 깨달았다.</p>

<h4 id="자료구조를-stack으로-수정">자료구조를 Stack으로 수정</h4>
<p>고려히지 못한 검증 조건은 주어진 문자열이 <strong>올바른</strong> 괄호 문자열이냐는 것이다. <br />
예를 들어 <code class="language-plaintext highlighter-rouge">({)}</code> 라는 예제를 보면 <code class="language-plaintext highlighter-rouge">(</code>와 <code class="language-plaintext highlighter-rouge">{</code> 모두 열린 괄호와 닫힌 괄호가 한 쌍씩 존재하지만, 올바른 위치에 배치되어 있지 않다. <br /></p>

<p>열린 괄호 <code class="language-plaintext highlighter-rouge">(</code>가 들어갔으면  닫힌 괄호 <code class="language-plaintext highlighter-rouge">)</code>가 나왔을 때 <code class="language-plaintext highlighter-rouge">(</code>가 나와야 하는데, 내가 짠 Map을 활용한 로직에는 <strong>짝은 맞출 수 있으나 올바른 배치로 이루어진 문자열인지에 대한 검증은 하지 못하고 있었던 것</strong>이다. 결국 Map으로는 이를 구현하기가 어렵다고 느껴져 자료구조를 Stack으로 수정하였다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre><span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">str</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
    <span class="k">switch</span> <span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">case</span> <span class="sc">'('</span><span class="o">:</span> <span class="k">case</span> <span class="sc">'{'</span><span class="o">:</span> <span class="k">case</span> <span class="sc">'['</span><span class="o">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="sc">')'</span><span class="o">:</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">()</span> <span class="o">!=</span> <span class="sc">'('</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="sc">'}'</span><span class="o">:</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">()</span> <span class="o">!=</span> <span class="sc">'{'</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="sc">']'</span><span class="o">:</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">()</span> <span class="o">!=</span> <span class="sc">'['</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="k">return</span> <span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Stack으로 괄호 문자열 검증하는 것은 이전에도 많이 해보아서 굉장히 쉽게 구현해낼 수 있었다. <br />
간단하게 정리하자면 소괄호, 중괄호, 대괄호의 <strong>열린 괄호가 나온다면 스택에 삽입하고 닫힌 괄호가 나올 때는 스택의 맨 위의 괄호와 일치하는 괄호인지를 확인</strong>하면 된다.</p>

<p>이렇게 고친 코드를 제출하니 정상적으로 14번 테스트케이스까지 모든 테스트케이스를 정상적으로 통과하였다.</p>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">rotate</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">())</span> <span class="o">+</span> <span class="n">s</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">isBracket</span><span class="o">(</span><span class="n">rotate</span><span class="o">))</span> <span class="n">answer</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">answer</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isBracket</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Stack</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Stack</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">str</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">switch</span> <span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">case</span> <span class="sc">'('</span><span class="o">:</span> <span class="k">case</span> <span class="sc">'{'</span><span class="o">:</span> <span class="k">case</span> <span class="sc">'['</span><span class="o">:</span>
                    <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="k">case</span> <span class="sc">')'</span><span class="o">:</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">()</span> <span class="o">!=</span> <span class="sc">'('</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="k">case</span> <span class="sc">'}'</span><span class="o">:</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">()</span> <span class="o">!=</span> <span class="sc">'{'</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="k">case</span> <span class="sc">']'</span><span class="o">:</span>
                    <span class="k">if</span> <span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">()</span> <span class="o">!=</span> <span class="sc">'['</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        
        <span class="c1">// String s = "[](){}";</span>
        <span class="c1">// String s = "}]()[{";</span>
        <span class="c1">// String s = "{{{}";</span>
        <span class="c1">// String s = "(){{))";</span>
        <span class="c1">// String s = "(){{]]";</span>
        <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"{(})"</span><span class="o">;</span>
        
        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<ul>
  <li>문자열을 회전시키기 위해 substring() 메소드를 적절히 활용할 수 있었다.</li>
  <li>Stack을 사용하지않고 Map으로도 올바른 괄호 문자열 검증을 할 수 있을 줄 알았지만 마땅히 아이디어가 떠오르지 않아 Stack을 자료구조로 사용하였다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 2 - 괄호 회전하기]]></summary></entry><entry><title type="html">[Java] 2차원 배열 - 달팽이 만들기</title><link href="http://localhost:4000/java/152-post/" rel="alternate" type="text/html" title="[Java] 2차원 배열 - 달팽이 만들기" /><published>2023-03-07T00:00:00+09:00</published><updated>2023-03-07T00:00:00+09:00</updated><id>http://localhost:4000/java/152-post</id><content type="html" xml:base="http://localhost:4000/java/152-post/"><![CDATA[<p><br /></p>

<h3 id="문제">문제</h3>
<hr />
<p>아래 와 같은 형태로 데이터를 저장하는 이차원 배열을 생성하세요.</p>

<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FyD8yH%2FbtqvbObYz0O%2FwxKKf03EbLNSpxpkSKJihk%2Fimg.png" width="50%" /></p>

<p><br />
<br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />
<p>주어진 문제 보기와 같이 달팽이 모양의 2차원 배열을 만들어야 한다. <br />
여기서 배열을 잘 살펴보면, 안쪽으로 말려 들어가는 달팽이 집과 같은 모양을 보이고 있음을 알 수 있다.</p>

<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbcCJsu%2FbtqvbJvcqgU%2FsdaR8KzGdhKEAPUVymHkSK%2Fimg.png" width="50%" /></p>

<p>이 원리를 코드로 구현하기 위한 아이디어를 생각해보자.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>
<p>정사각형 형태의 배열이기에 가로 열과 세로 행은 같다고 보고, 2차원 배열 안에 채워지는 숫자를 어떻게 채워갈지 정해보자.</p>

<ol>
  <li>1부터 5까지는 첫번째 행에 오른쪽으로 채워지며 5부터 9까지는 5번째 열에 아래로 채워진다.</li>
  <li>10부터 13까지는 5번째 행에서 왼쪽으로 채워지며, 13부터 16까지는 1번째 열에서 위로 채워진다.</li>
  <li>16부터 19까지는 2번째 행에서 오른쪽으로 채워지며, 19부터 21까지는 4번째 열에서 아래로 채워진다.</li>
  <li>21부터 23까지는 4번째 행에서 왼쪽으로 채워지며, 23부터 24까지는 2번째 열에서 위로 채워진다.</li>
  <li>마지막으로 24에서 25로 3번째 행에서 채워지게 된다.</li>
</ol>

<p>여기서 총 <strong>5번의 과정</strong>을 통해 1부터 25까지 달팽이 모양으로 2차원 배열을 채우게 되는데 이 5번이라는 것은 정사각형의 행, 열과 동일한 숫자임을 알 수 있다.</p>

<p>이 때, 5번 만큼 배열을 채울 때 일반적인 배열의 순서대로 <strong>오른쪽이나 아래로 채워지는 경우</strong>와, 배열의 순서와는 반대인 <strong>왼쪽이나 위로 채워지는 경우</strong>를 분기하여 채우도록 하면 된다. 그리고 채워질 수는 계속해서 증가시키며 행*열만큼의 수가 되도록 하면 된다.</p>

<h4 id="오른쪽이나-아래로-채워지는-경우">오른쪽이나 아래로 채워지는 경우</h4>
<p>위 <code class="language-plaintext highlighter-rouge">1번</code> 과정과 같이 원래 순서대로 자연스럽게 채워야 하는 경우를 살펴보자. <br />
먼저 열에 값을 오른쪽 방향으로 채운 뒤, 행에 값을 아래 방향으로 아래와 같이 채우게 된다.</p>

<p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbwWAhk%2FbtqvbHD9Zlv%2FNPKqcYw2WgdMKhgFi3sVZk%2Fimg.png" width="30%" /></p>

<p>i가 행 인덱스, j가 열 인덱스라고 한다면 <strong>i는 0행으로 고정시키고, j만 1씩 증가</strong>시켜서 1~5까지 첫 행을 채워주어야 한다. <br />
그리고 첫 행 채우기가 끝나면 <strong>열 인덱스 j를 고정시키고, i만 1씩 증가</strong>하며 채워주어야 한다. <br />
단, 첫 열을 채울 때는 5-1번만큼 반복하여 6부터 9까지만 채우면 된다는 점을 유의해야 한다.</p>

<h4 id="왼쪽이나-위로-채워지는-경우">왼쪽이나 위로 채워지는 경우</h4>
<p>1번 과정대로 배열을 채웠다면 10부터 13까지, 14부터 16까지는 반대 방향으로 배열을 채워야 한다. <br />
이 때는 열 인덱스인 j를 1씩 감소시켜서 채워야 하기 때문에 <strong>방향을 반대로 바꿔줄 변수</strong>가 하나 있어야 한다.</p>

<p><br /></p>

<p>문제 예시처럼 가로 5, 세로 5 크기를 가지는 정사각형을 채우려면 위 과정을 5번 반복하여 달팽이 배열을 채울 수 있게 된다. <br />
아이디어가 생각보다 복잡해보이지만 필자가 장황하게 늘어놓은 점도 없지 않기에 코드를 작성하면서 이해하는 것이 더 쉬울 수 있다.</p>

<p>자 그럼 이제 코드를 작성해보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="kt">int</span><span class="o">[][]</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">col</span><span class="o">][</span><span class="n">row</span><span class="o">];</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1">// row start index</span>
<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="c1">// col start index</span>
<span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// snail number</span>
<span class="kt">int</span> <span class="n">direction</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// i with j switch direction(1 or -1)</span>
<span class="kt">int</span> <span class="n">repeat</span> <span class="o">=</span> <span class="n">row</span><span class="o">;</span> <span class="c1">// repeat count</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>달팽이 모양대로 채워줄 2차원 배열 answr를 선언한다.
그리고 i는 행 인덱스, j는 열 인덱스를 의미하고 tmp는 각 배열에 채워줄 숫자 값이 된다.</p>

<blockquote>
  <p><em>j가 -1부터 시작하는 이유는, 행을 고정하고 열을 증가시키며 배열에 채워줄 때 배열의 범위를 벗어나지 않도록 하기 위함이다.</em></p>
</blockquote>

<p>direction 변수는 <strong>방향이 바뀔 시 사용될 스위치 변수</strong>이며, repeat는 몇 번을 반복해야 하는지를 알려주는 <code class="language-plaintext highlighter-rouge">반복 인덱스</code>라고 보면 된다.</p>

<blockquote>
  <p><em>여기서는 정사각형이기 때문에 행과 열의 크기가 같기에 둘 중 아무거나 repeat로 선언해도 무방하다.</em></p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="k">while</span><span class="o">(</span><span class="n">repeat</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>기본적으로 repeat가 0이 될 때까지 반복하면 된다. 문제 예시대로라면 5번을 반복하게 된다. <br />
while문에서 2차원 배열을 채우는 반복문을 작성해주면 되며, while문의 <strong>탈출 조건은 반복 인덱스인 repeat가 0과 작거나 같아지는 순간</strong>이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">l</span><span class="o">&lt;</span><span class="n">repeat</span><span class="o">;</span> <span class="n">l</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">tmp</span><span class="o">++;</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="n">direction</span><span class="o">;</span>
    <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
<span class="o">}</span>
<span class="n">repeat</span><span class="o">--;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>앞에서 구상한 아이디어대로 행 인덱스인 i를 고정해둔 채 j를 1씩 증가시키며 첫 행을 1부터 채워준다. <br />
이 때, 열을 고정시키고 행을 증가시켜야 하는데 행의 첫번째 값은 이전에 채워졌으므로, 채워진 값 이후로 배열을 채우기 위해 repeat 변수를 1 감소시킨다.</p>

<blockquote>
  <p>1부터 5까지 5번을 반복하며 첫 행에 채워진다.</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">m</span><span class="o">&lt;</span><span class="n">repeat</span><span class="o">;</span> <span class="n">m</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">tmp</span><span class="o">++;</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">direction</span><span class="o">;</span>
    <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
    
<span class="o">}</span>
<span class="n">direction</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>다음으로는 행 인덱스만 변경하며 배열을 채워주어야 하기 때문에 j를 고정해둔 채 행 인덱스인 i를 1씩 증가시키며 열 값을 채워준다.</p>

<blockquote>
  <p>6부터 9까지 4번을 반복하며 마지막 열에 채워진다.</p>
</blockquote>

<p>이제 다시 배열의 행부터 값을 채워야 하는데 <strong>왼쪽이나 위 방향인 반대로 채워야 하기 때문에 열 인덱스인 j를 1씩 감소</strong>시켜야 한다.
그래서 선언해둔 스위치 변수인 <strong>direction을 -1로 바꾸어주면</strong> 된다.</p>

<p><br /></p>

<p>이렇게 while문 안에서 두가지의 반복 과정을 진행하며 repeat 반복 변수가 0 이하가 된다면 while문을 종료된다.</p>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">col</span><span class="o">][</span><span class="n">row</span><span class="o">];</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// row start index</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="c1">// col start index</span>
        <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="c1">// snail number</span>
        <span class="kt">int</span> <span class="n">direction</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="c1">// i with j switch direction(1 or -1)</span>
        <span class="kt">int</span> <span class="n">repeat</span> <span class="o">=</span> <span class="n">row</span><span class="o">;</span> <span class="c1">// repeat count</span>

        <span class="k">while</span><span class="o">(</span><span class="n">repeat</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">l</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">l</span><span class="o">&lt;</span><span class="n">repeat</span><span class="o">;</span> <span class="n">l</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">tmp</span><span class="o">++;</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="n">direction</span><span class="o">;</span>
                <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">repeat</span><span class="o">--;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">m</span><span class="o">&lt;</span><span class="n">repeat</span><span class="o">;</span> <span class="n">m</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">tmp</span><span class="o">++;</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">direction</span><span class="o">;</span>
                <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">;</span>
                
            <span class="o">}</span>
            <span class="n">direction</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">:</span> <span class="n">answer</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">arr</span><span class="o">));</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="n">col</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<ul>
  <li>행과 열을 탐색하는 순서를 전환하기 위해 양수와 음수를 이용할 수 있었고, 열을 고정시키고 행을 1씩 증가시켜서 열 값을 채워주고 행을 고정시키고 열 값을 1씩 증가시켜서 행 값을 채워줄 수 있었다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[2차원 배열 응용 - 달팽이 만들기]]></summary></entry><entry><title type="html">[Java] LeetCode(Easy) - 819. Most Common Word</title><link href="http://localhost:4000/java/151-post/" rel="alternate" type="text/html" title="[Java] LeetCode(Easy) - 819. Most Common Word" /><published>2023-03-06T00:00:00+09:00</published><updated>2023-03-06T00:00:00+09:00</updated><id>http://localhost:4000/java/151-post</id><content type="html" xml:base="http://localhost:4000/java/151-post/"><![CDATA[<p><br /></p>
<center><img src="/assets/images/leetcode/819_01.png" width="100%" /></center>
<center><img src="/assets/images/leetcode/819_02.png" width="100%" /></center>
<p><br /></p>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />
<p>이번 819번 문제는 <code class="language-plaintext highlighter-rouge">Most Common Word</code>, 즉 가장 흔한 단어를 찾는 문제이다. <br />
문제 풀이의 핵심은 <strong>정규식 및 Map</strong>을 활용하는 것이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>
<p>문제 그대로 주어진 문자열을 토대로 빈도수가 많은 단어를 반환하면 되는데, 먼저 문제에서 요구하는 <strong>특정 문자열을 필터링</strong>하여 단어 배열을 만드는 것이 중요하다. <br /></p>

<ul>
  <li>단어별로 빈도수를 담기 위해 Map을 사용한다.</li>
  <li>주어진 단어의 빈도수를 세기 위해서 문자열을 소문자로 변환한다.</li>
  <li>문자열에서 주어진 단락을 기준으로 단어 배열을 만든다.
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">!</code>, <code class="language-plaintext highlighter-rouge">?</code>, <code class="language-plaintext highlighter-rouge">'</code>, <code class="language-plaintext highlighter-rouge">,</code>, <code class="language-plaintext highlighter-rouge">;</code>, <code class="language-plaintext highlighter-rouge">.</code>라는 문자들과 공백 문자인 ` ` 까지</strong> 포함시켜 잘라야 한다.</li>
    </ul>
  </li>
  <li>단어 배열을 만들었다면, 해당 단어 배열을 순회하면서 단어들의 빈도수를 세어 Map에 담는다.
    <ul>
      <li>이 때, <strong>banned 배열에 포함된 단어라면 카운트를 세지 않도록</strong> 한다.</li>
    </ul>
  </li>
  <li>단어들의 빈도수를 담은 Map에서 가장 많은 빈도수를 가진 단어를 찾으면 된다.</li>
</ul>

<p><br /></p>

<p>이제 아이디어를 토대로 코드를 작성해보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="nc">String</span><span class="o">[]</span> <span class="n">words</span> <span class="o">=</span> <span class="n">paragraph</span><span class="o">.</span><span class="na">toLowerCase</span><span class="o">().</span><span class="na">split</span><span class="o">(</span><span class="s">"[!?,;'\\.\\s]+"</span><span class="o">);</span>
<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
<span class="nc">String</span> <span class="n">answer</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>먼저 주어진 paragraph 문자열을 소문자로 변환하고 공백 문자 및 문제에서 요구하는 문자를 기준으로 단어를 구분하기 위해 정규식을 활용하였다. <br /></p>

<h4 id="단락-필터링을-위한-정규식">단락 필터링을 위한 정규식</h4>
<p>문제에서 요구하는 <code class="language-plaintext highlighter-rouge">!</code>, <code class="language-plaintext highlighter-rouge">?</code>, <code class="language-plaintext highlighter-rouge">'</code>, <code class="language-plaintext highlighter-rouge">,</code>, <code class="language-plaintext highlighter-rouge">;</code>, <code class="language-plaintext highlighter-rouge">.</code>라는 문자들과 공백 문자인 ` ` 문자를 기준으로 자르기 위해서는 어떻게 해야할까? <br />
바로 정규식을 이용하여 손쉽게 해당 문자를 기준으로 문자열을 구분할 수 있도록 할 수 있다.</p>

<p>사용한 정규식을 살펴보면 <code class="language-plaintext highlighter-rouge">String[] words = paragraph.toLowerCase().split("[!?,;'\\.\\s]+");</code> 과 같다.
이 떄 <code class="language-plaintext highlighter-rouge">.</code>과 ` ` 공백문자에 정규식 안에 \를 사용하여 .와 \s를 이스케이프(escape) 처리해 주었다.</p>

<p>이 정규식은 <code class="language-plaintext highlighter-rouge">!</code>, <code class="language-plaintext highlighter-rouge">?</code>, <code class="language-plaintext highlighter-rouge">'</code>, <code class="language-plaintext highlighter-rouge">,</code>, <code class="language-plaintext highlighter-rouge">;</code>, <code class="language-plaintext highlighter-rouge">.</code> 문자와 공백문자 ` `를 구분자로 사용한다는 것을 의미한다. <br /></p>

<blockquote>
  <p><em>여기서 <strong>[]는 문자 클래스</strong>를 나타내며, 안에 들어가는 문자들 중 <strong>하나라도 매치되면 분리 기준으로 사용</strong>하겠다는 뜻이다. 또한 <strong>+는 해당 문자들이 하나 이상 연속으로 나타날 때 매치되는 것을 의미</strong>한다.</em></p>
</blockquote>

<p>아무튼, 위와 같이 정규식을 활용하여 특정 단락에 속하는 문자를 기준으로 구분하여 split 메소드를 이용해 문자로 잘라서 배열로 만들 수 있었다. <br />
다음으로 문자를 key로 문자들의 빈도수를 value로 담을 count HashMap을 하나 생성하고 가장 많은 빈도수를 보인 단어를 반환할 String 변수 answer를 null로 초기화한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span> <span class="o">:</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Boolean</span> <span class="n">possiable</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="n">ban</span> <span class="o">:</span> <span class="n">banned</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">word</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">ban</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">possiable</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">if</span><span class="o">(</span><span class="n">possiable</span><span class="o">)</span> <span class="n">count</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">count</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>이제 구분해낸 소문자 단어들을 순회하며 빈도수를 세도록 하자. <br />
이 때, 해당 단어가 금지어라면 카운트를 할 필요가 없다. 그렇기에 <strong>Boolean 변수를 하나 두어서 이중 for문으로 해당 단어가 금지어인지를 확인</strong>하면 된다.</p>

<p>만약 금지어라면 카운트를 셀 필요가 없기 때문에 <code class="language-plaintext highlighter-rouge">break;</code>로 이중 for문을 탈출하면 된다. 그리고 Boolean 변수가 false이기 때문에 count HashMap에 넣지 않는다. <br />
만약 금지어가 아니라면 카운트를 세야 하기 때문에 count HashMap에 해당 단어 문자를 key 값으로, 빈도수를 <strong>getOrDefault로</strong> 찾아와서 value 값으로 삽입한다.</p>

<p>그러면 구분해낸 단어들의 빈도수가 count HashMap에 온전히 담길 것이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span> <span class="o">:</span> <span class="n">count</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">answer</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">answer</span><span class="o">))</span> <span class="n">answer</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>마지막으로 count를 가지고 가장 많은 빈도수를 보인 단어를 찾으면 된다. <br />
가장 많은 value를 가진 key값을 구하면 되기 때문에 count를 순회하면서 answer에 최대 value를 가지는 값을 담으면 된다.</p>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">mostCommonWord</span><span class="o">(</span><span class="nc">String</span> <span class="n">paragraph</span><span class="o">,</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">banned</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">words</span> <span class="o">=</span> <span class="n">paragraph</span><span class="o">.</span><span class="na">toLowerCase</span><span class="o">().</span><span class="na">split</span><span class="o">(</span><span class="s">"[!?,;'\\.\\s]+"</span><span class="o">);</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="nc">String</span> <span class="n">answer</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="n">w</span> <span class="o">:</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">word</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="na">replace</span><span class="o">(</span><span class="s">"\\W"</span><span class="o">,</span> <span class="s">""</span><span class="o">);</span>
            <span class="nc">Boolean</span> <span class="n">possiable</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="n">ban</span> <span class="o">:</span> <span class="n">banned</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">word</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">ban</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">possiable</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">possiable</span><span class="o">)</span> <span class="n">count</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">count</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="nc">String</span> <span class="n">key</span> <span class="o">:</span> <span class="n">count</span><span class="o">.</span><span class="na">keySet</span><span class="o">())</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">answer</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">count</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">answer</span><span class="o">))</span> <span class="n">answer</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">answer</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<ul>
  <li>정규식을 이용하여 문자열을 원하는 패턴으로 구분할 수 있었다. 앞으로 문자열 치환이 필요할 경우 항상 정규식을 이용할 수 있는지 확인해보자.</li>
</ul>

<h3 id="출처">출처</h3>
<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://leetcode.com/problems/most-common-word/">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[Easy - 819. Most Common Word]]></summary></entry><entry><title type="html">[Java] 프로그래머스(level-2) - 주식 가격</title><link href="http://localhost:4000/java/150-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-2) - 주식 가격" /><published>2023-03-05T00:00:00+09:00</published><updated>2023-03-05T00:00:00+09:00</updated><id>http://localhost:4000/java/150-post</id><content type="html" xml:base="http://localhost:4000/java/150-post/"><![CDATA[<p><br /></p>
<center><img src="/assets/images/programmers/20230305_01.png" width="100%" /></center>
<p><br /></p>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />
<p>이번 <code class="language-plaintext highlighter-rouge">주식 가격</code> 문제는 필자의 가독성이 부족한 것인지, 도저히 지문 자체가 이해가 안되어 지문을 이해하는 것이 더 어려웠다. <br />
이 때, 다른 분의 지문 해석 글이 지문을 이해하는데 큰 도움이 되었기 때문에 해당 <a href="https://school.programmers.co.kr/questions/20326?question=20326">링크</a>를 공유한다.</p>

<p>해당 글에서는 아래와 같이 지문을 이해하기 쉽게 알려주었다.</p>

<p><br /></p>

<p><strong>문제설명</strong> <br />
n초 간의 주가를 초 단위로 기록한 배열 prices가 매개변수로 주어질 때, 각 초의 주가를 기준으로 해당 초 부터 n초 사이에 가격이 떨어지지 않은 시간은 몇 초인지 배열에 담아 return 하도록 solution 함수를 완성하세요.</p>

<p><strong>제한사항</strong> <br />
prices의 각 가격은 1 이상 10,000 이하인 자연수입니다. <br />
prices의 길이 n은 2 이상 100,000 이하입니다. (2 &lt;= n &lt;= 100,000)</p>

<p><strong>입출력 예</strong> <br /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>prices : [1, 2, 3, 2, 3]
return : [4, 3, 1, 1, 0]
</pre></td></tr></tbody></table></code></pre></div></div>

<p><strong>입출력 예 설명</strong> <br /></p>
<ul>
  <li>1초의 주가는 1이며 1초부터 5초까지 총 4초간 주가를 유지했습니다.</li>
  <li>2초의 주가는 2이며 2초부터 5초까지 총 3초간 주가를 유지했습니다.</li>
  <li>3초의 주가는 3이며 4초의 주가는 2로 주가가 떨어졌지만 3초에서 4초가 되기 직전까지의 1초간 주가가 유지 된것으로 봅니다. 따라서 5초까지 총 1초간 주가를 유지했습니다.</li>
  <li>4초의 주가는 2이며 4초부터 5초까지 총 1초간 주가를 유지했습니다.</li>
  <li>5초의 주가는 3이며 5초 이후로는 데이터가 없으므로 총 0초간 주가를 유지했습니다.</li>
</ul>

<p><br /></p>

<h4 id="문제에-활용할-자료구조">문제에 활용할 자료구조</h4>
<p>위에서 살펴본 지문을 통해 이해한 후에는 새로운 의문점이 생겼다. 바로 해당 문제의 유형이 <code class="language-plaintext highlighter-rouge">스택/큐</code> 문제로 지정되어 있었다는 것이다.<br />
굳이 큐를 활용해서 peek한 원소와 나머지 원소를 비교해가며 할 수는 있겠지만 필자는 그냥 단순하게 배열을 활용하는 것이 좋을 것 같아 배열을 활용하여 풀었다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>
<p>지문을 잘 이해했다면 문제의 솔루션을 찾는 건 생각보다 쉽다.</p>

<ul>
  <li>주어진 prices의 길이를 통해 1초부터 N초까지 각 원소의 정수값을 유지하고 있는지를 줌점으로 보면 된다.</li>
  <li>prices의 원소를 순회하며 중첩 for문을 통해 <strong>해당 원소와 다음 원소와의 증감 여부를 비교</strong>하면 된다.
    <ul>
      <li>이 때, <strong>현재 원소가 다음 원소보다 작으면 주식 가격이 올라가는 중</strong>이기 때문에 또 다음 원소와 비교할 수 있도록 1초씩 증가시키고 다음 순회로 넘기면 된다.</li>
      <li>만약 현재 원소가 다음 원소보다 크다면, 즉 주식 가격이 하락했다면 <strong>하락되기 직전까지의 1초간은 주가가 유지된 것</strong>으로 보기 때문에 1초를 포함한 후 해당 순회를 멈춘다.</li>
    </ul>
  </li>
  <li>위 과정을 반복하며 prices의 각 원소마다 중첩 for문을 통해 구한 주식가격 유지시간 값을 반환할 배열에 담으면 된다.</li>
</ul>

<p><br /></p>

<p>생각해낸 아이디어는 복잡할 수 있지만, 앞서 말했듯이 지문을 잘 이해했다면 간단할 수 있다. <br />
그럼 바로 코드를 작성해보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre><span class="kt">int</span><span class="o">[]</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>먼저 prices의 길이만큼 그대로 반환할 것이니 answer 배열을 prices의 길이와 동일하게 선언하자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">term</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">prices</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="n">term</span><span class="o">++;</span>
        <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">prices</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">term</span><span class="o">++;</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">term</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>주어진 prices를 통해 1초부터 [prices.length]초까지 가격이 떨어지지 않은 시간은 몇 초인지를 구하기 위한 로직은 다음과 같다.</p>

<ol>
  <li>중첩 for문을 통해 prices의 해당 원소와 다음 원소들을 순회하며 비교한다.</li>
  <li>이 때, 각 원소마다 몇 초만큼인지를 구할 term 변수를 선언한다.</li>
  <li>현재 원소(가격)가 다음 원소보다 작으면 주가가 상승하고 있다는 것이기에 term을 1 증가시키고 다음 원소를 순회하도록 한다.</li>
  <li>만약, 현재 원소(가격)가 다음 원소보다 크다면 주가가 하락했다는 것이기에 term을 1 증가시킨 후, <strong>현재 순회에서 멈추고 1초 뒤의 주가를 비교하도록</strong> 한다.</li>
  <li>그 밖의 상황일 경우 쓸데없이 이중 for문을 순회할 필요가 없기 때문에 순회를 종료시킨다.</li>
</ol>

<blockquote>
  <p><em>중첩 for문에서 j를 <code class="language-plaintext highlighter-rouge">i+1</code>부터 순회하도록 구현한 이유는 <strong>같은 원소끼리는 비교할 필요가 없기 때문</strong>이다.</em></p>
</blockquote>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span><span class="o">)</span> <span class="o">{</span>

        <span class="kt">int</span><span class="o">[]</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">term</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">prices</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">prices</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="n">term</span><span class="o">++;</span>
                <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">prices</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">prices</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
                    <span class="n">term</span><span class="o">++;</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">else</span> <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">term</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">prices</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">};</span>
        <span class="c1">// int[] prices = new int[]{5,4,3,2,5};</span>
        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">prices</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<ul>
  <li>중첩 for문 내에서 특정 조건에서는 순회를 이어가고, 특정 조건에서는 순회를 멈추도록 하는 로직을 통해 스택이나 큐를 활용하지 않고도 해당 문제를 풀 수 있었다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 2 - 주식 가격]]></summary></entry><entry><title type="html">[Java] 프로그래머스(level-1) - 기사단원의 무기</title><link href="http://localhost:4000/java/149-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-1) - 기사단원의 무기" /><published>2023-03-03T00:00:00+09:00</published><updated>2023-03-03T00:00:00+09:00</updated><id>http://localhost:4000/java/149-post</id><content type="html" xml:base="http://localhost:4000/java/149-post/"><![CDATA[<p><br /></p>
<center><img src="/assets/images/programmers/20230303_01.png" width="100%" /></center>
<center><img src="/assets/images/programmers/20230303_02.png" width="100%" /></center>
<p><br /></p>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />
<p>이번 <code class="language-plaintext highlighter-rouge">기사단원의 무기</code> 문제는 전반적인 구현까지의 과정은 단순하나 중간에 필요한 <strong>약수 개수를 구하는 알고리즘</strong>을 잘 구성해야 한다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>
<ul>
  <li>주어진 number 만큼 1부터 number까지 배열로 만든다.</li>
  <li>위에서 만든 배열을 순회하면서 각 요소마다 <strong>약수의 개수</strong>를 구하고 이를 공격력으로 칭한 변수에 담는다.
    <ul>
      <li>약수의 개수를 구하는 로직을 <strong>별도의 함수에서 수행</strong>한다.</li>
    </ul>
  </li>
  <li>구한 공격력(약수의 개수)가 limit보다 크다면, power로 대체한다.</li>
  <li>마지막으로 모든 공격력의 누적합을 구하면 요구하는 철의 무게가 된다.</li>
</ul>

<p><br /></p>

<p>아이디어 자체는 간단하니 바로 코드를 작성해보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">knights</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">number</span><span class="o">];</span>

<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">number</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">knights</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>먼저 모든 기사단원의 공격력을 합해 철의무게를 반환할 answer 변수와 주어진 number 만큼의 크기를 가질 knights 배열을 선언한다. <br />
그리고 1부터 number까지의 수로 knights 배열을 초기화한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">knights</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">atk</span> <span class="o">=</span> <span class="n">divisor</span><span class="o">(</span><span class="n">knights</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
    <span class="k">if</span><span class="o">(</span><span class="n">atk</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="o">)</span> <span class="n">atk</span> <span class="o">=</span> <span class="n">power</span><span class="o">;</span>
    <span class="n">answer</span> <span class="o">+=</span> <span class="n">atk</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>그리고 knights 배열을 순회하면서 각 요소마다 atk이라는 변수에 약수의 개수를 구해서 담는다. <br />
이 때, 구한 atk가 limit보다 크다면 power로 대체시키면 된다.</p>

<p>이렇게 구한 atk들의 누적합을 구한다면 요구하는 철의 무게를 구할 수 있다. <br />
그런데 아이디어 자체는 크게 문제가 없어보였지만, 약수의 개수를 구할 때 <strong>시간초과 문제가 발생</strong>하게 되었다.</p>

<p><br /></p>

<h4 id="일반적으로-약수의-개수-구하기">일반적으로 약수의 개수 구하기</h4>
<p>알고보니 아무 생각없이 작성했던 약수를 구하는 로직 자체가 문제였다. <br />
number의 수가 커질수록 그만큼 반복문이 돌아야 하기 때문에 시간적으로 매우 비효율적이라는 것을 알 수 있었다. <br /></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="c1">// 일반적인 약수를 구하는 방법</span>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++){</span>
    <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">cnt</span><span class="o">++;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>문제의 제한사항을 살펴보니 다음과 같았다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">1 ≤ number ≤ 100,000</code></li>
  <li><code class="language-plaintext highlighter-rouge">2 ≤ limit ≤ 100</code></li>
  <li><code class="language-plaintext highlighter-rouge">1 ≤ power ≤ limit</code></li>
</ul>

<p>number가 최대 십만까지 주어질 수 있기에 그만큼 배열의 길이가 늘어날테니 이를 고려하기 위해서는 결국 약수를 구하는 로직의 시간을 줄여야 한다.</p>

<p><br /></p>

<h4 id="약수의-개수를-보다-효율적으로-구하기">약수의 개수를 보다 효율적으로 구하기</h4>
<p>앞에서 약수를 구할 때 발생한 시간초과 해결을 위해 약수 개수 구하는 알고리즘 수정해야 했다.</p>

<p>만약 n의 약수가 1일 때 다른 약수는 n/1이 되므로 다른 하나의 약수는 number가 된다. <br />
이 때, n의 약수 중 하나를 i라고 한다면, 다른 약수는 <strong>n/i 가 되므로 하나의 약수를 알면 다른 하나의 약수의 존재가 보장</strong>된다.</p>

<p>이를 코드로 표현하면 다음과 같다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="o">==</span> <span class="n">n</span><span class="o">)</span> <span class="n">cnt</span><span class="o">++;</span>
    <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">cnt</span><span class="o">+=</span><span class="mi">2</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>우선, for 루프에서 i는 1부터 n의 제곱근까지 증가시킨다. 그 이유는 <strong>n의 제곱근 이후의 값에서는 n을 나누어 떨어지는 수가 나오지 않기 때문</strong>이다. <br />
예를 들자면, n이 16이라면 4 이후의 값에서는 16을 나누어 떨어지게 하는 수가 없는 것과 같다.</p>

<p>다음으로, i * i 가 n과 같으면, i는 n의 약수이기 때문에 cnt 변수를 1만큼 증가시킨다. <br />
그런데, 만약 i * i 가 n과 같지 않으면서 n을 i로 나누어 떨어지게 하는 경우, <strong>i와 n/i 둘 다 n의 약수인 것으로 보고 cnt 변수를 2만큼 증가</strong>시키면 된다.</p>

<p><br /></p>

<p>이처럼 약수의 개수를 구하는 알고리즘 n의 제곱근을 황용하여 효율적으로 수정할 수 있었고, 정상적으로 테스트케이스를 모두 통과할 수 있었다.</p>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">number</span><span class="o">,</span> <span class="kt">int</span> <span class="n">limit</span><span class="o">,</span> <span class="kt">int</span> <span class="n">power</span><span class="o">)</span> <span class="o">{</span>

        <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">knights</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">number</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">number</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">knights</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">knights</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">atk</span> <span class="o">=</span> <span class="n">divisor</span><span class="o">(</span><span class="n">knights</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">atk</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="o">)</span> <span class="n">atk</span> <span class="o">=</span> <span class="n">power</span><span class="o">;</span>
            <span class="n">answer</span> <span class="o">+=</span> <span class="n">atk</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">divisor</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="o">==</span> <span class="n">n</span><span class="o">)</span> <span class="n">cnt</span><span class="o">++;</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">cnt</span><span class="o">+=</span><span class="mi">2</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="mi">3</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">power</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">number</span><span class="o">,</span> <span class="n">limit</span><span class="o">,</span> <span class="n">power</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<ul>
  <li>약수의 개수를 구하는 알고리즘에 대해서 다시 한번 생각해보고 고민하여 약수를 구할 수의 제곱근을 황용하여 보다 효율적인 방법으로 약수의 개수를 구할 수 있었다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 1 - 기사단원의 무기]]></summary></entry><entry><title type="html">[Java] 백준(브론즈-2) 10811번 - 바구니 뒤집기</title><link href="http://localhost:4000/java/148-post/" rel="alternate" type="text/html" title="[Java] 백준(브론즈-2) 10811번 - 바구니 뒤집기" /><published>2023-03-02T00:00:00+09:00</published><updated>2023-03-02T00:00:00+09:00</updated><id>http://localhost:4000/java/148-post</id><content type="html" xml:base="http://localhost:4000/java/148-post/"><![CDATA[<p><br /></p>

<center><img src="/assets/images/baekjoon/10811.png" width="100%" /></center>

<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />
<p>이번 <code class="language-plaintext highlighter-rouge">바구니 뒤집기</code> 문제는 배열의 일정 인덱스의 범위만큼을 담아둘 <strong>임시 배열</strong>을 활용하여 풀 수 있었다.</p>

<h4 id="아이디어-도출">아이디어 도출</h4>
<p>N만큼의 길이를 가지는 원본 배열에서 주어지는 <strong>i와 j만큼의 범위만큼을 잘라서 역순으로 담은 임시배열을 원본 배열에 덮어씌우는 방식</strong>을 적용하였다.</p>

<ul>
  <li>N과 M을 입력받고 N만큼의 길이를 가지는 배열을 생성한 뒤 1부터 N까지의 값으로 초기화한다.</li>
  <li>M만큼 반복하면서 i와 j를 입력받고, i와 j의 인덱스의 범위를 가지는 임시배열을 초기화 한다.
    <ul>
      <li>여기서 임시배열의 크기는 <code class="language-plaintext highlighter-rouge">j-i+1</code>만큼을 가져야 한다.</li>
    </ul>
  </li>
  <li>원본 배열을 역순으로 임시배열에 담기 위해 j부터 i까지 역순으로 순회하면서 j-i의 인덱스 범위만큼 역순으로 임시배열에 담는다.</li>
  <li>특정 범위만큼 역순으로 담긴 임시배열이 만들어졌다면 원본배열에 해당되는 범위에 임시배열의 값을 덮어씌운다.</li>
</ul>

<p><br /></p>

<p>아이디어를 말로 설명하자니 조금 복잡할 수 있다. <br />
바로 코드를 작성해보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
<span class="kt">int</span> <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>

<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>N과 M을 공백 기준으로 입력받은 후, N의 크기를 가지는 arr 배열을 선언하고 1부터 N까지의 값으로 초기화한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre><span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">idx</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">idx</span><span class="o">&lt;</span><span class="no">M</span><span class="o">;</span> <span class="n">idx</span><span class="o">++)</span> <span class="o">{</span>
    <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">())</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">())</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

    <span class="kt">int</span><span class="o">[]</span> <span class="n">tmp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
    <span class="kt">int</span> <span class="n">ridx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">r</span><span class="o">=</span><span class="n">j</span><span class="o">;</span> <span class="n">r</span><span class="o">&gt;=</span><span class="n">i</span><span class="o">;</span> <span class="n">r</span><span class="o">--)</span> <span class="o">{</span>
        <span class="n">tmp</span><span class="o">[</span><span class="n">ridx</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">r</span><span class="o">];</span>
        <span class="n">ridx</span><span class="o">++;</span>
    <span class="o">}</span>
    <span class="n">ridx</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">:</span> <span class="n">tmp</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">arr</span><span class="o">[</span><span class="n">ridx</span><span class="o">]</span> <span class="o">=</span> <span class="n">r</span><span class="o">;</span>
        <span class="n">ridx</span><span class="o">++;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>M만큼 반복하면서 앞서 말했던 임시배열을 원본배열에 덮어씌우는 로직을 수행한다.</p>

<ol>
  <li>i부터 j까지의 범위를 역순으로 담을 임시배열 tmp를 생성한다. 이 떄, tmp는 <code class="language-plaintext highlighter-rouge">j-i+1</code>의 크기를 가져야 해당 범위만큼 역순으로 담을 수 있게 된다.</li>
  <li>원본배열의 역순으로 접근한 특정 범위의 값들을 tmp 배열에 순차적으로 담기 위해 <strong>ridx라는 인덱스를 별도로 선언</strong>한다.</li>
  <li>임시 배열에 원본배열의 특정 범위를 역순으로 삽입한다.</li>
  <li>원본배열에 특정 범위에 임시배열을 덮어씌우기 위해 <strong>ridx를 i번째 인덱스 값으로 설정</strong>한다.</li>
  <li>임시배열을 순회하면서 원본배열에 임시배열 값을 삽입하여 덮어씌운다.</li>
</ol>

<p><br /><br /></p>

<h3 id="작성코드">작성코드</h3>
<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.BufferedReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.BufferedWriter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.IOException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.InputStreamReader</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.io.OutputStreamWriter</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Arrays</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.StringTokenizer</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="kt">int</span> <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">idx</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">idx</span><span class="o">&lt;</span><span class="no">M</span><span class="o">;</span> <span class="n">idx</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">())</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">())</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>

            <span class="kt">int</span><span class="o">[]</span> <span class="n">tmp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">j</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">ridx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">r</span><span class="o">=</span><span class="n">j</span><span class="o">;</span> <span class="n">r</span><span class="o">&gt;=</span><span class="n">i</span><span class="o">;</span> <span class="n">r</span><span class="o">--)</span> <span class="o">{</span>
                <span class="n">tmp</span><span class="o">[</span><span class="n">ridx</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">r</span><span class="o">];</span>
                <span class="n">ridx</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="n">ridx</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">r</span> <span class="o">:</span> <span class="n">tmp</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">arr</span><span class="o">[</span><span class="n">ridx</span><span class="o">]</span> <span class="o">=</span> <span class="n">r</span><span class="o">;</span>
                <span class="n">ridx</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">res</span> <span class="o">:</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">res</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
        <span class="o">}</span>
               
        <span class="n">bw</span><span class="o">.</span><span class="na">flush</span><span class="o">();</span>
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<ul>
  <li>배열의 특정 범위의 값을 역순으로 만들어 저장하기 위해 임시 배열을 별도로 만들어 덮어씌우는 방식을 생각해낼 수 있었다.</li>
</ul>

<h3 id="출처">출처</h3>
<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/10811">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[10811번 - 바구니 뒤집기]]></summary></entry><entry><title type="html">[Java] 프로그래머스(level-1) - 명예의 전당 (1)</title><link href="http://localhost:4000/java/147-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-1) - 명예의 전당 (1)" /><published>2023-03-01T00:00:00+09:00</published><updated>2023-03-01T00:00:00+09:00</updated><id>http://localhost:4000/java/147-post</id><content type="html" xml:base="http://localhost:4000/java/147-post/"><![CDATA[<p><br /></p>
<center><img src="/assets/images/programmers/20230301_01.png" width="100%" /></center>
<left><img src="/assets/images/programmers/20230301_02.png" width="100%" /></left>
<p><br /></p>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />
<p>이번 명예의 전당(1) 문제의 경우 많은 분들이 <strong>우선순위 큐</strong>를 많이들 사용하는 것 같았는데, 필자는 우선순위 큐에 대한 공부가 부족하여 <strong>ArrayList</strong>를 활용하여 풀었다. <br />
일단은 ArrayList를 활용한 풀이 위주로 해설을 진행하고 추후 우선순위 큐를 학습한 후 다시 한번 풀어볼 예정이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>
<p>주어진 score의 길이가 일차가 되고, score의 원소, 즉 점수를 <strong>높은 점수순으로 k 만큼 누적해가며 최하위 점수</strong>를 구해내야 한다. <br />
여기서 ArrayList를 활용하는 원리는 간단하다.</p>

<ul>
  <li>k만큼의 일차까지는 명예의 전당에 순서대로 그대로 등록한다.</li>
  <li>명예의 전당 자리가 꽉 찬 이후의 점수의 경우, <strong>명예의 전당의 최하위 점수와 비교</strong>하여 명예의 전당에 등록한다.
    <ul>
      <li>이 때, 명예의 전당 점수는 <strong>오름차순으로 정렬</strong>을 하여 매일 발표되는 점수와 비교하여 명예의 전당에 등록한다.</li>
    </ul>
  </li>
  <li>일차(score.length) 별로 명예의 전당의 최하위 점수를 찾으면 된다.</li>
</ul>

<p><br /></p>

<p>말로 설명하면 좀 이해하기 어려울 수 있으니 바로 코드를 작성해보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="kt">int</span><span class="o">[]</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">score</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
<span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">glory</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>매일 발표되는 명예의 전당의 최하위 점수를 담을 answer 배열과 매일 k만큼의 점수를 가지고 있을 ArrayList를 하나 선언하자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">score</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">glory</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">glory</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">score</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
        <span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">glory</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">score</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">glory</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">glory</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">score</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">glory</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">glory</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>이제 매일 발표되는 점수들을 가지고 명예의 전당에 등록 여부를 가리면 된다. 그 과정은 다음과 같다.</p>

<ol>
  <li>명예의 전당 자리가 <strong>꽉 찰 때까지</strong>는 매일 발표되는 점수를 <strong>그대로 등록시키고 정렬</strong>한다.</li>
  <li>명예의 전당 자리가 <strong>꽉 찬 이후부터는</strong> 매일 발표되는 점수와 명예의 전당 최하위 점수와 비교하여 <strong>발표되는 점수가 더 클 경우 명예의 전당에 등록</strong>한 후 정렬한다.</li>
  <li>매일 명예의 전당의 최하위 점수를 answer 배열에 담는다.</li>
</ol>

<blockquote>
  <p><em>모든 경우마다 glory ArrayList를 정렬하는 이유는 최하위 점수를 알고 있어야 하기 때문이다.</em></p>
</blockquote>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">score</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">score</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">glory</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">score</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">glory</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">glory</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">score</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                <span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">glory</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">score</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">glory</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">glory</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">score</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                    <span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">glory</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>
            <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">glory</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">score</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">300</span><span class="o">,</span> <span class="mi">40</span><span class="o">,</span> <span class="mi">300</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">70</span><span class="o">,</span> <span class="mi">150</span><span class="o">,</span> <span class="mi">50</span><span class="o">,</span> <span class="mi">500</span><span class="o">,</span> <span class="mi">1000</span><span class="o">};</span>
        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">k</span><span class="o">,</span><span class="n">score</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<ul>
  <li>우선순위 큐를 알고 있었다면 더 쉽게 풀 수 있었지만 ArrayList만으로도 쉽게 풀 수 있었던 문제였다. 추후 꼭 우선순위 큐를 활용하여 다시 풀어봐야겠다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 1 - 명예의 전당 (1)]]></summary></entry><entry><title type="html">[Java] 프로그래머스(level-1) - 과일 장수</title><link href="http://localhost:4000/java/146-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-1) - 과일 장수" /><published>2023-02-28T00:00:00+09:00</published><updated>2023-02-28T00:00:00+09:00</updated><id>http://localhost:4000/java/146-post</id><content type="html" xml:base="http://localhost:4000/java/146-post/"><![CDATA[<p><br /></p>
<center><img src="/assets/images/programmers/20230228_01.png" width="100%" /></center>
<left><img src="/assets/images/programmers/20230228_02.png" width="35%" /></left>
<p><br /></p>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />
<p>이번 <code class="language-plaintext highlighter-rouge">과일 장수</code> 문제는 주어진 <strong>배열을 역순으로 그룹지어 접근</strong>하는 것이 핵심이다. <br />
한 마디로 배열을 잘 다룰 줄 알아야 한다는 것이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>
<p>처음엔 ArrayList를 활용하여 주어진 score 배열만큼 담은 다음 별도의 ArrayList에 add하고 remove하는 방식으로 접근하려 했으나 성능 이슈가 발생할 것 같아 그만두고 배열 자체를 잘 활용해보기로 하였다.</p>

<ul>
  <li>주어진 score 배열을 오름차순으로 정렬한다.
    <ul>
      <li>최대한 많은 이익을 내야 하기 때문에 <strong>오름차순으로 정렬하여 역순으로 큰 점수부터 접근</strong>하기 위함이다.</li>
    </ul>
  </li>
  <li>몇 박스나 담을 수 있는지를 구한다.
    <ul>
      <li>score 배열의 길이에서 m을 나눈 값이 된다.</li>
    </ul>
  </li>
  <li>박스 별로 <strong>[최소점수의 사과 * m]으로 최대 이익을 계산</strong>한다.
    <ul>
      <li>배열을 역순으로 접근하는데, m만큼 박스로 구분지어 최소점수를 구하고 [최소점수 * m] 연산을 통해 박스 당 최대이익을 구할 수 있다.</li>
    </ul>
  </li>
  <li>박스별로 구했던 최대이익을 모두 합한 값을 리턴한다.</li>
</ul>

<blockquote>
  <p><em>이 때, 내가 푼 풀이과정에서는 k를 굳이 고려하지 않아도 정답을 내는데 상관이 없어 보인다.</em></p>
</blockquote>

<p><br /></p>

<p>이제 아이디어대로 코드를 구현해보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">score</span><span class="o">);</span>    
<span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
<span class="kt">int</span> <span class="n">bucketLength</span> <span class="o">=</span> <span class="n">score</span><span class="o">.</span><span class="na">length</span> <span class="o">/</span> <span class="n">m</span><span class="o">;</span>
<span class="kt">int</span><span class="o">[]</span> <span class="n">buckets</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">bucketLength</span><span class="o">];</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>먼저 입력으로 주어지는 score 배열을 오름차순으로 정렬한다. <br />
모든 박스의 최대이익을 담을 answer 변수를 선언한다. <br />
그리고 몇 박스나 담을 수 있는지를 구하여 박스당 이익을 담아둘 buckets 배열을 선언하고 초기화하자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">score</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">-=</span><span class="n">m</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">&gt;</span><span class="n">i</span><span class="o">-</span><span class="n">m</span><span class="o">;</span> <span class="n">j</span><span class="o">--)</span> <span class="o">{</span>
        <span class="n">min</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="n">score</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
    <span class="o">}</span>
    <span class="n">buckets</span><span class="o">[</span><span class="n">idx</span><span class="o">++]</span> <span class="o">=</span> <span class="n">min</span> <span class="o">*</span> <span class="n">m</span><span class="o">;</span>
<span class="o">}</span>
<span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">bucket</span>  <span class="o">:</span> <span class="n">buckets</span><span class="o">)</span> <span class="n">answer</span> <span class="o">+=</span> <span class="n">bucket</span><span class="o">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>다음으로 score 배열을 거꾸로 역순으로 접근하는데 <strong>박스의 크기인 m만큼 나누어서</strong> 박스에 담아야 한다.</p>

<p>여기서 바깥쪽 for문에서는 <strong>i가 <code class="language-plaintext highlighter-rouge">score.length-1</code>부터 m-1이 될 때까지 m만큼 줄어들면서 반복</strong>하게 된다. <br />
그리고 안쪽 for문에서는 j가 i부터 시작해서 i-m만큼, 즉 <strong>역순으로 m개 만큼 추가로 반복</strong>한다.</p>

<p>이 때, 박스에 담긴 사과의 점수들 중 최소점수를 구해야 하기 때문에 Math 클래스의 min 메소드를 활용해서 박스 별 최소점수를 구한다.
안쪽 for문이 종료되는 순간 <strong>하나의 박스에 대한 연산이 끝나고 최소점수가 min에 담겨</strong>지게 된다.</p>

<p>그리고 안쪽 for문이 종료되면 앞서 선언해둔 <strong>bucket 배열에 <code class="language-plaintext highlighter-rouge">[최소점수 * m]</code> 을 통해 박스별 최대이익 값을 담으면 된다.</strong></p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">Math.min(10, score[j])</code>에서 10과 사과점수를 비교해 최소점수를 구하는 이유는 문제의 제한사항을 보면 사과의 점수 범위가 <code class="language-plaintext highlighter-rouge">3 ≤ k ≤ 9</code> 이기 때문이다.</p>
</blockquote>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">,</span> <span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">score</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">score</span><span class="o">);</span>    
        <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">bucketLength</span> <span class="o">=</span> <span class="n">score</span><span class="o">.</span><span class="na">length</span> <span class="o">/</span> <span class="n">m</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">buckets</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">bucketLength</span><span class="o">];</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">score</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">-=</span><span class="n">m</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">&gt;</span><span class="n">i</span><span class="o">-</span><span class="n">m</span><span class="o">;</span> <span class="n">j</span><span class="o">--)</span> <span class="o">{</span>
                <span class="n">min</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="n">score</span><span class="o">[</span><span class="n">j</span><span class="o">]);</span>
            <span class="o">}</span>
            <span class="n">buckets</span><span class="o">[</span><span class="n">idx</span><span class="o">++]</span> <span class="o">=</span> <span class="n">min</span> <span class="o">*</span> <span class="n">m</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">bucket</span>  <span class="o">:</span> <span class="n">buckets</span><span class="o">)</span> <span class="n">answer</span> <span class="o">+=</span> <span class="n">bucket</span><span class="o">;</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">answer</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<ul>
  <li>배열을 역순으로 접근한다는 생각은 쉽게 할 수 있었지만, m을 활용하여 큰 점수부터 작은 점수까지 박스별로 묶어서 접근하는 방식을 생각해내기가 어려웠다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 1 - 과일 장수]]></summary></entry><entry><title type="html">[Java] 프로그래머스(level-1) - 가장 가까운 같은 글자</title><link href="http://localhost:4000/java/145-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-1) - 가장 가까운 같은 글자" /><published>2023-02-27T00:00:00+09:00</published><updated>2023-02-27T00:00:00+09:00</updated><id>http://localhost:4000/java/145-post</id><content type="html" xml:base="http://localhost:4000/java/145-post/"><![CDATA[<p><br /></p>
<center><img src="/assets/images/programmers/20230227_02.png" width="100%" /></center>
<p><br /></p>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />
<p>이번 문제는 <strong>HashMap을 활용</strong>한다면 간단하게 풀 수 있다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>
<p>주어진 s의 각 문자별로 HashMap에 존재여부를 검증하도록 구현하면 된다.</p>

<ul>
  <li>HashMap에 존재하지 않는 문자라면, HashMap에 현재 문자와 인덱스 값을 집어넣고 answer 배열에 -1을 삽입한다.</li>
  <li>HashMap에 존재하는 문자라면, <strong>가장 가까운 글자의 인덱스가 HashMap에 삽입</strong>되어 있을 테니 <code class="language-plaintext highlighter-rouge">[현재 문자의 인덱스 - 가장 가까운 문자의 인덱스]</code>의 결과를 answer 배열에 삽입한 후, HashMap의 현재 문자와 인덱스 값을 집어넣는다.</li>
</ul>

<p><br /></p>

<p>아이디어를 토대로 바로 코드를 작성해보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="kt">int</span><span class="o">[]</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()];</span>
<span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">hm</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>가장 가까운 글자의 위치를 담을 answer 배열을 만들고 s의 길이를 가지도록 초기화한다. <br />
그리고 s의 문자와 인덱스 값을 담을 HashMap을 생성하자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="nc">Character</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
    <span class="k">if</span><span class="o">(</span><span class="n">hm</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">str</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">hm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">str</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
        <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">hm</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
        <span class="n">hm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">str</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">answer</span><span class="o">));</span>
<span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>다음으로 s의 각 문자들을 순회하면서 HashMap을 활용하여 검증하고 삽입하면 된다.</p>

<ol>
  <li>먼저 s의 문자가 HashMap에 존재하지 않는다면, HashMap에 s의 문자와 인덱스 값을 삽입한 후 answer 배열에 -1을 삽입한다.</li>
  <li>만약 s의 문자가 HashMap에 존재하는 값이라면, answer 배열에 <code class="language-plaintext highlighter-rouge">[s의 인덱스 - 먼저 삽입된 s 문자의 인덱스(값)]</code> 을 통해 <strong>가장 가까운 글자와의 인덱스의 차</strong>를 구한다.</li>
  <li>이 후 HashMap에 현재 인덱스 위치를 삽입하여 최신화한다.</li>
</ol>

<blockquote>
  <p><em>여기서는 s의 각 문자를 <code class="language-plaintext highlighter-rouge">Character.toString(s.charAt(i));</code> 구문과 같이 String 타입으로 활용했지만 Character 타입을 바로 사용해도 무방하다.</em></p>
</blockquote>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">solution</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">()];</span>
        <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">hm</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="nc">Character</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">));</span>
            <span class="k">if</span><span class="o">(</span><span class="n">hm</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">str</span><span class="o">)</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">hm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">str</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
                <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">hm</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
                <span class="n">hm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">str</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">Arrays</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="n">answer</span><span class="o">));</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">){</span>
        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        <span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"banana"</span><span class="o">;</span>
        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<ul>
  <li>문자열의 인덱스 값이 고정되는 것이 아니라 중복 문자가 발생할 경우 최신화 해야 하기 때문에 HashMap을 활용하여 삽입된 키에 따른 값을 변경하는 메커니즘을 도입할 수 있었다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 1 - 가장 가까운 같은 글자]]></summary></entry></feed>