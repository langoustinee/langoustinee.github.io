<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-09-04T14:31:24+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">lango’s DevLog</title><subtitle>developer</subtitle><author><name>lango</name></author><entry><title type="html">[Java] 백준(실버-1) 1149번 - RGB거리</title><link href="http://localhost:4000/java/267-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-1) 1149번 - RGB거리" /><published>2023-09-04T00:00:00+09:00</published><updated>2023-09-04T00:00:00+09:00</updated><id>http://localhost:4000/java/267-post</id><content type="html" xml:base="http://localhost:4000/java/267-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 <strong>동적 계획법 DP</strong>를 이용해 점화식을 세운다면 쉽게 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>처음엔 문제를 잘 이해하기 어려울 수 있다. 하나씩 살펴보며 간단히 정리해보자.</p>

<p>일단 1번부터 N번까지의 집을 색칠해야하는데 이때, 색칠할 수 있는 색의 종류는 빨강, 초록, 파랑 3가지가 주어진다. 그리고 각 집마다 색을 칠하는 비용이 주어진다. 우리는 N번까지의 모든 집을 칠할 때의 최소가 되는 비용을 구해야 한다.</p>

<p>일단 여기까지만 생각해보면, 각 집마다 R,G,B의 비용 중 가장 싼 색을 선택하면 될 것 같은데, 문제의 요구사항을 보면 <strong>근접한 집끼리는 같은 색으로 칠하면 안된다</strong>는 점을 고려해야 한다.</p>

<blockquote>
  <p>예를 들어 3번 집에 초록색을 칠한다면, 2번집과 4번집은 초록색을 칠할 수 없다. 이러한 조건으로 인해 최소 비용을 구할 때 그냥 최솟 비용만을 구한다면 오답이 된다.</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="mi">3</span>
<span class="mi">1</span> <span class="mi">100</span> <span class="mi">103</span>
<span class="mi">1</span> <span class="mi">103</span> <span class="mi">200</span>
<span class="mi">100</span> <span class="mi">1</span> <span class="mi">103</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>위와 같은 예시가 있다고 가정한다면, <code class="language-plaintext highlighter-rouge">1(R) + 103(G) + 100(R) = 204</code>로 조건을 잘 지키며 색을 칠할 수 있다. 하지만 이 비용이 과연 최소비용이 맞을까? 아니다. <code class="language-plaintext highlighter-rouge">100(G) + 1(R) + 1(G) = 102</code>가 정답이 된다. 여기서 볼 수 있듯이 그냥 <strong>단순히 최소가 돠는 비용을 찾아 누적합을 구하면 안된다</strong>는 것을 알 수 있다.</p>

<blockquote>
  <p>결과적으로 집마다 최소비용을 구해 누적합을 구하는 것이 아니라, <strong>모든 집을 칠하는 경우의 수를 찾아서 최종적으로 최소가 되는 누적합</strong>을 찾아야 한다.</p>
</blockquote>

<h4 id="dp-점화식">DP 점화식</h4>

<p>이때, 동적계획법을 어떻게 이용할 수 있을까? R, G, B에 따른 3가지 케이스 별로 비용을 담은 배열과 누적합을 담은 DP 테이블을 이용하면 된다.</p>

<p>DP 테이블을 갱신하기 위한 점화식은 다음과 같다.</p>

<ol>
  <li><strong>Red</strong>일 경우: <strong><code class="language-plaintext highlighter-rouge">Cost[N][0] = min( Cost[N-1][1], Cost[N-1][2] ) + Cost[N][0]</code></strong></li>
  <li><strong>Green</strong>일 경우: <strong><code class="language-plaintext highlighter-rouge">Cost[N][1] = min( Cost[N-1][0], Cost[N-1][2] ) + Cost[N][1]</code></strong></li>
  <li><strong>Blue</strong>일 경우: <strong><code class="language-plaintext highlighter-rouge">Cost[N][2] = min( Cost[N-1][0], Cost[N-1][1] ) + Cost[N][2]</code></strong></li>
</ol>

<p>위와 같은 점화식을 세우고 이를 재귀함수로 구성하여 메모이제이션을 적용해 <strong>해당 배열을 아직 탐색하지 않았다면 재귀</strong>를 해주고, 그 외의 경우는 DP배열의 값을 반환해주면 된다.</p>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// DP 테이블 선언</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="no">D</span><span class="o">;</span>
    
    <span class="c1">// 색상별 비용을 담을 배열</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">arr</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
                
                <span class="c1">// 1번 규칙: 1번 집과 2번 집의 색은 달라야 한다.</span>
                <span class="c1">// 2번 규칙: N-1번 집과 N번 집의 색은 달라야 한다.</span>
                <span class="c1">// 3번 규칙: i번 집은 i-1번 집, i+1번 집의 색과 달라야 한다.</span>

                <span class="c1">// 모든 집을 탐색하며 경로마다 경우의 수를 찾아 가장 작은 누적합을 찾아야 한다.</span>
                <span class="c1">// 1번집을 DP 테이블의 0번째로 초기화</span>

                <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

                <span class="c1">// 안쪽 배열은 R,G,B 3가지이기에 3의 크기로 초기화</span>
                <span class="no">D</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="mi">3</span><span class="o">];</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="mi">3</span><span class="o">];</span>

                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">(),</span> <span class="s">" "</span><span class="o">);</span>
                    <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                <span class="o">}</span>

                <span class="c1">// DP 테이블의 1번 집의 R,G,B 비용 설정</span>
                <span class="no">D</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
                <span class="no">D</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
                <span class="no">D</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>

                <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">recursion</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">recursion</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span> <span class="n">recursion</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)));</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>

        <span class="o">}</span>

    <span class="o">}</span>

    <span class="cm">/**
     * DP 테이블을 갱신할 재귀함수
     *
     * 점화식은 아래와 같다.
     * Red: arr[N][0] = min(arr[N-1][1], arr[N-1][2]) + arr[N][0]
     * Green: arr[N][1] = min(arr[N-1][0], arr[N-1][2]) + arr[N][1]
     * Blue: arr[N][2] = min(arr[N-1][0], arr[N-1][1]) + arr[N][2]
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">recursion</span><span class="o">(</span><span class="kt">int</span> <span class="no">N</span><span class="o">,</span> <span class="kt">int</span> <span class="n">color</span><span class="o">)</span> <span class="o">{</span>
        <span class="cm">/**
         * 탐색하지 않은 집의 위치라면 R,G,B 중 최소 비용을 갱신한다.
         * Red일 경우 == 0
         * Green일 경우 == 1
         * Blue일 경우 == 2
         */</span>
        <span class="k">if</span><span class="o">(</span><span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="n">color</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">color</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">recursion</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span> <span class="n">recursion</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">))</span> <span class="o">+</span> <span class="n">arr</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">color</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">recursion</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="n">recursion</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">))</span> <span class="o">+</span> <span class="n">arr</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span> 
            <span class="k">else</span> <span class="o">{</span>
                <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">recursion</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="n">recursion</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span> <span class="o">+</span> <span class="n">arr</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="c1">// 메모이제이션을 통해 탐색한 집이라면 위 제어문을 타지 않고 바로 반환한다.</span>
        <span class="k">return</span> <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="n">color</span><span class="o">];</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/1149">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[1149번 - RGB거리]]></summary></entry><entry><title type="html">[Java] 백준(실버-2) 11053번 - 가장 긴 증가하는 부분 수열</title><link href="http://localhost:4000/java/268-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-2) 11053번 - 가장 긴 증가하는 부분 수열" /><published>2023-09-04T00:00:00+09:00</published><updated>2023-09-04T00:00:00+09:00</updated><id>http://localhost:4000/java/268-post</id><content type="html" xml:base="http://localhost:4000/java/268-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 <strong>동적 계획법 DP</strong>를 이용해 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>필자는 반복문을 활용한 Bottom-Up 방식이 아닌 재귀 함수를 이용한 Top-Down 방식을 이용해 풀었다.</p>

<p>이번 문제는 이전에 풀었던 <a href="https://langoustinee.github.io/java/232-post/">계단 오르기</a>와 같은 계열의 문제로써, <strong>LIS(최장 증가 부분 수열) 유형의 문제</strong>이다.</p>

<blockquote>
  <p>최장 증가 부분 수열(LIS)란 <strong>주어진 수열에서 오름차순으로 구성 가능한 원소들을 선택하여 최대 길이를 찾아내는 것</strong>이다. 잘 활용하면 O(N logN) 의 시간복잡도를 가진다.</p>
</blockquote>

<p>예제1을 살펴보면, <code class="language-plaintext highlighter-rouge">{10, 20, 10, 30, 20, 50}</code>라는 수열이 주어진다. N의 크기를 가지는 arr 배열에 해당 수열을 담고 DP 테이블에 해당 위치마다의 수열 길이를 메모이제이션하는 방식으로 접근하면 된다.</p>

<blockquote>

  <ol>
    <li>arr[0]=10일 경우 증가 부분 수열은 arr[0]보다 이전 값이 없기에 <strong>{10}이라는 부분 수열만이 존재하여 1의 길이</strong>를 가진다. <code class="language-plaintext highlighter-rouge">DP[0] = 1</code><br /></li>
    <li>arr[1]=20의 경우 arr[0]이 10으로 arr[1]보다 작기때문에 <strong>{10, 20}이라는 부분 수열</strong>을 만들 수 있다. <code class="language-plaintext highlighter-rouge">DP[1] = 2</code><br /></li>
    <li>arr[2]=10의 경우, 이전 값들 중 작은 값이 없기 때문에 <strong>{10} 부분 수열</strong>을 만들 수 있다. <code class="language-plaintext highlighter-rouge">DP[2] = 1</code><br />
…</li>
  </ol>
</blockquote>

<p>위 과정을 N까지 반복하게 되면 <code class="language-plaintext highlighter-rouge">D = {1, 2, 1, 3, 2, 4}</code>라는 DP 테이블을 만들 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="no">DP</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">}</span> <span class="c1">// 길이 1</span>
<span class="no">DP</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">}</span> <span class="c1">// 길이 2</span>
<span class="no">DP</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">}</span> <span class="c1">// 길이 1</span>
<span class="no">DP</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="o">}</span> <span class="c1">// 길이 3</span>
<span class="no">DP</span><span class="o">[</span><span class="mi">4</span><span class="o">]</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">}</span> <span class="c1">// 길이 2</span>
<span class="no">DP</span><span class="o">[</span><span class="mi">5</span><span class="o">]</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="o">,</span> <span class="mi">50</span><span class="o">}</span> <span class="c1">// 길이 4</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>위와 같이 부분 수열들의 길이를 DP 테이블의 위치마다 갱신하면 가장 긴 부분수열의 길이는 4라는 것을 알 수 있다.</p>

<p>이를 DP로 어떻게 접근하여 풀 수 있을까? 아이디어를 생각해보자.</p>

<ol>
  <li>일단 <strong>모든 부분 수열의 최소 길이는 1</strong>이기에 탐색시 D[N]의 값을 1로 초기화한다.</li>
  <li>0부터 N-1까지 재귀 호출하여 탐색한다.</li>
  <li>재귀 함수에서는 <strong>N-1부터 0까지 거꾸로 이전 위치까지 다시 찾아나가며</strong>, 현재의 값보다 이전 값들 중 작은 값이 있을 경우 <strong>재귀호출을 통해 작은 값이 있는 위치의 길이와 비교해가며 부분 수열의 길이를 DP 테이블에 갱신</strong>한다.</li>
  <li>DP 테이블 갱신을 완료했다면, DP 테이블의 값 중 최댓값이 가장 긴 부분수열의 길이가 된다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// DP 테이블 선언</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="no">D</span><span class="o">;</span>
    
    <span class="c1">// 수열 입력 배열 선언</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
                
                <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

                <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
                <span class="no">D</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>

                <span class="c1">// DP 테이블의 모든 값을 -1로 초기화</span>
                <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="no">D</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>

                <span class="c1">// 수열 입력</span>
                <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                <span class="o">}</span>
                
                <span class="c1">// 0부터 N-1까지 재귀함수 호출하여 탐색</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="n">recursion</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                <span class="o">}</span>

                <span class="c1">// DP 테이블의 최댓값을 구하기 위해 오름차순 정렬</span>
                <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="no">D</span><span class="o">);</span>

                <span class="c1">// DP 테이블의 마지막 원소가 최댓값이 된다.</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="no">D</span><span class="o">[</span><span class="no">D</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">]+</span><span class="s">"\n"</span><span class="o">);</span>
                
        <span class="o">}</span>

    <span class="o">}</span>
    
    <span class="cm">/**
     * DP 테이블을 갱신할 재귀함수
     * 
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">recursion</span><span class="o">(</span><span class="kt">int</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 방문하지 않은 위치라면</span>
        <span class="k">if</span><span class="o">(</span><span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 모든 부분수열의 길이는 최소 1이기에 1로 초기화</span>
            <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="cm">/*
             * N-1부터 0까지 탐색하며 현재 값보다 작은 값을 찾는다.
             * 찾을 때, 재귀 호출을 통해 찾아온다.
             */</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">[</span><span class="no">N</span><span class="o">])</span> <span class="o">{</span>
                    <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">],</span> <span class="n">recursion</span><span class="o">(</span><span class="n">i</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>    
        <span class="o">}</span>
        <span class="c1">// 메모이제이션을 통해 방문한 위치의 값을 바로 반환</span>
        <span class="k">return</span> <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/11053">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[11053번 - 가장 긴 증가하는 부분 수열]]></summary></entry><entry><title type="html">[Java] 프로그래머스(level-2) - 두 큐 합 같게 만들기</title><link href="http://localhost:4000/java/266-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-2) - 두 큐 합 같게 만들기" /><published>2023-08-31T00:00:00+09:00</published><updated>2023-08-31T00:00:00+09:00</updated><id>http://localhost:4000/java/266-post</id><content type="html" xml:base="http://localhost:4000/java/266-post/"><![CDATA[<p><br /></p>

<center><img src="/assets/images/programmers/" width="100%" /></center>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />

<p>이 문제는 완전탐색을 활용해 풀기보다는 <strong>그리디 알고리즘</strong>을 활용해 풀어야 한다.</p>

<p><br /></p>

<h4 id="아아디어-도출">아아디어 도출</h4>

<p>정직하게 문제에서 주어진대로 접근한다면 1번큐와 2번큐 중 추출시 선택의 기로가 생기게 되고, 결국 <strong>큐의 길이(최대 300,000)만큼 완전 탐색하며 경우의 수를 따지게 된다면 시간초과가 발생</strong>할 수 있다.</p>

<p>모든 큐의 합을 맟추려하지 말고, 아래처럼 접근하며 어떨까?</p>

<blockquote>
  <p>두 큐의 합이 같다 == 한 큐의 합은 <code class="language-plaintext highlighter-rouge">두 큐의 합/2</code>이 된다.</p>
</blockquote>

<p>이 말은 즉, 1번 큐의 모든 원소의 합을 두 큐의 합/2의 값으로 만들면 된다는 것이다. 그렇다면 교체는 어떻게 하면 될까?</p>

<ul>
  <li>1번 큐의 합이 <code class="language-plaintext highlighter-rouge">두 큐의 합/2</code> 보다 <strong>작다면, 2번 큐에서 추출</strong>하여 가져온다.</li>
  <li>1번 큐의 합이 <code class="language-plaintext highlighter-rouge">두 큐의 합/2</code> 보다 <strong>크다면, 1번 큐에서 추출하여 2번 큐로 넣어준다.</strong></li>
</ul>

<p>이때, 필자는 1번 큐를 기준으로 2번 큐를 교체할 큐로 정해 구현했다.
이제 위 내용을 통해 아이디어를 정리해보자.</p>

<ol>
  <li>두 큐의 원소를 각각 큐에 저장하고, 1번 큐의 원소 합과 두 큐의 합/2의 값을 계산한다.(<strong>합 계산 중 문제 방지를 위해 long 타입을 사용!</strong>)</li>
  <li>1번 큐의 합(sum)이 두 큐의 합(total)과 같을 때까지 아래 3-4번 과정을 반복한다.</li>
  <li><code class="language-plaintext highlighter-rouge">sum &gt; total</code>이라면 1번 큐에서 원소를 추출해 2번 큐로 삽입한다. 추출한 원소값만큼을 sum에서 뺀다.</li>
  <li><code class="language-plaintext highlighter-rouge">sum &lt; total</code>이라면 2번 큐에서 원소를 추출하여 1번 큐로 삽입한다. 추출한 원소값만큼을 sum에 증가시킨다.</li>
  <li>이때, 교체횟수는 최대로 <strong><code class="language-plaintext highlighter-rouge">큐의 길이 * 3</code></strong> 만큼을 넘어갈 수 없기 때문에 반복 횟수가 이를 넘어가면 두 큐의 합을 맞출 수 없다고 판단하여 -1을 반환한다.</li>
</ol>

<p><br /></p>

<p>다음으로 문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
</pre></td><td class="rouge-code"><pre>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="c1">// 두 큐 원소의 합이 같다는 것은 하나의 큐의 합을 두 큐의 합/2 이 되면 된다는 것이다.</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">queue1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">queue2</span><span class="o">)</span> <span class="o">{</span>

        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">q1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">q2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// 문제에서 요구한대로 합 계산 과정 중 문제 방지를 위해 long 타입을 사용한다.</span>
        <span class="kt">long</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">queue1</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">q1</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">queue1</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">q2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">queue2</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">queue1</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">queue2</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">queue1</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="c1">// 한쪽 큐의 합은 [두 큐의 합/2] 조건을 충족하면 된다.</span>
        <span class="n">total</span> <span class="o">/=</span> <span class="mi">2</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">cycle</span> <span class="o">=</span> <span class="n">queue1</span><span class="o">.</span><span class="na">length</span><span class="o">*</span><span class="mi">3</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="cm">/**
         * 두 큐의 합을 동일하게 만드는 로직
         * q1을 기준으로 q2는 교체할 큐로 사용한다.
         * 단, 일정 교체횟수 이상을 반복하게 되면 종료한다.
         */</span>
        <span class="k">while</span><span class="o">(</span><span class="n">sum</span> <span class="o">!=</span> <span class="n">total</span><span class="o">)</span> <span class="o">{</span>

            <span class="cm">/**
             * q1과 a2의 값을 교체하는 횟수는 최대 [한 큐의 길이 * 3] 만큼 을 넘지 않는다.
             * 교체 횟수 이상 반복되면 두 큐의 합을 맞추지 못하기에 -1을 반환한다.
             */</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cycle</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
            
            <span class="cm">/**
             * q1의 합이 total보다 크다면, 첫번째 원소를 추출하고 q2의 원소를 가져온다.
             * 이때, q1의 합을 다시 계산하기 위해 추출한 수만큼을 뺀다.
             * 그 반대라면 q2의 첫번째 원소를 추출하고 q1의 원소를 가져간다.
             */</span>
            <span class="k">if</span><span class="o">(</span><span class="n">sum</span> <span class="o">&gt;</span> <span class="n">total</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">temp1</span> <span class="o">=</span> <span class="n">q1</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="n">sum</span> <span class="o">-=</span> <span class="n">temp1</span><span class="o">;</span>
                <span class="n">q2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">temp1</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">temp2</span> <span class="o">=</span> <span class="n">q2</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">temp2</span><span class="o">;</span>
                <span class="n">q1</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">temp2</span><span class="o">);</span>
            <span class="o">}</span>
            
            <span class="c1">// 교체 횟수를 차감한다.</span>
            <span class="n">cycle</span><span class="o">--;</span>

        <span class="o">}</span>

        <span class="c1">// 두 큐의 합을 같게 한 이후, 총 교체횟수를 구한다.</span>
        <span class="k">return</span> <span class="n">queue1</span><span class="o">.</span><span class="na">length</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">-</span> <span class="n">cycle</span><span class="o">;</span>
    <span class="o">}</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        
        <span class="c1">// int[] queue1 = new int[]{3,2,7,2};</span>
        <span class="c1">// int[] queue2 = new int[]{4,6,5,1};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">queue1</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">queue2</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">};</span>
        
        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">queue1</span><span class="o">,</span> <span class="n">queue2</span><span class="o">);</span>

    <span class="o">}</span>

<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<p>-</p>

<hr />

<p><br /></p>

<h3 id="출처">출처</h3>
<p>-</p>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://school.programmers.co.kr/learn/courses/30/lessons/118667">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 2 - 두 큐 합 같게 만들기]]></summary></entry><entry><title type="html">[Java] 프로그래머스(level-2) - 숫자 변환하기</title><link href="http://localhost:4000/java/265-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-2) - 숫자 변환하기" /><published>2023-08-30T00:00:00+09:00</published><updated>2023-08-30T00:00:00+09:00</updated><id>http://localhost:4000/java/265-post</id><content type="html" xml:base="http://localhost:4000/java/265-post/"><![CDATA[<p><br /></p>

<center><img src="/assets/images/programmers/" width="100%" /></center>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />

<p>이번 문제는 <strong>동적 계획법(DP)</strong>을 통해 풀 수 있다.</p>

<p>처음엔 단순히 재귀를 통해 x<em>n, x</em>2, x*3 경우별로 재귀 호출하여 y가 되는 순간의 최소 깊이를 반환하는 방식으로 풀었으나 <strong>시간초과가 발생</strong>했다.</p>

<h4 id="재귀-코드---오답시간초과-발생">재귀 코드 - 오답(시간초과 발생)</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">answer</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">answer</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="n">recursion</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">answer</span> <span class="o">==</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">answer</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">recursion</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">answer</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">answer</span><span class="o">,</span> <span class="n">depth</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">recursion</span><span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="n">n</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">recursion</span><span class="o">(</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">recursion</span><span class="o">(</span><span class="n">x</span><span class="o">*</span><span class="mi">3</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>그렇다면 어떻게 시간초과를 줄일 수 있을까? 완전탐색을 하지 않고 효율적인 방법이 없는지를 고민해보니 <strong>DP 테이블에 x가 y로 변환되는 최소 연산횟수를 갱신해가며 접근하는 방법</strong>으로 풀 수 있다고 판단하여 DP를 이용해 풀 수 있었다.</p>

<p>DP를 이용한 아이디어를 살펴보자.</p>

<ol>
  <li>y만큼의 크기를 가지는 DP 테이블을 선언하고 x부터 y까지 순회하며 DP 테이블의 값을 갱신한다.</li>
  <li>DP 테이블의 값을 갱신하는 경우는 <strong>index+n, index<em>2, index</em>3과 같이 3가지 경우로 나누어 DP 테이블의 원소를 기록</strong>한다.</li>
  <li>현재 위치의 DP 테이블 값이 변환될 수 없는 수라면 -1을 기록하고 순회를 넘어간다.</li>
</ol>

<p><br /></p>

<p>다음으로 문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre></td><td class="rouge-code"><pre>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="c1">// x와 y의 최대 범위 값을 상수로 활용한다.</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MAX_VALUE</span> <span class="o">=</span> <span class="mi">1_000_000</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="c1">// DP 테이블을 MAX_VALUE 값으로 초기화한다.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="no">D</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="no">D</span><span class="o">,</span> <span class="no">MAX_VALUE</span><span class="o">);</span>

        <span class="c1">// DP 테이블의 x번째 원소를 0으로 초기화한다.</span>
        <span class="no">D</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="cm">/**
         * DP 테이블에 연산 횟수를 갱신하는 반복문
         * x부터 y까지 순회하면서 x의 값에서 변환할 수 있는 i+n일 경우, i*2일 경우, i*3일 경우를 비교한다.
         * 변환할 수 없는 값이라면 
         * 변환할 수 있는 값일 경우 i번째 연산 횟수에서 1씩 증가한 값과 최솟값을 비교하여 갱신한다.
         */</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">x</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">y</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            
            <span class="c1">// 현재 위치의 x값이 y로 변환할 수 없다면 -1로 기록하고 넘어간다.</span>
            <span class="k">if</span><span class="o">(</span><span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="no">MAX_VALUE</span><span class="o">)</span> <span class="o">{</span>
                <span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// 연산횟수를 기록한다.</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
                <span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="n">n</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="n">n</span><span class="o">],</span> <span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
                <span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">],</span> <span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
                <span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">*</span><span class="mi">3</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">*</span><span class="mi">3</span><span class="o">],</span> <span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>

        <span class="o">}</span>
        
        <span class="k">return</span> <span class="no">D</span><span class="o">[</span><span class="n">y</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">40</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        
        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>

    <span class="o">}</span>

<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<p>-</p>

<hr />

<p><br /></p>

<h3 id="출처">출처</h3>
<p>-</p>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://school.programmers.co.kr/learn/courses/30/lessons/154538">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 2 - 숫자 변환하기]]></summary></entry><entry><title type="html">[Java] 백준(실버-1) 20529번 - 가장 가까운 세 사람의 심리적 거리</title><link href="http://localhost:4000/java/264-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-1) 20529번 - 가장 가까운 세 사람의 심리적 거리" /><published>2023-08-29T00:00:00+09:00</published><updated>2023-08-29T00:00:00+09:00</updated><id>http://localhost:4000/java/264-post</id><content type="html" xml:base="http://localhost:4000/java/264-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 <strong>문제의 제약사항을 잘 파악</strong>한 뒤, <strong>완전탐색</strong>을 이용해 쉽게 풀 수 있다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>처음에 단순히 완전탐색을 통해 모든 경우를 탐색하려 했으나 N의 범위가 최대 100,000이기에 시간초과를 어느정도 고려해야 했다.</p>

<p>시간 초과를 어떻게 줄일 수 있을까?</p>

<p>우리는 가까운 <strong>3 사람의 MBTI</strong>를 통해 최소가 되는 심리거리를 구해야 한다. 문제에서 주어지는 <strong>MBTI는 총 16가지이며 이것이 큰 힌트</strong>가 된다.</p>

<p><strong>세 사람의 MBTI가 같다면, 서로간의 심리거리는 0으로 가장 최소</strong>가 될테니 이후로는 더이상 탐색할 필요가 없다.</p>

<p>그런데 MBTI는 한 사람당 16가지 중 1가지가 나오며 두 사람일 경우는 32가지가 된다. <strong>33가지가 넘어가는 순간 세 사람이 같은 MBTI가 될 수 있기 때문</strong>에 33명의 학생(N)을 입력받을 경우 묻지도 않고 따지지도 않고 <strong>0을 출력</strong>하면 나머지 탐색을 줄일 수 있어 시간복잡도 측면에서 이득이 된다.</p>

<p>그렇다면 이제 아이디어를 정리해보자.</p>

<ol>
  <li>N(학생)이 33 이상이 주어질 경우 0을 출력하고 다음 순회로 넘어간다.</li>
  <li>N이 32 이하일 경우 3중 for문(세 사람)으로 완전 탐색을 하며 서로 간의 심리거리를 구하고 이 심리거리들 중 최솟값으로 갱신한다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>

                <span class="kt">int</span> <span class="no">T</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

                <span class="k">while</span><span class="o">(</span><span class="no">T</span> <span class="o">--&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>

                    <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                    <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

                    <span class="cm">/**
                     * 세 사람의 심리적 거리가 0이 될 경우 최소이기에 더 탐색을 진행할 필요가 없다.
                     * MBIT의 종류는 총 16가지이기에 N이 33 이상이라면 중복되는 3개의 MBTI가 주어질 수 있기에 불필요한 탐색을 하게 된다.
                     * N이 33 이상이라면 바로 0을 반환할 수 있도록 한다.
                     */</span>
                    <span class="k">if</span><span class="o">(</span><span class="no">N</span> <span class="o">&gt;</span> <span class="mi">32</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"0"</span> <span class="o">+</span> <span class="s">"\n"</span><span class="o">);</span>
                        <span class="k">continue</span><span class="o">;</span>
                    <span class="o">}</span>

                    <span class="c1">// * N이 32 이하일 경우 아래 로직을 수행한다.</span>

                    <span class="c1">// N개의 MBTI 문자열을 입력받는다.</span>
                    <span class="nc">String</span><span class="o">[]</span> <span class="n">mbtis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                        <span class="n">mbtis</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">();</span>
                    <span class="o">}</span>

                    <span class="c1">// 세 사람의 심리거리의 최소값을 구하기 위한 변수 초기화한다.</span>
                    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

                    <span class="c1">// N개 중 3 사람의 조합을 이용해 최소가 되는 심리거리를 구한다.</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>
                                <span class="n">result</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">getDistance</span><span class="o">(</span><span class="n">mbtis</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">mbtis</span><span class="o">[</span><span class="n">j</span><span class="o">],</span> <span class="n">mbtis</span><span class="o">[</span><span class="n">k</span><span class="o">]));</span>
                            <span class="o">}</span>
                        <span class="o">}</span>
                    <span class="o">}</span>

                    <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
                <span class="o">}</span>

        <span class="o">}</span>

    <span class="o">}</span>

    <span class="c1">// 3개의 MBTI를 통해 심리거리를 구하는 함수</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">getDistance</span><span class="o">(</span><span class="nc">String</span> <span class="n">a</span><span class="o">,</span> <span class="nc">String</span> <span class="n">b</span><span class="o">,</span> <span class="nc">String</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">)</span> <span class="o">{</span>
                <span class="n">result</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">c</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">result</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">c</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">result</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/20529">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[20529번 - 가장 가까운 세 사람의 심리적 거리]]></summary></entry><entry><title type="html">[Java] 백준(실버-1) 2583번 - 영역 구하기</title><link href="http://localhost:4000/java/263-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-1) 2583번 - 영역 구하기" /><published>2023-08-29T00:00:00+09:00</published><updated>2023-08-29T00:00:00+09:00</updated><id>http://localhost:4000/java/263-post</id><content type="html" xml:base="http://localhost:4000/java/263-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 <strong>너비 우선 탐색 BFS</strong>를 이용해 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>일반적인 BFS 문제들과 유사하나, <strong>직사각형의 위치를 먼저 갱신하고 BFS 탐색을 진행</strong>하도록 구현하면 된다.</p>

<p>그래서 문제에서 주어지는 <strong>4개의 x,y좌표를 통해 직사각형의 위치를 갱신</strong>하는 것이 핵심이다. 문제에서는 왼쪽 아래 x,y 좌표와 오른쪽 위 x,y죄표를 어떻게 직사각형 위치만큼 배열에 기록할 수 있을까?</p>

<p>아래 예시를 통해 살펴보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="no">M</span><span class="o">=</span><span class="mi">5</span><span class="o">,</span> <span class="no">N</span><span class="o">=</span><span class="mi">7</span><span class="o">,</span> <span class="no">K</span><span class="o">=</span><span class="mi">3</span>
<span class="mi">0</span> <span class="mi">2</span> <span class="mi">4</span> <span class="mi">4</span>
<span class="mi">1</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">5</span>
<span class="mi">4</span> <span class="mi">0</span> <span class="mi">6</span> <span class="mi">2</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <ul>
    <li>왼쪽 x 좌표부터 오른쪽 x 좌표까지 <strong>0 ~ 4</strong>, 왼쪽 y 좌표부터 오른쪽 y 좌표까지 <strong>2 ~ 4</strong></li>
    <li>왼쪽 x 좌표부터 오른쪽 x 좌표까지 <strong>1 ~ 2</strong>, 왼쪽 y 좌표부터 오른쪽 y 좌표까지 <strong>1 ~ 5</strong></li>
    <li>왼쪽 x 좌표부터 오른쪽 x 좌표까지 <strong>4 ~ 6</strong>, 왼쪽 y 좌표부터 오른쪽 y 좌표까지 <strong>0 ~ 2</strong></li>
  </ul>
</blockquote>

<p>위와 같이 x와 y좌표의 왼쪽, 오른쪽 값의 위치일 때면 직사각형의 범위 내에 있는 것이라고 볼 수 있다! 그래서 4개의 꼭지점을 입력받을 때 직사각형의 위치만큼 배열을 갱신할 수 있게 된다.</p>

<p>이제 문제풀이를 위한 전체적인 흐름을 살펴보자.</p>

<ol>
  <li>M*N 크기의 배열에서 4개의 꼭지점을 입력받아 직사각형의 위치만큼 1로 갱신한다.</li>
  <li>해당 배열을 가지고 BFS 너비 우선 탐색을 진행하여 분리된 영역의 갯수와 각 영역별 넓이를 구한다.</li>
</ol>

<p>꼭지점을 가지고 직사각형 범위만 찾아낼 수 있다면, BFS를 수행하는 로직은 쉽다고 볼 수 있다.</p>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// 상,하,좌,우로 탐색할 dx,dy 배열 선언</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dx</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>

    <span class="c1">// 방문 배열 및 직사각형 위치를 갱신할 입력배열 선언</span>
    <span class="kd">static</span> <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">visited</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">arr</span><span class="o">;</span>

    <span class="c1">// 배열의 크기와 직사각형 위치 갯수 변수 선언</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="no">N</span><span class="o">,</span> <span class="no">M</span><span class="o">,</span> <span class="no">K</span><span class="o">;</span>

    <span class="c1">// 영역 총 갯수 선언</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">totalCnt</span><span class="o">;</span>
    
    <span class="c1">// 영역별 넓이를 담을 List 선언</span>
    <span class="kd">static</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">areaCnts</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>

                <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                <span class="no">K</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

                <span class="c1">// 입력 배열 및 방문 배열 초기화</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">M</span><span class="o">];</span>
                <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">M</span><span class="o">];</span>

                <span class="c1">// 4개의 꼭지점을 입력받아 arr 배열에 직사각형을 놓는다.</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">K</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                    <span class="kt">int</span> <span class="n">left_x</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="kt">int</span> <span class="n">left_y</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="kt">int</span> <span class="n">right_x</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="kt">int</span> <span class="n">right_y</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="c1">// 직사각형 꼭지점을 이용해 배열에 직사각형 위치를 1로 갱신한다.</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="n">left_x</span><span class="o">;</span> <span class="n">x</span><span class="o">&lt;</span><span class="n">right_x</span><span class="o">;</span> <span class="n">x</span><span class="o">++)</span> <span class="o">{</span>
                        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">y</span><span class="o">=</span><span class="n">left_y</span><span class="o">;</span> <span class="n">y</span><span class="o">&lt;</span><span class="n">right_y</span><span class="o">;</span> <span class="n">y</span><span class="o">++)</span> <span class="o">{</span>
                            <span class="n">arr</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                <span class="o">}</span>

                <span class="c1">// 영역의 총 갯수를 구하기 위해 초기화</span>
                <span class="n">totalCnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                
                <span class="c1">// 영역별 넓이를 담기위한 List 초기화</span>
                <span class="n">areaCnts</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

                <span class="c1">// MXN만큼 순회하며 bfs 함수 호출하여 영역별 넓이를 구한다.</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="no">M</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                        <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                            <span class="kt">int</span> <span class="n">areaCnt</span> <span class="o">=</span> <span class="n">bfs</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">);</span>
                            <span class="n">areaCnts</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">areaCnt</span><span class="o">);</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                <span class="o">}</span>

                <span class="c1">// 영역별 넓이를 담은 List의 size가 총 영역의 개수가 된다.</span>
                <span class="n">totalCnt</span> <span class="o">=</span> <span class="n">areaCnts</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>

                <span class="c1">// 문제 요구사항을 맞추기 위해 List 오름차순 정렬</span>
                <span class="nc">Collections</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">areaCnts</span><span class="o">);</span>
                
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">totalCnt</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">areaCnt</span> <span class="o">:</span> <span class="n">areaCnts</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">areaCnt</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"\n"</span><span class="o">);</span>

        <span class="o">}</span>

    <span class="o">}</span>

    <span class="cm">/**
     * BFS 함수
     * x,y 값을 담은 Node 클래스를 큐에 삽입해가며 너비우선탐색을 진행
     * 함수 내에서 영역별 넓이를 계산하여 반환
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">bfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">));</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="c1">// 영역별 넓이를 구하기 위한 변수</span>
        <span class="kt">int</span> <span class="n">areaCnt</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">Node</span> <span class="n">now</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">dir</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">dir</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">;</span> <span class="n">dir</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="na">getX</span><span class="o">()</span> <span class="o">+</span> <span class="n">dx</span><span class="o">[</span><span class="n">dir</span><span class="o">];</span>
                <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="na">getY</span><span class="o">()</span> <span class="o">+</span> <span class="n">dy</span><span class="o">[</span><span class="n">dir</span><span class="o">];</span>
                <span class="k">if</span><span class="o">(</span><span class="n">isRange</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">));</span>
                        <span class="n">areaCnt</span><span class="o">++;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">areaCnt</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isRange</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">&lt;</span><span class="no">N</span> <span class="o">&amp;&amp;</span> <span class="n">y</span><span class="o">&lt;</span><span class="no">M</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>

<span class="c1">// x,y 좌표를 담을 Node 클래스</span>
<span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">y</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getX</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">x</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getY</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">y</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/2583">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[2583번 - 영역 구하기]]></summary></entry><entry><title type="html">[Java] 프로그래머스(level-2) - 롤케이크 자르기</title><link href="http://localhost:4000/java/261-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-2) - 롤케이크 자르기" /><published>2023-08-28T00:00:00+09:00</published><updated>2023-08-28T00:00:00+09:00</updated><id>http://localhost:4000/java/261-post</id><content type="html" xml:base="http://localhost:4000/java/261-post/"><![CDATA[<p><br /></p>

<center><img src="/assets/images/programmers/" width="100%" /></center>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />

<p>이번 문제는 문제에서 요구한 대로 <strong>자료구조를 잘 활용</strong>하여 구현하면 되는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>이 문제에서는 철수와 동생이 동일한 토핑 수를 나눠 먹을 수 있도록 롤케이크를 자를 수 있는 경우를 반환해야 한다. 어떤 자료구조를 이용할 수 있을까?</p>

<ul>
  <li>HashMap</li>
  <li>HashSet</li>
</ul>

<p>필자는 위 2개의 자료구조를 이용해 <strong>형과 동생이 나눠먹을 토핑 수를 기록하고 비교하여 롤케이크를 자를 수 있는지 비교</strong>하였다.</p>

<p>또한, 배열의 길이는 최대 1,000,000까지 주어질 수 있어 시간초과를 고려해야 한다. 그래서 <strong>O(n)의 시간복잡도</strong>를 맞출 수 있도록 하였다.</p>

<ol>
  <li>topping 배열을 순회하며 <strong>원소를 key</strong>로, <strong>원소의 빈도 수를 value</strong>로 Map에 삽입한다.</li>
  <li>다시 topping 배열을 순회하며, 등장하는 원소마다 Set에 삽입하고 Map에서는 해당 원소의 빈도 수를 1씩 차감한다.</li>
  <li>2번 과정을 마친 후, 만약 Map에서 해당 원소의 빈도 수가 0이라면 Map에서 해당 원소를 제거한다.</li>
  <li>이후, <strong>Map과 Set의 크기가 같다면, 같은 토핑 수를 보유하고 있는 것이기에 롤 케이크를 자를 수 있다고 판단</strong>하여 answer를 1 증가시킨다.</li>
</ol>

<blockquote>
  <p><strong>중복이 허용되지 않는 HashSet</strong>을 통해 HashMap과의 크기 비교를 통해 같은 토핑 수를 유지하고 있는지를 확인할 수 있다.</p>
</blockquote>

<p><br /></p>

<p>다음으로 문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre></td><td class="rouge-code"><pre>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">topping</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">hm</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="nc">HashSet</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// map에 원소와 빈도 수를 key:value로 담는다.</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">ele</span> <span class="o">:</span> <span class="n">topping</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">hm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">ele</span><span class="o">,</span> <span class="n">hm</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">ele</span><span class="o">,</span> <span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="cm">/**
         * set에 해당 원소를 담은 후, map에서 빈도 수를 1씩 차감한다.
         * 만약 map의 빈도 수가 0이면 map에서 제거한다.
         * set과 map의 크기가 같다면 같은 토핑 수를 보유하기에 answer를 1 증가시킨다.
         */</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">ele</span> <span class="o">:</span> <span class="n">topping</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">hm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">ele</span><span class="o">,</span> <span class="n">hm</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">ele</span><span class="o">,</span> <span class="mi">0</span><span class="o">)-</span><span class="mi">1</span><span class="o">);</span>
            <span class="n">set</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">ele</span><span class="o">);</span>

            <span class="k">if</span><span class="o">(</span><span class="n">hm</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">ele</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">hm</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">ele</span><span class="o">);</span>
            <span class="o">}</span>

            <span class="k">if</span><span class="o">(</span><span class="n">hm</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="n">set</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">answer</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">topping</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
        
        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">topping</span><span class="o">);</span>

    <span class="o">}</span>

<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<p>-</p>

<hr />

<p><br /></p>

<h3 id="출처">출처</h3>
<p>-</p>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://school.programmers.co.kr/learn/courses/30/lessons/132265">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 2 - 롤케이크 자르기]]></summary></entry><entry><title type="html">[Java] 프로그래머스(level-2) - 하노이의 탑</title><link href="http://localhost:4000/java/262-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-2) - 하노이의 탑" /><published>2023-08-28T00:00:00+09:00</published><updated>2023-08-28T00:00:00+09:00</updated><id>http://localhost:4000/java/262-post</id><content type="html" xml:base="http://localhost:4000/java/262-post/"><![CDATA[<p><br /></p>

<center><img src="/assets/images/programmers/" width="100%" /></center>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />

<p>이번 문제는 <strong>하노이의 탑 원리</strong>를 잘 숙지하고 있으면 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>필자는 하노이의 탑 원리를 구현하기 위해 <strong>재귀 함수</strong>를 이용했다. 또한 이번 문제는 백준에서 출제된 <a href="https://langoustinee.github.io/java/101-post/">하노이의 탑 이동순서</a> 문제와 굉장히 유사하니 해당 문제를 풀었다면 해당 문제도 쉽게 풀 수 있을 것이다.</p>

<p>재귀를 이용해 하노이의 탑에서 원판을 이동시킬 때, 첫번째 탑에서 두번째 탑으로 이동해야할 <strong>N-1개의 원판들은 재귀함수를 통해 원판이 1개가 남을 때까지 이동</strong>하게 된다.</p>

<p>문제의 예시처럼 첫번째 탑에 있는 2개의 원판을 마지막 탑으로 최소한의 과정을 통해 옮기기 위해서는 아래와 같은 과정이 필요하다.</p>

<blockquote>
  <ol>
    <li>첫번째 원판을 시작 탑에서 중간 탑으로 옮긴다.</li>
    <li>두번째 원판을 시작 탑에서 마지막 탑으로 옮긴다.</li>
    <li>중간 탑에 남아있던 첫번째 원판을 중간 탑에서 마지막 탑으로 옮긴다.</li>
  </ol>
</blockquote>

<p>위 과정을 재귀로 풀어내는 방법을 알았으니, 해당 과정에서 일어나는 이동과정을 배열에 담아서 2차원 배열로 반환하면 되는 것이다.</p>

<p>그렇게 문제풀이를 위한 아이디어는 생각해보니 다음과 같았다.</p>

<ol>
  <li>n개의 원판을 지정해 하노이 재귀 함수를 호출한다.</li>
  <li>재귀 함수를 통해 원판을 시작 탑에서 마지막 탑까지 옮긴다.</li>
  <li>원판을 옮기는 과정에서 <strong>원판이 어느 탑에서 어느 탑으로 옮겨졌는지에 대한 정보를 담아 2차원 배열 형태로 반환</strong>한다.</li>
</ol>

<p><br /></p>

<p>다음으로 문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre></td><td class="rouge-code"><pre>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="c1">// 이동시 첫번째 탑과 </span>
    <span class="kd">static</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

    <span class="kd">public</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="cm">/**
         * 3개의 탑을 두고 하노이 함수 실행
         * 첫번째 탑에 n개의 원판이 존재한다.
         */</span>
        <span class="n">hanoi</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>

        <span class="c1">// Stream을 활용해 ArrayList&lt;int[]&gt; 타입을 int[][] 타입으로 변환하여 반환한다.</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">answer</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">stream</span><span class="o">().</span><span class="na">toArray</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]::</span><span class="k">new</span><span class="o">);</span>

        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">hanoi</span><span class="o">(</span><span class="kt">int</span> <span class="n">first</span><span class="o">,</span> <span class="kt">int</span> <span class="n">center</span><span class="o">,</span> <span class="kt">int</span> <span class="n">last</span><span class="o">,</span> <span class="kt">int</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
        <span class="cm">/**
         * 옮겨야 할 원판이 1개 남았다면 재귀를 종료한다.
         * 재귀 도중, 탑의 원판 이동여부를 result에 담는다.
         */</span>
        <span class="k">if</span><span class="o">(</span><span class="no">N</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">first</span><span class="o">,</span> <span class="n">last</span><span class="o">});</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
            <span class="n">hanoi</span><span class="o">(</span><span class="n">first</span><span class="o">,</span> <span class="n">last</span><span class="o">,</span> <span class="n">center</span><span class="o">,</span> <span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
            <span class="n">result</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">first</span><span class="o">,</span> <span class="n">last</span><span class="o">});</span>
            <span class="n">hanoi</span><span class="o">(</span><span class="n">center</span><span class="o">,</span> <span class="n">first</span><span class="o">,</span> <span class="n">last</span><span class="o">,</span> <span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>        
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>        
        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>

    <span class="o">}</span>

<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<p>-</p>

<hr />

<p><br /></p>

<h3 id="출처">출처</h3>
<p>-</p>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://school.programmers.co.kr/learn/courses/30/lessons/12946">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 2 - 하노이의 탑]]></summary></entry><entry><title type="html">[Java] 백준(골드-5) 14719번 - 빗물</title><link href="http://localhost:4000/java/260-post/" rel="alternate" type="text/html" title="[Java] 백준(골드-5) 14719번 - 빗물" /><published>2023-08-25T00:00:00+09:00</published><updated>2023-08-25T00:00:00+09:00</updated><id>http://localhost:4000/java/260-post</id><content type="html" xml:base="http://localhost:4000/java/260-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 요구사항대로 잘 <strong>구현</strong>하면 된다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>빗물이 고이기 위한 조건은 무엇일까?</p>

<ol>
  <li>현재 블록의 높이보다 높은 블록이 왼쪽에 있어야 한다.</li>
  <li>현재 블록의 높이보다 높은 블록이 오른쪽에 있어야 한다.</li>
  <li>첫 블록과, 마지막 블록에는 빗물이 고일 수 없다.</li>
</ol>

<p>아이디어 자체는 단순하다. 이 조건을 문제 풀이를 위한 아이디어로 접목시켜 보자.</p>

<ol>
  <li><strong>첫 블록과 마지막 블록을 제외한 블록들을 탐색</strong>한다.</li>
  <li>기둥들을 탐색하며 현재 기둥을 기준으로 <strong>왼쪽으로 가장 높은 기둥</strong>과, <strong>오른쪽으로 가장 높은 기둥</strong>을 구한다.</li>
  <li>현재 기둥이 양 옆의 기둥의 높이보다 낮다면 <strong>왼쪽, 오른쪽 기둥 중 낮은 기둥 높이 값에서 현재 기둥 높이값을 빼준다.</strong></li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
                
                <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                <span class="kt">int</span> <span class="no">H</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                <span class="kt">int</span> <span class="no">W</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

                <span class="kt">int</span><span class="o">[]</span> <span class="n">heights</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">W</span><span class="o">];</span>

                <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">W</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="n">heights</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                <span class="o">}</span>
                
                <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

                <span class="c1">// 1. 현재 블록 높이보다 왼쪽 블록이 높아야 한다.</span>
                <span class="c1">// 2. 현재 블록 높이보다 오른쪽 블록이 높아야 한다.</span>
                <span class="c1">// 3. 첫 줄 블록과 마지막 줄의 블록에는 빗물이 고일 수 없다.</span>

                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">W</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    
                    <span class="c1">// 현재 기둥</span>
                    <span class="kt">int</span> <span class="n">now</span> <span class="o">=</span> <span class="n">heights</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
                    
                    <span class="c1">// 왼쪽, 오른쪽 기둥 높이를 담을 변수</span>
                    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

                    <span class="c1">// 왼쪽에서 가장 높은 기둥을 구한다.</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                        <span class="n">left</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">heights</span><span class="o">[</span><span class="n">j</span><span class="o">],</span> <span class="n">left</span><span class="o">);</span>
                    <span class="o">}</span>
                    
                    <span class="c1">// 오른쪽에서 가장 높은 기둥을 구한다.</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="no">W</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                        <span class="n">right</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">heights</span><span class="o">[</span><span class="n">j</span><span class="o">],</span> <span class="n">right</span><span class="o">);</span>
                    <span class="o">}</span>

                    <span class="cm">/**
                     * 현재 블록이 왼쪽, 오른쪽 블록보다 낮다면,
                     * 둘 중 더 낮은 기둥의 높이값으로 현재 기둥 높이값을 빼준다.
                     */</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">now</span> <span class="o">&lt;</span> <span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">now</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">result</span> <span class="o">+=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="o">-</span> <span class="n">now</span><span class="o">;</span>
                    <span class="o">}</span>

                <span class="o">}</span>
                
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
        <span class="o">}</span>

    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/14719">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[14719번 - 빗물]]></summary></entry><entry><title type="html">[Java] 백준(골드-4) 9019번 - DSLR</title><link href="http://localhost:4000/java/259-post/" rel="alternate" type="text/html" title="[Java] 백준(골드-4) 9019번 - DSLR" /><published>2023-08-23T00:00:00+09:00</published><updated>2023-08-23T00:00:00+09:00</updated><id>http://localhost:4000/java/259-post</id><content type="html" xml:base="http://localhost:4000/java/259-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 <strong>너비 우선 탐색 BFS</strong>을 응용하여 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>여태 BFS를 이용하며, 지도 배열에서 상,하,좌,우를 탐색할 dx, dy 배열을 이용했지만, 이번 문제는 D,S,L,R이라는 특수 명령마다 탐색해가며 누적되는 문자열을 반환해야 하는 문제이기에 별도의 레지스터 값과 문자열을 담을 클래스를 이용하게 되었다.</p>

<p>그렇게, A라는 수를 B로 표현할 수 있는 최소한의 방법인 <strong>수행할 명령을 나열한 문자열</strong>을 출력하는 방법을 살펴보자.</p>

<ol>
  <li>BFS를 통해 A라는 수를 D,S,L,R 명령을 통해 변환한다.</li>
  <li>문제의 요구사항을 잘 살펴서 D, S, L, R 명령을 수행한다.(자세한 내용은 아래에서 확인!)</li>
  <li>D,S,L,R 명령을 수행하며 변환된 레지스터 값이 B가 된다면 탐색을 종료한다.</li>
  <li>변환 과정에서 수행한 명령을 문자열로 출력하면 된다.</li>
</ol>

<blockquote>
  <p>D,S,L,R 명령 수행</p>
  <ul>
    <li>D: 수를 2배로 바꾸고 10000으로 나눈 나머지로 갱신한다.</li>
    <li>S: 수를 0일 때, 9999, 아니면 1을 빼준다</li>
    <li>L: 왼쪽으로 자리수를 바꾼다. <br /> <code class="language-plaintext highlighter-rouge">1234 -&gt; 2341, 1234를 1000으로 나눈 나머지(234)에 10을 곱함=2340, 1234를 1000으로 나누면 1, 2340+1=2341</code></li>
    <li>R: 오른쪽으로 자리수를 바꾼다. <br /><code class="language-plaintext highlighter-rouge">1234 -&gt; 4123, 1234를 10으로 나눈 나머지에 1000 곱합 = 4000, 1234를 10으로 나누면 123, 4000+123=4123</code></li>
  </ul>
</blockquote>

<p>이때, <strong>현재까지의 레지스터값과 수행한 명령어를 담을 Register라는 클래스를 사용</strong>하였다.</p>

<p>그렇게 모든 경우에서 4가지 명령어를 실행하고 각각의 실행한 경우에서 또 명령어를 실행하도록 반복하였고 결국, 변환된 값이 B가 되었을때 누적된 문자열(명령어)를 반환하도록 구현했다.</p>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// 방문 배열 선언</span>
    <span class="kd">static</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span><span class="o">;</span>
    
    <span class="c1">// D,S,L,R 명령을 담을 배열 선언</span>
    <span class="kd">static</span> <span class="kt">char</span><span class="o">[]</span> <span class="n">cmds</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[]{</span><span class="sc">'D'</span><span class="o">,</span> <span class="sc">'S'</span><span class="o">,</span> <span class="sc">'L'</span><span class="o">,</span> <span class="sc">'R'</span><span class="o">};</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
                
                <span class="kt">int</span> <span class="no">T</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                <span class="k">while</span><span class="o">(</span><span class="no">T</span> <span class="o">--&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    
                    <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                    <span class="kt">int</span> <span class="no">A</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="kt">int</span> <span class="no">B</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

                    <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="mi">10000</span><span class="o">];</span>
                    
                    <span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">bfs</span><span class="o">(</span><span class="no">A</span><span class="o">,</span> <span class="no">B</span><span class="o">);</span>
                    <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>

                <span class="o">}</span>

        <span class="o">}</span>

    <span class="o">}</span>

    <span class="c1">// D,S,L,R 만큼 너비우번 탐색을 진행할 bfs 함수</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">bfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Register</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">Register</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="s">""</span><span class="o">));</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">start</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

        <span class="k">while</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            
            <span class="nc">Register</span> <span class="n">now</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
        
            <span class="c1">// 만약 A와 B가 같다면 변환이 성공한 것이니 탐색을 종료한다.</span>
            <span class="k">if</span><span class="o">(</span><span class="n">now</span><span class="o">.</span><span class="na">num</span> <span class="o">==</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">now</span><span class="o">.</span><span class="na">command</span><span class="o">;</span>
            <span class="o">}</span>
            
            <span class="c1">// D,S,L,R 4번을 반복한다.</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">change</span> <span class="o">=</span> <span class="n">changeRegister</span><span class="o">(</span><span class="n">now</span><span class="o">.</span><span class="na">num</span><span class="o">,</span> <span class="n">cmds</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">change</span><span class="o">])</span> <span class="o">{</span>
                    <span class="n">visited</span><span class="o">[</span><span class="n">change</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">Register</span><span class="o">(</span><span class="n">change</span><span class="o">,</span> <span class="n">now</span><span class="o">.</span><span class="na">command</span> <span class="o">+</span> <span class="n">cmds</span><span class="o">[</span><span class="n">i</span><span class="o">]));</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * D,S,L,R 명령별 기능을 수행할 함수
     * D: 수를 2배로 바꾸고 10000으로 나눈 나머지로 갱신한다.
     * S: 수를 0일 때, 9999, 아니면 1을 빼준다 
     * L: 왼쪽으로 자리수를 바꾼다.
     * R: 오른쪽으로 자리수를 바꾼다.
     */</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">changeRegister</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">,</span> <span class="kt">char</span> <span class="n">cmd</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">switch</span><span class="o">(</span><span class="n">cmd</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">case</span> <span class="sc">'D'</span><span class="o">:</span>
                <span class="n">num</span> <span class="o">*=</span> <span class="mi">2</span><span class="o">;</span>
                <span class="k">if</span><span class="o">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="mi">9999</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">num</span> <span class="o">%=</span> <span class="mi">10000</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="sc">'S'</span><span class="o">:</span>
                <span class="n">num</span> <span class="o">-=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="k">if</span><span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">num</span> <span class="o">=</span> <span class="mi">9999</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="sc">'L'</span><span class="o">:</span>
                <span class="kt">int</span> <span class="n">tmp_l1</span> <span class="o">=</span> <span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="mi">1000</span><span class="o">)</span> <span class="o">*</span> <span class="mi">10</span><span class="o">;</span>
                <span class="kt">int</span> <span class="n">tmp_l2</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="mi">1000</span><span class="o">;</span>
                <span class="n">num</span> <span class="o">=</span> <span class="n">tmp_l1</span> <span class="o">+</span> <span class="n">tmp_l2</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="sc">'R'</span><span class="o">:</span>
                <span class="kt">int</span> <span class="n">tmp_r1</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="mi">10</span><span class="o">;</span>
                <span class="kt">int</span> <span class="n">tmp_r2</span> <span class="o">=</span> <span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="mi">10</span><span class="o">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="o">;</span>
                <span class="n">num</span> <span class="o">=</span> <span class="n">tmp_r1</span> <span class="o">+</span> <span class="n">tmp_r2</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">default</span><span class="o">:</span>
                <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">num</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// register값과 수행한 명령을 담을 Register 클래스</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Register</span> <span class="o">{</span>
        
        <span class="kt">int</span> <span class="n">num</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">command</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">Register</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">,</span> <span class="nc">String</span> <span class="n">command</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">num</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">command</span> <span class="o">=</span> <span class="n">command</span><span class="o">;</span>
        <span class="o">}</span>
        
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/9019">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[9019번 - DSLR]]></summary></entry></feed>