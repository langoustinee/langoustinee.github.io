<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-10-12T00:02:59+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">lango’s DevLog</title><subtitle>developer</subtitle><author><name>lango</name></author><entry><title type="html">[Java] 백준(브론즈-2) 13458번 - 시험 감독</title><link href="http://localhost:4000/java/278-post/" rel="alternate" type="text/html" title="[Java] 백준(브론즈-2) 13458번 - 시험 감독" /><published>2023-10-11T00:00:00+09:00</published><updated>2023-10-11T00:00:00+09:00</updated><id>http://localhost:4000/java/278-post</id><content type="html" xml:base="http://localhost:4000/java/278-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 사칙 연산을 통해 간단하게 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>바로 문제 풀이를 위한 아이디어를 살펴보자.</p>

<ol>
  <li>먼저 응시장 별로 최소 총 감독관이 N명만큼 필요하기에 <strong>필요한 감독관의 수를 N으로 두고 시작</strong>한다.</li>
  <li>반복문을 통해 응시장별 <strong>응시자 수에서 총 감독관이 감독할 수 있는 수(B)만큼 차감</strong>한다.</li>
  <li>총 감독관의 감독 수만큼 차감한 후 응시장 별 응시자 수가 <strong>0 이하라면 부감독관이 필요없기에</strong> 다음 순회로 넘어간다.</li>
  <li>응시장별 응시자 수마다 <strong>부감독관이 감독할 수 있는 수(C)로 나눈만큼 부감독관 수가 필요</strong>하기에 나눈 값을 감독관 수에 더해준다.</li>
  <li><strong>C로 나눈 나머지가 0이 아니라면</strong>, 부감독관이 추가적으로 1명 더 필요하기에 감독관 수에 1을 더해주면 된다.</li>
</ol>

<p>위와 같이 나눗셈과 나머지를 잘 유의하면 풀면 쉽게 풀 수 있다.</p>

<blockquote>
  <p>또한 감독관의 수는 시험장의 개수와 학생 수를 고려해 int형이 아닌 long형으로 선언하여 풀어야 한다.</p>
</blockquote>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
                
                <span class="c1">// 응시장 개수</span>
                <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                
                <span class="c1">// 응시장 별 응시자 수를 담을 배열 선언 후 입력받음.</span>
                <span class="kt">int</span><span class="o">[]</span> <span class="n">candidates</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>

                <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="n">candidates</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                <span class="o">}</span>

                <span class="c1">// 총 감독관이 감독할 수 있는 수 B와 부 감독관이 감독할 수 있는 수 C 입력받음.</span>
                <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                <span class="kt">int</span> <span class="no">B</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                <span class="kt">int</span> <span class="no">C</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

                <span class="c1">// 감독관 수는 총 N개에 응시장에 총 감독관이 최소 1명씩 배치되므로 N부터 시작한다.</span>
                <span class="c1">// 시험장의 개수와 학생 수가 최대 1,000,000이기에 int형이 아닌 long형으로 선언해야 한다.</span>
                <span class="kt">long</span> <span class="n">viewerCnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="n">viewerCnt</span> <span class="o">+=</span> <span class="no">N</span><span class="o">;</span>

                <span class="cm">/**
                 * 1. 먼저, 총 감독관이 감시할 수 있는 수를 차감한다. 이때, 각 응시장별로 0명 이하라면, 부감독관이 필요 없기에 continue한다.
                 * 2. 0명 이상이라면, 부감독관이 필요하기 때문에 응시장 별 남은 응시자 수를 C로 나눈 값만큼을 감독관 수로 늘린다.
                 * 3. 이후 응시장별 남은 응시자 수를 C로 나눈 나머지가 0이 아니라면 추가적으로 부감독관이 필요한 것이기에 마지막으로 감독관 수를 1 늘린다.
                 */</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="n">candidates</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-=</span> <span class="no">B</span><span class="o">;</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">candidates</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">continue</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="n">viewerCnt</span> <span class="o">+=</span> <span class="n">candidates</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">/</span> <span class="no">C</span><span class="o">;</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">candidates</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">%</span> <span class="no">C</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">viewerCnt</span><span class="o">++;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">viewerCnt</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>           
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/13458">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[13458번 - 시험 감독]]></summary></entry><entry><title type="html">[Java] 백준(골드-5) 12865번 - 평범한 배낭</title><link href="http://localhost:4000/java/277-post/" rel="alternate" type="text/html" title="[Java] 백준(골드-5) 12865번 - 평범한 배낭" /><published>2023-10-09T00:00:00+09:00</published><updated>2023-10-09T00:00:00+09:00</updated><id>http://localhost:4000/java/277-post</id><content type="html" xml:base="http://localhost:4000/java/277-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>유명한 배낭 문제 중 하나인 이번 문제는, <strong>조합 최적화</strong> 문제로 <strong>동적 계획법(DP)</strong>로 해결해야 한다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<blockquote>
  <p>배낭 문제의 경우 짐을 쪼갤 수 있는 문제(Fraction Knapsack Problem)와 짐을 쪼갤 수 없는 문제(0/1 Knapsack Problem)로 나눠진다. 알고리즘 또한 다르게 적용하는데, Fraction Knapsack Problem은 그리디 알고리즘을, 0/1 Knapsack Problem의 경우 DP를 사용한다.</p>
</blockquote>

<p>이번 문제는 짐을 쪼갤 수 없는 배낭문제이기에 DP로 풀어야 한다. N개만큼의 무게와 가치들을 토대로 수용가능한 최대 무게를 구하기 위한 규칙을 살펴보자.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">i/dp</th>
      <th style="text-align: center">0</th>
      <th style="text-align: center">1</th>
      <th style="text-align: center">2</th>
      <th style="text-align: center">3</th>
      <th style="text-align: center">4</th>
      <th style="text-align: center">5</th>
      <th style="text-align: center">6</th>
      <th>7</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">13</td>
      <td>13</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">8</td>
      <td style="text-align: center">8</td>
      <td style="text-align: center">13</td>
      <td>13</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">6</td>
      <td style="text-align: center">8</td>
      <td style="text-align: center">8</td>
      <td style="text-align: center">13</td>
      <td><strong>14</strong></td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">6</td>
      <td style="text-align: center">8</td>
      <td style="text-align: center">12</td>
      <td style="text-align: center">13</td>
      <td><strong>14</strong></td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p>위 표를 보면, i에 따른 무게와 가치별로 누적 탐색해가며, 수용가능한 무게(dp)에 따라 최대 가치를 구해보았다. 이떄, DP를 통한 메모이제이션을 이용해 <strong>이전 i값에 대한 값을 바로 반환할 수 있도록 구현하는 것이 중요</strong>하다.</p>

<p>표에서 볼 수 있듯이, 우리는 <strong>수용가능한 무게가 7일 경우 6+8=14 의 값이 가장 큰 가치 값</strong>으로 저장되어 이를 구해야 하는 것을 알 수 있다. 이를 위한 점화식은 다음과 같다.</p>

<h4 id="점화식">점화식</h4>
<ul>
  <li><code class="language-plaintext highlighter-rouge">DP[i][k] = max(DP[i-1][k], DP[i-1][k - W[i]] + V[i])</code></li>
</ul>

<p>필자는 재귀함수를 이용한 Top-Down 방식으로 재귀 로직을 구현하였다. 재귀 호출을 통해서 현재 물건에 추가적으로 다른 물건을 담을 수 있는지 살피고, 위 점화식을 토대로 최대 가치가 되는 값을 DP 테이블에 갱신해나가는 방식이다.</p>

<p>간단하게 문제 풀이를 위한 아이디어를 정리해보자.</p>

<ol>
  <li>2차원 배열인 DP 테이블과 1차원 배열인 무게(W), 가치(V) 배열을 선언한다.</li>
  <li>DP 테이블은 DP[N][K+1]로 초기화, 입력값을 통해 W, V 배열에 값을 삽입한다.</li>
  <li>재귀함수를 호출하여 메모이제이션된 값이면 바로 값을 반환한다.</li>
  <li>메모이제이션 되지 않은(탐색하지 않은) 위치라면, 현재 물건을 추가로 담을 수 있는지, 없는지 확인한다.</li>
  <li>현재 물건을 추가로 담을 수 없다면, 현재 물건의 가치를 저장한다.</li>
  <li>현재 물건에 추가로 담을 수 있다면, 앞서 구한 점화식을 적용하여 더 큰 가치 값을 DP 테이블에 갱신하고 반환한다.</li>
</ol>

<blockquote>
  <p>W, V 배열은 인덱스가 0부터 시작하기 때문에 i=0일 때를 고려해야 한다.</p>
</blockquote>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// DP 테이블 선언</span>
    <span class="kd">static</span> <span class="nc">Integer</span><span class="o">[][]</span> <span class="no">DP</span><span class="o">;</span>

    <span class="c1">// 물건의 무게와 가치를 담을 W, V 배열 선언</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="no">W</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="no">V</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>

                <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                <span class="kt">int</span> <span class="no">K</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

                <span class="c1">// 2차원 DP 테이블 초기화</span>
                <span class="no">DP</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Integer</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">K</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>

                <span class="c1">// 무게와 가치를 담기 위한 1차원 배열 초기화</span>
                <span class="no">W</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
                <span class="no">V</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>

                <span class="c1">// 무게와 가치를 N번만큼 입력받는다.</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                    <span class="no">W</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="no">V</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                <span class="o">}</span>

                <span class="c1">// DP 테이블을 갱신하기 위해 Top-Down 방식의 재귀 호출</span>
                <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">knapsack</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="no">K</span><span class="o">);</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
                
                
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">knapsack</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
        <span class="o">}</span>   
        <span class="c1">// 탐색하지 않았다면</span>
        <span class="k">if</span><span class="o">(</span><span class="no">DP</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 현재 물건을 추가로 담지 못할 경우</span>
            <span class="k">if</span><span class="o">(</span><span class="no">W</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
                <span class="no">DP</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">knapsack</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="cm">/**
             * 현재 물건을 담을 수 있는 경우
             * 이전 i값과 이전 i값에 대한 k-W[i]의 값 + 현재 가치(V[i]) 중에서 더 큰 값을 DP 테이블에 저장한다.
             */</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="no">DP</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">knapsack</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">k</span><span class="o">),</span> <span class="n">knapsack</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">k</span> <span class="o">-</span> <span class="no">W</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">+</span> <span class="no">V</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="o">}</span>
            
        <span class="o">}</span>
        <span class="k">return</span> <span class="no">DP</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">];</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/12865">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[12865번 - 평범한 배낭]]></summary></entry><entry><title type="html">[Java] 백준(실버-2) 16953번 - A → B</title><link href="http://localhost:4000/java/276-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-2) 16953번 - A → B" /><published>2023-10-05T00:00:00+09:00</published><updated>2023-10-05T00:00:00+09:00</updated><id>http://localhost:4000/java/276-post</id><content type="html" xml:base="http://localhost:4000/java/276-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 너비 우선 탐색인 <strong>BFS</strong>를 이용해 풀 수도 있지만 A→B가 아닌 B→A로 생각해보면 <strong>그리디 알고리즘</strong>을 이용해서도 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>처음에는 단순히 BFS를 이용해, A에서 B가 되기 위해 2가지 연산을 반복하여 최소의 연산횟수로 B가 될 수 있는지를 구하는 로직을 세웠지만, 이것을 반대로 생각하여 B에서 A로 바꾸는 로직을 통해 보다 쉽게 풀 수 있었다.</p>

<p>B에서 A로 바꾸는 아이디어는 다음과 같다.</p>

<ol>
  <li><strong>B가 2로 나누어 떨어지지 않거나, 맨 끝자리가 1이 아니라면 A로 만들 수 없기</strong>에 반복문을 종료한다.</li>
  <li>B가 2로 나누어 떨어진다면, B를 2로 나눈다.</li>
  <li>B의 맨 끝자리가 1이라면, 1을 없앤다.</li>
  <li>2, 3번 과정이 성립할 때마다 연산횟수 카운트를 1개씩 증가시키고, A가 B와 같아지면 반복문을 종료한다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>

                <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                <span class="kt">int</span> <span class="no">A</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                <span class="kt">int</span> <span class="no">B</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                
                <span class="c1">// 연산횟수는 1부터 시작한다.</span>
                <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

                <span class="k">while</span><span class="o">(</span><span class="no">A</span> <span class="o">!=</span> <span class="no">B</span><span class="o">)</span> <span class="o">{</span>
                    <span class="c1">// B가 A보다 작다면 A를 B로 바꿀 수 없다.</span>
                    <span class="k">if</span><span class="o">(</span><span class="no">B</span> <span class="o">&lt;</span> <span class="no">A</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="cm">/**
                     * B가 2로 나누어 떨어진다면, B를 2로 나눈다.
                     * B의 끝자리가 1이라면, 1을 없앤다.
                     * B가 2로 나누어 떨어지지 않거나, 끝 자리 수가 1이 아니라면 A를 B로 바꿀 수 없기에 순회를 종료한다.
                     */</span>
                    <span class="k">if</span><span class="o">(</span><span class="no">B</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        <span class="no">B</span> <span class="o">/=</span> <span class="mi">2</span><span class="o">;</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="no">B</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                        <span class="no">B</span> <span class="o">/=</span> <span class="mi">10</span><span class="o">;</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="c1">// 연산 횟수를 1 증가시킨다.</span>
                    <span class="n">result</span><span class="o">++;</span>
                <span class="o">}</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>       
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/16953">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[16953번 - A → B]]></summary></entry><entry><title type="html">[Java] 백준(실버-1) 1325번 - 효율적인 해킹</title><link href="http://localhost:4000/java/275-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-1) 1325번 - 효율적인 해킹" /><published>2023-09-29T00:00:00+09:00</published><updated>2023-09-29T00:00:00+09:00</updated><id>http://localhost:4000/java/275-post</id><content type="html" xml:base="http://localhost:4000/java/275-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 <strong>너비 우선 탐색인 BFS</strong>를 이용해 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>이번 문제에서는 컴퓨터를 노드, 연결된 신뢰도를 에지라고 생각하고 BFS 탐색을 수행했다.</p>

<p>A와 B에 관계에 대해서 유의할 점은 다음과 같다.</p>
<blockquote>
  <ul>
    <li>A가 B를 신뢰하는 경우 <strong>B를 해킹하면 A도 해킹</strong>할 수 있는데, 반대의 경우, 즉 A가 B를 신뢰하는 경우 <strong>A를 해킹한다고 B가 해킹되는 것은 아니다.</strong></li>
    <li>한 번의 해킹으로 <strong>동시에 해킹할 수 있는 컴퓨터의 수가 가장 많은 수</strong>를 찾아야 한다.</li>
    <li>또한, 동시에 해킹할 수 있는 컴퓨터의 <strong>최대 갯수가 동일한 컴퓨터가 여러 대일 수도 있다</strong>는 점을 고려한다.</li>
  </ul>
</blockquote>

<p>위 내용을 염두에 두고 문제를 풀기위한 아이디어를 정리해보자.</p>

<ol>
  <li>BFS 탐색을 수행하면서 해킹할 수 있는 컴퓨터, 즉 <strong>신뢰도가 있는 컴퓨터라면 그 수를 카운트</strong>한다. (이때, 필자는 카운트배열로 신뢰도를 관리했다.)</li>
  <li>컴퓨터별로 신뢰도 수가 담긴 배열에서 가장 많은 컴퓨터를 해킹할 수 있는 컴퓨터의 번호를 출력하기 위해 <strong>최댓값</strong>을 구한다.</li>
  <li>최대값과 동일한 컴퓨터의 번호, 인덱스를 순서대로 출력하면 된다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// 방문 배열</span>
    <span class="kd">static</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span><span class="o">;</span>
    <span class="c1">// 인접 배열</span>
    <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="c1">// 노드의 범위 N, 간선의 개수 M 선언</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="no">N</span><span class="o">,</span> <span class="no">M</span><span class="o">;</span>
    <span class="c1">// N개의 컴퓨터간의 신뢰관계를 카운트할 배열</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">count</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>

                <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

                <span class="c1">// 인접배열 초기화</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;());</span>
                <span class="o">}</span>

                <span class="c1">// 인접배열에 신뢰도 삽입</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">M</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                    <span class="kt">int</span> <span class="no">A</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="kt">int</span> <span class="no">B</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="no">A</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="no">B</span><span class="o">);</span>
                <span class="o">}</span>

                <span class="c1">// 컴퓨터별 총 신뢰도를 담기 위해 초기화</span>
                <span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>

                <span class="c1">// 컴퓨터별로 방문배열을 초기화해가며, BFS 탐색 수행</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
                    <span class="n">bfs</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                <span class="o">}</span>

                <span class="c1">// 모든 컴퓨터 중 가장 높은 신뢰도를 구한다.</span>
                <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">count</span><span class="o">).</span><span class="na">max</span><span class="o">().</span><span class="na">getAsInt</span><span class="o">();</span>

                <span class="c1">// 가장 높은 신뢰도를 가지는 컴퓨터일 경우 오름차순으로 출력한다.</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">count</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">count</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">max</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                
        <span class="o">}</span>

    <span class="o">}</span>
    
    <span class="cm">/**
     * BFS 함수
     * 노드별로 너비우선탐색을 하며, 신뢰관계에 놓인 컴퓨터를 탐색하여 해당 컴퓨터의 신뢰도를 갱신한다.
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">bfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">node</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">now</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">next</span> <span class="o">:</span> <span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">now</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">next</span><span class="o">])</span> <span class="o">{</span>
                    <span class="n">visited</span><span class="o">[</span><span class="n">next</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">next</span><span class="o">);</span>
                    <span class="n">count</span><span class="o">[</span><span class="n">next</span><span class="o">]++;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/1325">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[1325번 - 효율적인 해킹]]></summary></entry><entry><title type="html">[Java] 백준(실버-4) 1158번 - 요세푸스 문제</title><link href="http://localhost:4000/java/273-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-4) 1158번 - 요세푸스 문제" /><published>2023-09-12T00:00:00+09:00</published><updated>2023-09-12T00:00:00+09:00</updated><id>http://localhost:4000/java/273-post</id><content type="html" xml:base="http://localhost:4000/java/273-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 <strong>큐</strong>를 이용해 문제의 요구사항을 구현하면 되는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>큐를 이용한 접근 방식은 단순하다.</p>

<ol>
  <li>1에서 N까지의 수를 큐에 삽입한다.</li>
  <li><strong>K-1번째 수까지는 첫 번째 값을 맨 뒤로</strong> 보낸다.</li>
  <li><strong>K번째 수일 경우, 큐에서 추출하여 출력</strong>한다.</li>
  <li>2-3번 과정을 <strong>큐의 사이즈가 1개일 때까지 반복</strong>한다.</li>
  <li>마지막 남은 1개의 원소를 출력한다.</li>
</ol>

<p>위 아이디어대로 큐를 이용해 구현하면 쉽게 풀 수 있는 문제였다.</p>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
                
                <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                <span class="kt">int</span> <span class="no">K</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

                <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"&lt;"</span><span class="o">);</span>

                <span class="c1">// 1. 1부터 N-1까지 큐에 삽입한다.</span>
                <span class="c1">// 2. K-1번째 까지는 큐의 첫째 값을 맨 뒤로 보낸다.</span>
                <span class="c1">// 3. K번째에는 삽입하여 출력한다.</span>

                <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                <span class="o">}</span>

                <span class="cm">/**
                 * 큐의 원소가 1개 남을 때까지 반복한다.
                 * K-1번째까지는 첫 원소를 맨 뒤로 보낸다.
                 * K번째 값은 추출하여 출력한다.
                 */</span>
                <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="k">while</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">idx</span> <span class="o">==</span> <span class="no">K</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">()+</span> <span class="s">", "</span><span class="o">);</span>
                        <span class="n">idx</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                        <span class="k">continue</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="kt">int</span> <span class="n">first</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">first</span><span class="o">);</span>
                    <span class="n">idx</span><span class="o">++;</span>
                <span class="o">}</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">()</span> <span class="o">+</span><span class="s">"&gt;"</span><span class="o">);</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">sb</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
                
        <span class="o">}</span>
    <span class="o">}</span>    
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/1158">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[1158번 - 요세푸스 문제]]></summary></entry><entry><title type="html">[Java] 백준(실버-1) 2615번 - 오목</title><link href="http://localhost:4000/java/274-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-1) 2615번 - 오목" /><published>2023-09-12T00:00:00+09:00</published><updated>2023-09-12T00:00:00+09:00</updated><id>http://localhost:4000/java/274-post</id><content type="html" xml:base="http://localhost:4000/java/274-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 <strong>너비 우선 탐색인 BFS를 잘 응용</strong>하면 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>문제의 요구사항을 보면, 연속으로 5알이 놓인 오목은 정상이나, <strong>6알인 육목이나 7알인 칠목의 경우는 조건 달성 실패</strong>라고 한다. 예륻 들어 흰돌이 6알, 검은돌이 5알이면 흰돌이 아닌 검은돌이 이기는 것이다.</p>

<p>먼저 오목판의 길이는 최대 19이기에 시간복잡도 측면에서 크게 걱정하지 않겠다고 느꼈고, 연속적으로 놓인 5알을 1칸씩 이동하며 찾을 방법을 BFS를 떠올리게 되었다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dx</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>
<span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>먼저 오목의 경우 대각선 방향을 고려해야 하기에 상,하,좌,우 대각선까지 8방향으로 탐색을 해야한다고 생각했다. 그런데 <strong>8 방향으로 모두 탐색할 경우, 5알이 놓였는지, 5알 이상이 놓였는지를 구하기가 매우 까다로웠다.</strong></p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="c1">// 가로, 세로, 오른쪽 위 대각선, 왼쪽 위 대각선 4 방향으로 탐색하기 위한 dx, dy 배열</span>
<span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dx</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>
<span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>그래서 8 방향으로 탐색하는 것이 아니라 <strong>가로, 세로, 오른쪽 대각선, 왼쪽 대각선만을 생각하여 탐색</strong>하는데, <strong>연속으로 4알 이상이 놓인 돌일 경우, 진행방향의 반대방향에 같은 돌이 놓였는지 함께 체크하면서 탐색</strong>하도록 진행하였다.</p>
</blockquote>

<p>이를 통해 아이디어를 정리해보자.</p>

<ol>
  <li>오목판 2차원 배열을 입력받고, 검은돌(1)과 흰돌(2)일 경우 <strong>가로(1,0), 세로(0,1), 오른쪽 위 대각선(1,1), 왼쪽 위 대각선(-1,1)</strong> 4 방향으로 BFS 탐색을 진행한다.</li>
  <li>4 방향마다 이어진 같은 돌이 놓였는지 체크하면서, 오목이 놓였는지를 확인한다.</li>
  <li>5알이 놓였을 경우 <strong>처음 돌이 놓인 시작위치의 반대 4 방향으로 탐색하며 6알 이상이 놓였는지</strong> 추가로 체크한다.</li>
  <li>특정 알의 진행방향과 반대방향 모두 확인하여 5알인 오목이 놓였을 경우 해당 돌이 이긴 것으로 간주하여 해당 돌의 색상과 오목판의 위치를 출력한다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// 가로, 세로, 오른쪽 위 대각선, 왼쪽 위 대각선 4 방향으로 탐색하기 위한 dx, dy 배열</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dx</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>

    <span class="c1">// 입력배열과 방문 배열 선언</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">arr</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
                
                <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">19</span><span class="o">][</span><span class="mi">19</span><span class="o">];</span>

                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">19</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">19</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                        <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="o">}</span>
                <span class="o">}</span>

                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">19</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">19</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                        <span class="c1">// 오목판에 검은돌과 흰돌일 경우만 BFS를 수행한다.</span>
                        <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>
                                <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">bfs</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
                                <span class="k">if</span><span class="o">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">5</span><span class="o">)</span> <span class="o">{</span>
                                    <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]+</span><span class="s">"\n"</span><span class="o">);</span>
                                    <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">((</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span> <span class="o">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">)+</span><span class="s">"\n"</span><span class="o">);</span>
                                    <span class="k">return</span><span class="o">;</span>
                                <span class="o">}</span>
                            <span class="o">}</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="c1">// 위 탐색과정에서 return 되지 않으면 승부가 결정나지 않았기에 0을 출력한다.</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"0"</span> <span class="o">+</span> <span class="s">"\n"</span><span class="o">);</span>
                
        <span class="o">}</span>

    <span class="o">}</span>    

    <span class="c1">// 오목판 배열을 탐색할 BFS 함수</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">bfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="mi">1</span><span class="o">));</span>
        
        <span class="c1">// 특정 돌의 연속으로 놓여진 갯수</span>
        <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">while</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">Node</span> <span class="n">now</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">now</span><span class="o">.</span><span class="na">cnt</span><span class="o">);</span>

            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="na">x</span> <span class="o">+</span> <span class="n">dx</span><span class="o">[</span><span class="n">dir</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="na">y</span> <span class="o">+</span> <span class="n">dy</span><span class="o">[</span><span class="n">dir</span><span class="o">];</span>

            <span class="c1">// 오목판 범위를 벗어나는지 체크한다.</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">isRange</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">))</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// 흰돌은 흰돌끼리, 검은돌은 검은돌끼리 탐색할 돌이 같은 돌인지 체크한다.</span>
            <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="n">arr</span><span class="o">[</span><span class="n">now</span><span class="o">.</span><span class="na">x</span><span class="o">][</span><span class="n">now</span><span class="o">.</span><span class="na">y</span><span class="o">])</span> <span class="o">{</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">now</span><span class="o">.</span><span class="na">cnt</span><span class="o">+</span><span class="mi">1</span><span class="o">));</span>
            
        <span class="o">}</span>
        <span class="cm">/**
         * 흰돌과 검은돌 중 오목을 달성했을 때,
         * 해당 돌이 6개 이상인지를 확인하기 위해 시작돌의 반대방향을 체크한다.
         */</span> 
        <span class="k">if</span><span class="o">(</span><span class="n">max</span> <span class="o">==</span> <span class="mi">5</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">dx</span><span class="o">[</span><span class="n">dir</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">dy</span><span class="o">[</span><span class="n">dir</span><span class="o">];</span>

            <span class="c1">// 오목판 범위는 벗어나지 않고 같은 돌이라면 육목 이상이다.</span>
            <span class="k">if</span><span class="o">(</span><span class="n">isRange</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="n">arr</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">max</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">max</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="c1">// 오목판 배열 범위 체크 함수</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isRange</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">&lt;</span><span class="mi">19</span> <span class="o">&amp;&amp;</span> <span class="n">y</span><span class="o">&lt;</span><span class="mi">19</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    
<span class="o">}</span>

<span class="c1">// 이동할 돌의 위치와 이어진 갯수를 담을 클래스</span>
<span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">cnt</span><span class="o">;</span>

    <span class="nc">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">cnt</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">cnt</span> <span class="o">=</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/2615">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[2615번 - 오목]]></summary></entry><entry><title type="html">[Java] 백준(실버-1) 7562번 - 나이트의 이동</title><link href="http://localhost:4000/java/272-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-1) 7562번 - 나이트의 이동" /><published>2023-09-11T00:00:00+09:00</published><updated>2023-09-11T00:00:00+09:00</updated><id>http://localhost:4000/java/272-post</id><content type="html" xml:base="http://localhost:4000/java/272-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 <strong>너비 우선 탐색인 BFS</strong>를 이용해 풀 수 있다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>보통, BFS를 이용하여 상,하,좌,우 4 방향으로 이동하는 문제가 많지만, 이번 문제에서는 <strong>이동할 수 있는 구간이 8 방향임을 고려</strong>하여 접근해야 한다.</p>

<p>나이트의 이동반경을 체스판 위에서 x,y 좌표로 살펴보자.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">x 좌표</th>
      <th style="text-align: center">y 좌표</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">-2</td>
      <td style="text-align: center">-1</td>
    </tr>
    <tr>
      <td style="text-align: center">-2</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">-1</td>
      <td style="text-align: center">-2</td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">-2</td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">-1</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">1</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p>위와 같이 8방향으로 BFS 탐색을 진행하면 된다. 이제 문제풀이를 위한 아이디어는 정리해보자.</p>

<ol>
  <li>각 테스트케이스마다 체스판의 변의 길이와 체스판 배열, 방문 배열을 초기화한다.</li>
  <li>나이트의 시작위치와 목표위치를 입력받아 <strong>BFS 탐색을 진행하는데, 나이트의 시작위치를 먼저 큐에 삽입하여 탐색</strong>한다.</li>
  <li>BFS를 통해 나이트가 이동할 때마다(큐에 새로 삽입될 때마다) 이동횟수를 1씩 증가시킨다.</li>
  <li>BFS를 탐색하며 <strong>현재 나이트의 위치가 목표위치에 도달하게되면 탐색을 종료</strong>하고 여태까지의 이동횟수를 출력한다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// 체스판의 크기 선언</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="no">N</span><span class="o">;</span>

    <span class="c1">// 나이트 이동할 수 있는 8칸</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dx</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{-</span><span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>

    <span class="c1">// 체스판 입력배열과 방문 배열 선언</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">arr</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">visited</span><span class="o">;</span>

    <span class="c1">// 나이트의 시작위치와 종료위치를 담을 배열 선언</span>
    <span class="kd">static</span> <span class="nc">Node</span><span class="o">[]</span> <span class="n">nodes</span><span class="o">;</span>

    <span class="kd">static</span> <span class="kt">int</span> <span class="n">result</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
                
                <span class="c1">// 1. 나이트는 총 8방향으로 움직일 수 있다.</span>
                <span class="c1">// 2. 나이트의 시작위치에서 BFS를 통해 탐색해가며 종료위치가 될 경우 탐색을 종료한다.</span>
                <span class="c1">// 3. 탐색 종료 후 이동횟수를 출력한다.</span>

                <span class="kt">int</span> <span class="no">T</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                <span class="k">while</span><span class="o">(</span><span class="no">T</span> <span class="o">--&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                    <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">N</span><span class="o">];</span>
                    <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">N</span><span class="o">];</span>

                    <span class="c1">// 나이트의 시작위치와 목표위치를 담는다.</span>
                    <span class="n">nodes</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                        <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                        <span class="n">nodes</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>
                    <span class="o">}</span>

                    <span class="c1">// 나이트의 총 이동횟수를 담기 위한 초기화</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

                    <span class="c1">// BFS 함수 호출하여 탐색을 시작한다.</span>
                    <span class="n">bfs</span><span class="o">();</span>
                    
                    <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
                <span class="o">}</span>
                
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">bfs</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 큐에 시작위치를 담고, 방문 여부를 체크한다.</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">nodes</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">nodes</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">x</span><span class="o">][</span><span class="n">nodes</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">y</span><span class="o">]</span> <span class="o">=</span><span class="kc">true</span><span class="o">;</span>
        
        <span class="c1">// 이동해야할 목표 위치</span>
        <span class="nc">Node</span> <span class="n">target</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>

        <span class="k">while</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">Node</span> <span class="n">now</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>

            <span class="c1">// 현재 위치가 종료 위치가 될 경우 탐색을 종료한다.</span>
            <span class="k">if</span><span class="o">(</span><span class="n">now</span><span class="o">.</span><span class="na">x</span> <span class="o">==</span> <span class="n">target</span><span class="o">.</span><span class="na">x</span> <span class="o">&amp;&amp;</span> <span class="n">now</span><span class="o">.</span><span class="na">y</span> <span class="o">==</span> <span class="n">target</span><span class="o">.</span><span class="na">y</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="na">cnt</span><span class="o">;</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">dir</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">dir</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">;</span> <span class="n">dir</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="na">x</span> <span class="o">+</span> <span class="n">dx</span><span class="o">[</span><span class="n">dir</span><span class="o">];</span>
                <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="na">y</span> <span class="o">+</span> <span class="n">dy</span><span class="o">[</span><span class="n">dir</span><span class="o">];</span>
                
                <span class="k">if</span><span class="o">(!</span><span class="n">isRange</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
                    <span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">now</span><span class="o">.</span><span class="na">cnt</span><span class="o">+</span><span class="mi">1</span><span class="o">));</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isRange</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">&lt;</span><span class="no">N</span> <span class="o">&amp;&amp;</span> <span class="n">y</span><span class="o">&lt;</span><span class="no">N</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>

<span class="cm">/**
 * Node 클래스는 x,y 좌표와 이동횟수를 가진다.
 * x,y좌표만을 받아 Node의 인스턴스를 생성한다.
 * x,y좌표 및 cnt(이동횟수)를 받아 위치를 이동하는 Node의 인스턴스를 생성한다.
 */</span>
<span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
    
    <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">cnt</span><span class="o">;</span>
    
    <span class="nc">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nc">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">cnt</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">cnt</span> <span class="o">=</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/7562">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[7562번 - 나이트의 이동]]></summary></entry><entry><title type="html">[Java] 백준(실버-1) 1932번 - 정수 삼각형</title><link href="http://localhost:4000/java/271-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-1) 1932번 - 정수 삼각형" /><published>2023-09-08T00:00:00+09:00</published><updated>2023-09-08T00:00:00+09:00</updated><id>http://localhost:4000/java/271-post</id><content type="html" xml:base="http://localhost:4000/java/271-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 <strong>동적 계획법 DP</strong>를 이용해 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>이번에는 재귀가 아닌 <strong>반복문을 활용한 Bottom-Up 방식</strong>으로 풀었다.</p>

<p>문제풀이를 위한 과정을 살펴보자면, 정수 삼각형의 꼭대기부터 아래로 내려가면서 누적합을 구해가는데 최하단 층까지 누적합을 구했다면, 최하단 층에서 가장 큰 최댓값을 구하면 된다.</p>

<h4 id="점화식-세우기">점화식 세우기</h4>
<p>그렇다면 이제, 동적 계획법을 이용한 DP 점화식을 세워보자.</p>

<p>아래 층으로 내려가면서 선택된 수는 대각선 왼쪽 위, 대각선 오른쪽 위의 수들 중 더 큰 값을 선택하게 된다. 이를 문제에 접근하기 위한 인덱스로 표현하자면 다음과 같다.</p>

<ul>
  <li>대각선 왼쪽 위<strong>(i-1, j-1)</strong></li>
  <li>대각선 오른쪽 위<strong>(i-1, j)</strong></li>
</ul>

<p>결국, 삼각형의 아래 층으로 내려가면서(탐색) <strong>현재 층의 수는 대각선 왼쪽 위, 오른쪽 수중 큰수와 현재 층의 수인 현재값을 더해가면서 갱신</strong>해가면 되는 것이다! 이를 토대로 <code class="language-plaintext highlighter-rouge">D[i][j] = (i, j)</code>에 도착했을 때 누적합의 최댓값을 구해야 한다고 보면 된다.</p>

<blockquote>
  <p>점화식: <strong><code class="language-plaintext highlighter-rouge">DP[i][j] = max(D[i-1][j-1], D[i-1][j]) + triangle[i][j]</code></strong></p>
</blockquote>

<p>이 점화식을 토대로 정수 삼각형을 탐색하며 DP 테이블을 갱신한 뒤, DP 테이블의 최하층에 누적합 중 가장 큰 값을 출력하면 된다.</p>

<ol>
  <li>정수 삼각형의 크기만큼 순회하며, DP 점화식을 통해 DP 테이블에 누적합을 갱신한다.</li>
  <li>이때, <code class="language-plaintext highlighter-rouge">대각선 왼쪽 위, 오른쪽 위중 큰 값 + 현재값</code>을 DP 테이블의 현재값으로 갱신한다.</li>
  <li>DP 테이블 갱신이 모두 끝나면, 최하단 층 누적합에서 최대값을 출력한다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// DP 테이블 선언</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="no">D</span><span class="o">;</span>

    <span class="c1">// 정수 삼각형 배열 선언</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">triangle</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
                
                <span class="c1">// 1. 정수 삼각형의 꼭대기부터 아래로 내려가면서 값을 누적해가며, 최하층에서 최댓값을 구해야 한다.</span>
                <span class="c1">// 2. DP 테이블의 최하단 층에 정수 삼각형의 선택지를 통한 최댓값을 누적하여 갱신한다.</span>
                <span class="c1">// 3. DP 테이블의 최하단 층까지 갱신이 완료되면, 최하단 층에서 최댓값을 구한다.</span>

                <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

                <span class="n">triangle</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
                <span class="no">D</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>

                <span class="c1">// 정수 삼각형 배열을 입력받는다.</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                        <span class="n">triangle</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="o">}</span>
                <span class="o">}</span>

                <span class="cm">/**
                 * DP 테이블 갱신
                 * 점화식: 대각선 왼쪽 위(i-1, j-1), 대각선 오른쪽 위(i-1, j) 중 큰 값 + 현재값
                 * D[i][j] = max(D[i-1][j-1], D[i-1][j]) + triangle[i][j]
                 */</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                        <span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">],</span> <span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">])</span> <span class="o">+</span> <span class="n">triangle</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                    <span class="o">}</span>
                <span class="o">}</span>

                <span class="c1">// DP 테이블의 최하층에서 최댓값을 구한다.</span>
                <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">max</span> <span class="o">&lt;</span> <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                        <span class="n">max</span> <span class="o">=</span> <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="n">i</span><span class="o">];</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">max</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
                
        <span class="o">}</span>

    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/1932">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[1932번 - 정수 삼각형]]></summary></entry><entry><title type="html">[Java] 프로그래머스(level-2) - 2개 이하로 다른 비트</title><link href="http://localhost:4000/java/270-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-2) - 2개 이하로 다른 비트" /><published>2023-09-05T00:00:00+09:00</published><updated>2023-09-05T00:00:00+09:00</updated><id>http://localhost:4000/java/270-post</id><content type="html" xml:base="http://localhost:4000/java/270-post/"><![CDATA[<p><br /></p>

<center><img src="/assets/images/programmers/" width="100%" /></center>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />

<p>이번 문제는 문제의 요구사항대로 비트를 활용해 <strong>구현</strong>하면 되는 문제이다.</p>

<p><br /></p>

<h4 id="아아디어-도출">아아디어 도출</h4>

<blockquote>
  <p>비트연산자를 활용하면 풀 수 있을 것으로 보이나 필자는 비트연산에 대해서 부족한 점이 많아 규칙을 찾아서 풀었다.</p>
</blockquote>

<p>정수를 비트(2진수)로 변환한 후, 이 수보다 큰 수이면서 비트일 때의 차이가 1~2개이여야 한다. 여기서 어떤 규칙을 찾아낼 수 있을까?</p>

<p>먼저 십진수 1부터 6까지를 비트로 표현해보자.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">십진수/비트</th>
      <th style="text-align: center">16</th>
      <th style="text-align: center">8</th>
      <th style="text-align: center">4</th>
      <th style="text-align: center">2</th>
      <th style="text-align: center">1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><em>1</em></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center"><em>2</em></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">0</td>
    </tr>
    <tr>
      <td style="text-align: center"><em>3</em></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center"><em>4</em></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
    </tr>
    <tr>
      <td style="text-align: center"><em>5</em></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center"><em>6</em></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">0</td>
    </tr>
  </tbody>
</table>

<p>잘보면 짝수일 때는 모두 0으로 끝나는 것을 알 수 있다. 그렇다면 여기서 짝수의 규칙을 찾아낼 수 있다!</p>

<blockquote>
  <p><strong>짝수일 때의 규칙</strong>
비트의 끝자리가 0인, 즉 짝수인 십진수의 경우 <strong>+1인 값이 조건에 충족</strong>된다. <br />
Ex. <code class="language-plaintext highlighter-rouge">2(10) -&gt; 3(11)</code>, <code class="language-plaintext highlighter-rouge">4(100) -&gt; 5(101)</code>, <code class="language-plaintext highlighter-rouge">6(110) -&gt; 7(111)</code></p>
</blockquote>

<p>짝수의 규칙은 쉽지만, 홀수의 규칙을 찾기가 어려웠다. 홀수의 경우는 끝자리가 1인데, <strong>비트값을 기준으로 0이 섞인 홀수와 0이 없는 홀수로 나뉘게 된다.</strong></p>

<blockquote>
  <p><strong>홀수일 때의 규칙</strong></p>
  <ol>
    <li>0이 존재할 경우, <strong>하위 비트에서부터 “01”을 찾아 “10”으로 바꾼다.</strong> <br />
Ex. <code class="language-plaintext highlighter-rouge">5(101) -&gt; "1" + "10" = "110"</code>, <code class="language-plaintext highlighter-rouge">9(1001) -&gt; "10" + "10" = "1010"</code></li>
    <li>0이 없을 경우, 큰 수이면서 가까운 수이려면 <strong>상위비트에 0을 삽입</strong>한다. <br />
Ex. <code class="language-plaintext highlighter-rouge">7(111) -&gt; "10" + "11" = "1011"</code>, <code class="language-plaintext highlighter-rouge">11111 -&gt; "10" + "1111" =&gt; "101111"</code></li>
  </ol>
</blockquote>

<p>위와 같이 주어진 수가 짝수일 경우와 홀수일 경우를 나누어 규칙을 반영하여 조건에 맞는 십진수를 배열에 담아 반환하면 된다.</p>

<p><br /></p>

<p>다음으로 문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre></td><td class="rouge-code"><pre>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">long</span><span class="o">[]</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">long</span><span class="o">[]</span> <span class="n">numbers</span><span class="o">)</span> <span class="o">{</span>
    
        <span class="kt">long</span><span class="o">[]</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="n">numbers</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">numbers</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            
            <span class="cm">/*
             * numbers의 원소가 짝수일 경우
             * 해당 수의 바로 다음 비트는 다른 점이 1개이면서 큰 수라는 조건을 충족한다.
             * f(n) = n + 1
             */</span>
            <span class="k">if</span><span class="o">(</span><span class="n">numbers</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            
            <span class="cm">/*
             * numbers의 원소가 홀수일 경우
             * 해당 수의 최하위 비트(마지막)부터 "01"을 찾아 "01"이 있다면, "10"으로 바꿔준다.
             * "01"이 없다면 최상위 비트(처음)를 제거하고 "10"을 추가한다.
             * 변환한 비트인 2진수를 Long형 타입으로 변환하여 배열에 삽입한다.
             */</span>
            <span class="nc">String</span> <span class="n">binary</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">toBinaryString</span><span class="o">(</span><span class="n">numbers</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            
            <span class="c1">// 해당 2진수에서 "01"의 인덱스를 마지막 비트에서부터 찾아 "10"으로 변환한다.</span>
            <span class="kt">int</span> <span class="n">zeroIdx</span> <span class="o">=</span> <span class="n">binary</span><span class="o">.</span><span class="na">lastIndexOf</span><span class="o">(</span><span class="s">"01"</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">zeroIdx</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">binary</span> <span class="o">=</span> <span class="n">binary</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">zeroIdx</span><span class="o">)</span> <span class="o">+</span> <span class="s">"10"</span> <span class="o">+</span> <span class="n">binary</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">zeroIdx</span><span class="o">+</span><span class="mi">2</span><span class="o">,</span> <span class="n">binary</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
                <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">parseLong</span><span class="o">(</span><span class="n">binary</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            
            <span class="c1">// "01"이 없다면 상위 비트 하나를 제거하고 "10"을 삽입한다.</span>
            <span class="n">binary</span> <span class="o">=</span> <span class="s">"10"</span> <span class="o">+</span> <span class="n">binary</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">binary</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
            <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">parseLong</span><span class="o">(</span><span class="n">binary</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>

        <span class="o">}</span>

        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        
        <span class="kt">long</span><span class="o">[]</span> <span class="n">numbers</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[]{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">};</span>
        <span class="c1">// long[] numbers = new long[]{5, 7, 11};</span>
        <span class="c1">// long[] numbers = new long[]{1001,337}; // 1002, 338</span>
        
        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">numbers</span><span class="o">);</span>

    <span class="o">}</span>

<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<p>-</p>

<hr />

<p><br /></p>

<h3 id="출처">출처</h3>
<p>-</p>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://school.programmers.co.kr/learn/courses/30/lessons/77885">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 2 - 2개 이하로 다른 비트]]></summary></entry><entry><title type="html">[Java] 프로그래머스(level-2) - 2xn 타일링</title><link href="http://localhost:4000/java/269-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-2) - 2xn 타일링" /><published>2023-09-05T00:00:00+09:00</published><updated>2023-09-05T00:00:00+09:00</updated><id>http://localhost:4000/java/269-post</id><content type="html" xml:base="http://localhost:4000/java/269-post/"><![CDATA[<p><br /></p>

<center><img src="/assets/images/programmers/" width="100%" /></center>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />

<p>이번 문제는 <strong>동적 계획법 DP</strong>를 이용해 손쉽게 풀 수 있다.</p>

<p><br /></p>

<h4 id="아아디어-도출">아아디어 도출</h4>

<p>이 문제는 백준의 <a href="https://langoustinee.github.io/java/226-post/">2×n 타일링</a> 문제와 거의 유사한 문제이다.</p>

<p>문제의 자세한 풀이는 해당 문제와 거의 동일해서 위 링크를 참조하기 바란다. 간단히 문제 핵심 아이디어만 살펴보고 넘어가자.</p>

<p>2xn 타일링 문제는 피보나치 수열과 동일한 구조를 가지고 있기에 <strong>DP를 이용해 피보나치 수열을 DP 테이블에 갱신</strong>하면 된다.</p>

<ol>
  <li>DP를 이용해 피보나치 수열의 N번째 수를 피보나치 함수로 구현한다.</li>
  <li>이미 구한 N번째 수일 경우 바로 반환(메모이제이션)한다.</li>
</ol>

<blockquote>
  <p>백준의 문제와 다른 점은 백준에서는 <code class="language-plaintext highlighter-rouge">경우의 수 % 10,007</code> 이었다면, 프로그래머스에서의 문제에서는 <code class="language-plaintext highlighter-rouge">경우의 수 % 1,000,000,007</code>의 차이만 있다고 보면 된다.</p>
</blockquote>

<p><br /></p>

<p>다음으로 문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="rouge-code"><pre>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="no">D</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>

        <span class="no">D</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>

        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="no">D</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>

        <span class="no">D</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="no">D</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="k">return</span> <span class="nf">fibo</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">fibo</span><span class="o">(</span><span class="kt">int</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="n">fibo</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">fibo</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">2</span><span class="o">))</span> <span class="o">%</span> <span class="mi">1000000007</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
        
        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>

    <span class="o">}</span>

<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<p>-</p>

<hr />

<p><br /></p>

<h3 id="출처">출처</h3>
<p>-</p>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://school.programmers.co.kr/learn/courses/30/lessons/12900">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 2 - 2xn 타일링]]></summary></entry></feed>