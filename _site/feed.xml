<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-09-12T10:49:30+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">lango’s DevLog</title><subtitle>developer</subtitle><author><name>lango</name></author><entry><title type="html">[Java] 백준(실버-4) 1158번 - 요세푸스 문제</title><link href="http://localhost:4000/java/273-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-4) 1158번 - 요세푸스 문제" /><published>2023-09-12T00:00:00+09:00</published><updated>2023-09-12T00:00:00+09:00</updated><id>http://localhost:4000/java/273-post</id><content type="html" xml:base="http://localhost:4000/java/273-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 <strong>큐</strong>를 이용해 문제의 요구사항을 구현하면 되는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>큐를 이용한 접근 방식은 단순하다.</p>

<ol>
  <li>1에서 N까지의 수를 큐에 삽입한다.</li>
  <li><strong>K-1번째 수까지는 첫 번째 값을 맨 뒤로</strong> 보낸다.</li>
  <li><strong>K번째 수일 경우, 큐에서 추출하여 출력</strong>한다.</li>
  <li>2-3번 과정을 <strong>큐의 사이즈가 1개일 때까지 반복</strong>한다.</li>
  <li>마지막 남은 1개의 원소를 출력한다.</li>
</ol>

<p>위 아이디어대로 큐를 이용해 구현하면 쉽게 풀 수 있는 문제였다.</p>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
                
                <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                <span class="kt">int</span> <span class="no">K</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

                <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"&lt;"</span><span class="o">);</span>

                <span class="c1">// 1. 1부터 N-1까지 큐에 삽입한다.</span>
                <span class="c1">// 2. K-1번째 까지는 큐의 첫째 값을 맨 뒤로 보낸다.</span>
                <span class="c1">// 3. K번째에는 삽입하여 출력한다.</span>

                <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                <span class="o">}</span>

                <span class="cm">/**
                 * 큐의 원소가 1개 남을 때까지 반복한다.
                 * K-1번째까지는 첫 원소를 맨 뒤로 보낸다.
                 * K번째 값은 추출하여 출력한다.
                 */</span>
                <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="k">while</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">idx</span> <span class="o">==</span> <span class="no">K</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">()+</span> <span class="s">", "</span><span class="o">);</span>
                        <span class="n">idx</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                        <span class="k">continue</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="kt">int</span> <span class="n">first</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">first</span><span class="o">);</span>
                    <span class="n">idx</span><span class="o">++;</span>
                <span class="o">}</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">()</span> <span class="o">+</span><span class="s">"&gt;"</span><span class="o">);</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">sb</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
                
        <span class="o">}</span>
    <span class="o">}</span>    
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/1158">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[1158번 - 요세푸스 문제]]></summary></entry><entry><title type="html">[Java] 백준(실버-1) 7562번 - 나이트의 이동</title><link href="http://localhost:4000/java/272-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-1) 7562번 - 나이트의 이동" /><published>2023-09-11T00:00:00+09:00</published><updated>2023-09-11T00:00:00+09:00</updated><id>http://localhost:4000/java/272-post</id><content type="html" xml:base="http://localhost:4000/java/272-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 <strong>너비 우선 탐색인 BFS</strong>를 이용해 풀 수 있다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>보통, BFS를 이용하여 상,하,좌,우 4 방향으로 이동하는 문제가 많지만, 이번 문제에서는 <strong>이동할 수 있는 구간이 8 방향임을 고려</strong>하여 접근해야 한다.</p>

<p>나이트의 이동반경을 체스판 위에서 x,y 좌표로 살펴보자.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">x 좌표</th>
      <th style="text-align: center">y 좌표</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">-2</td>
      <td style="text-align: center">-1</td>
    </tr>
    <tr>
      <td style="text-align: center">-2</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center">-1</td>
      <td style="text-align: center">-2</td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">-2</td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">2</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">-1</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">1</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<p>위와 같이 8방향으로 BFS 탐색을 진행하면 된다. 이제 문제풀이를 위한 아이디어는 정리해보자.</p>

<ol>
  <li>각 테스트케이스마다 체스판의 변의 길이와 체스판 배열, 방문 배열을 초기화한다.</li>
  <li>나이트의 시작위치와 목표위치를 입력받아 <strong>BFS 탐색을 진행하는데, 나이트의 시작위치를 먼저 큐에 삽입하여 탐색</strong>한다.</li>
  <li>BFS를 통해 나이트가 이동할 때마다(큐에 새로 삽입될 때마다) 이동횟수를 1씩 증가시킨다.</li>
  <li>BFS를 탐색하며 <strong>현재 나이트의 위치가 목표위치에 도달하게되면 탐색을 종료</strong>하고 여태까지의 이동횟수를 출력한다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// 체스판의 크기 선언</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="no">N</span><span class="o">;</span>

    <span class="c1">// 나이트 이동할 수 있는 8칸</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dx</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{-</span><span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">};</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">};</span>

    <span class="c1">// 체스판 입력배열과 방문 배열 선언</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">arr</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">visited</span><span class="o">;</span>

    <span class="c1">// 나이트의 시작위치와 종료위치를 담을 배열 선언</span>
    <span class="kd">static</span> <span class="nc">Node</span><span class="o">[]</span> <span class="n">nodes</span><span class="o">;</span>

    <span class="kd">static</span> <span class="kt">int</span> <span class="n">result</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
                
                <span class="c1">// 1. 나이트는 총 8방향으로 움직일 수 있다.</span>
                <span class="c1">// 2. 나이트의 시작위치에서 BFS를 통해 탐색해가며 종료위치가 될 경우 탐색을 종료한다.</span>
                <span class="c1">// 3. 탐색 종료 후 이동횟수를 출력한다.</span>

                <span class="kt">int</span> <span class="no">T</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                <span class="k">while</span><span class="o">(</span><span class="no">T</span> <span class="o">--&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                    <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">N</span><span class="o">];</span>
                    <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">N</span><span class="o">];</span>

                    <span class="c1">// 나이트의 시작위치와 목표위치를 담는다.</span>
                    <span class="n">nodes</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">[</span><span class="mi">2</span><span class="o">];</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                        <span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                        <span class="n">nodes</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>
                    <span class="o">}</span>

                    <span class="c1">// 나이트의 총 이동횟수를 담기 위한 초기화</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

                    <span class="c1">// BFS 함수 호출하여 탐색을 시작한다.</span>
                    <span class="n">bfs</span><span class="o">();</span>
                    
                    <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
                <span class="o">}</span>
                
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">bfs</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">// 큐에 시작위치를 담고, 방문 여부를 체크한다.</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Node</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">nodes</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">nodes</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">x</span><span class="o">][</span><span class="n">nodes</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">y</span><span class="o">]</span> <span class="o">=</span><span class="kc">true</span><span class="o">;</span>
        
        <span class="c1">// 이동해야할 목표 위치</span>
        <span class="nc">Node</span> <span class="n">target</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">[</span><span class="mi">1</span><span class="o">];</span>

        <span class="k">while</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="nc">Node</span> <span class="n">now</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>

            <span class="c1">// 현재 위치가 종료 위치가 될 경우 탐색을 종료한다.</span>
            <span class="k">if</span><span class="o">(</span><span class="n">now</span><span class="o">.</span><span class="na">x</span> <span class="o">==</span> <span class="n">target</span><span class="o">.</span><span class="na">x</span> <span class="o">&amp;&amp;</span> <span class="n">now</span><span class="o">.</span><span class="na">y</span> <span class="o">==</span> <span class="n">target</span><span class="o">.</span><span class="na">y</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="na">cnt</span><span class="o">;</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">dir</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">dir</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">;</span> <span class="n">dir</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="na">x</span> <span class="o">+</span> <span class="n">dx</span><span class="o">[</span><span class="n">dir</span><span class="o">];</span>
                <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">now</span><span class="o">.</span><span class="na">y</span> <span class="o">+</span> <span class="n">dy</span><span class="o">[</span><span class="n">dir</span><span class="o">];</span>
                
                <span class="k">if</span><span class="o">(!</span><span class="n">isRange</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
                    <span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">Node</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">,</span> <span class="n">now</span><span class="o">.</span><span class="na">cnt</span><span class="o">+</span><span class="mi">1</span><span class="o">));</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isRange</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">&lt;</span><span class="no">N</span> <span class="o">&amp;&amp;</span> <span class="n">y</span><span class="o">&lt;</span><span class="no">N</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>

<span class="cm">/**
 * Node 클래스는 x,y 좌표와 이동횟수를 가진다.
 * x,y좌표만을 받아 Node의 인스턴스를 생성한다.
 * x,y좌표 및 cnt(이동횟수)를 받아 위치를 이동하는 Node의 인스턴스를 생성한다.
 */</span>
<span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
    
    <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">cnt</span><span class="o">;</span>
    
    <span class="nc">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nc">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">cnt</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">cnt</span> <span class="o">=</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/7562">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[7562번 - 나이트의 이동]]></summary></entry><entry><title type="html">[Java] 백준(실버-1) 1932번 - 정수 삼각형</title><link href="http://localhost:4000/java/271-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-1) 1932번 - 정수 삼각형" /><published>2023-09-08T00:00:00+09:00</published><updated>2023-09-08T00:00:00+09:00</updated><id>http://localhost:4000/java/271-post</id><content type="html" xml:base="http://localhost:4000/java/271-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 <strong>동적 계획법 DP</strong>를 이용해 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>이번에는 재귀가 아닌 <strong>반복문을 활용한 Bottom-Up 방식</strong>으로 풀었다.</p>

<p>문제풀이를 위한 과정을 살펴보자면, 정수 삼각형의 꼭대기부터 아래로 내려가면서 누적합을 구해가는데 최하단 층까지 누적합을 구했다면, 최하단 층에서 가장 큰 최댓값을 구하면 된다.</p>

<h4 id="점화식-세우기">점화식 세우기</h4>
<p>그렇다면 이제, 동적 계획법을 이용한 DP 점화식을 세워보자.</p>

<p>아래 층으로 내려가면서 선택된 수는 대각선 왼쪽 위, 대각선 오른쪽 위의 수들 중 더 큰 값을 선택하게 된다. 이를 문제에 접근하기 위한 인덱스로 표현하자면 다음과 같다.</p>

<ul>
  <li>대각선 왼쪽 위<strong>(i-1, j-1)</strong></li>
  <li>대각선 오른쪽 위<strong>(i-1, j)</strong></li>
</ul>

<p>결국, 삼각형의 아래 층으로 내려가면서(탐색) <strong>현재 층의 수는 대각선 왼쪽 위, 오른쪽 수중 큰수와 현재 층의 수인 현재값을 더해가면서 갱신</strong>해가면 되는 것이다! 이를 토대로 <code class="language-plaintext highlighter-rouge">D[i][j] = (i, j)</code>에 도착했을 때 누적합의 최댓값을 구해야 한다고 보면 된다.</p>

<blockquote>
  <p>점화식: <strong><code class="language-plaintext highlighter-rouge">DP[i][j] = max(D[i-1][j-1], D[i-1][j]) + triangle[i][j]</code></strong></p>
</blockquote>

<p>이 점화식을 토대로 정수 삼각형을 탐색하며 DP 테이블을 갱신한 뒤, DP 테이블의 최하층에 누적합 중 가장 큰 값을 출력하면 된다.</p>

<ol>
  <li>정수 삼각형의 크기만큼 순회하며, DP 점화식을 통해 DP 테이블에 누적합을 갱신한다.</li>
  <li>이때, <code class="language-plaintext highlighter-rouge">대각선 왼쪽 위, 오른쪽 위중 큰 값 + 현재값</code>을 DP 테이블의 현재값으로 갱신한다.</li>
  <li>DP 테이블 갱신이 모두 끝나면, 최하단 층 누적합에서 최대값을 출력한다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// DP 테이블 선언</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="no">D</span><span class="o">;</span>

    <span class="c1">// 정수 삼각형 배열 선언</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">triangle</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
                
                <span class="c1">// 1. 정수 삼각형의 꼭대기부터 아래로 내려가면서 값을 누적해가며, 최하층에서 최댓값을 구해야 한다.</span>
                <span class="c1">// 2. DP 테이블의 최하단 층에 정수 삼각형의 선택지를 통한 최댓값을 누적하여 갱신한다.</span>
                <span class="c1">// 3. DP 테이블의 최하단 층까지 갱신이 완료되면, 최하단 층에서 최댓값을 구한다.</span>

                <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

                <span class="n">triangle</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
                <span class="no">D</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>

                <span class="c1">// 정수 삼각형 배열을 입력받는다.</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                        <span class="n">triangle</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="o">}</span>
                <span class="o">}</span>

                <span class="cm">/**
                 * DP 테이블 갱신
                 * 점화식: 대각선 왼쪽 위(i-1, j-1), 대각선 오른쪽 위(i-1, j) 중 큰 값 + 현재값
                 * D[i][j] = max(D[i-1][j-1], D[i-1][j]) + triangle[i][j]
                 */</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                        <span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">],</span> <span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">])</span> <span class="o">+</span> <span class="n">triangle</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                    <span class="o">}</span>
                <span class="o">}</span>

                <span class="c1">// DP 테이블의 최하층에서 최댓값을 구한다.</span>
                <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">max</span> <span class="o">&lt;</span> <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                        <span class="n">max</span> <span class="o">=</span> <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="n">i</span><span class="o">];</span>
                    <span class="o">}</span>
                <span class="o">}</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">max</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
                
        <span class="o">}</span>

    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/1932">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[1932번 - 정수 삼각형]]></summary></entry><entry><title type="html">[Java] 프로그래머스(level-2) - 2xn 타일링</title><link href="http://localhost:4000/java/269-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-2) - 2xn 타일링" /><published>2023-09-05T00:00:00+09:00</published><updated>2023-09-05T00:00:00+09:00</updated><id>http://localhost:4000/java/269-post</id><content type="html" xml:base="http://localhost:4000/java/269-post/"><![CDATA[<p><br /></p>

<center><img src="/assets/images/programmers/" width="100%" /></center>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />

<p>이번 문제는 <strong>동적 계획법 DP</strong>를 이용해 손쉽게 풀 수 있다.</p>

<p><br /></p>

<h4 id="아아디어-도출">아아디어 도출</h4>

<p>이 문제는 백준의 <a href="https://langoustinee.github.io/java/226-post/">2×n 타일링</a> 문제와 거의 유사한 문제이다.</p>

<p>문제의 자세한 풀이는 해당 문제와 거의 동일해서 위 링크를 참조하기 바란다. 간단히 문제 핵심 아이디어만 살펴보고 넘어가자.</p>

<p>2xn 타일링 문제는 피보나치 수열과 동일한 구조를 가지고 있기에 <strong>DP를 이용해 피보나치 수열을 DP 테이블에 갱신</strong>하면 된다.</p>

<ol>
  <li>DP를 이용해 피보나치 수열의 N번째 수를 피보나치 함수로 구현한다.</li>
  <li>이미 구한 N번째 수일 경우 바로 반환(메모이제이션)한다.</li>
</ol>

<blockquote>
  <p>백준의 문제와 다른 점은 백준에서는 <code class="language-plaintext highlighter-rouge">경우의 수 % 10,007</code> 이었다면, 프로그래머스에서의 문제에서는 <code class="language-plaintext highlighter-rouge">경우의 수 % 1,000,000,007</code>의 차이만 있다고 보면 된다.</p>
</blockquote>

<p><br /></p>

<p>다음으로 문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="rouge-code"><pre>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="no">D</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>

        <span class="no">D</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>

        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="no">D</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>

        <span class="no">D</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="no">D</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

        <span class="k">return</span> <span class="nf">fibo</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">fibo</span><span class="o">(</span><span class="kt">int</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="n">fibo</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">fibo</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">2</span><span class="o">))</span> <span class="o">%</span> <span class="mi">1000000007</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
        
        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>

    <span class="o">}</span>

<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<p>-</p>

<hr />

<p><br /></p>

<h3 id="출처">출처</h3>
<p>-</p>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://school.programmers.co.kr/learn/courses/30/lessons/12900">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 2 - 2xn 타일링]]></summary></entry><entry><title type="html">[Java] 프로그래머스(level-2) - 2개 이하로 다른 비트</title><link href="http://localhost:4000/java/270-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-2) - 2개 이하로 다른 비트" /><published>2023-09-05T00:00:00+09:00</published><updated>2023-09-05T00:00:00+09:00</updated><id>http://localhost:4000/java/270-post</id><content type="html" xml:base="http://localhost:4000/java/270-post/"><![CDATA[<p><br /></p>

<center><img src="/assets/images/programmers/" width="100%" /></center>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />

<p>이번 문제는 문제의 요구사항대로 비트를 활용해 <strong>구현</strong>하면 되는 문제이다.</p>

<p><br /></p>

<h4 id="아아디어-도출">아아디어 도출</h4>

<blockquote>
  <p>비트연산자를 활용하면 풀 수 있을 것으로 보이나 필자는 비트연산에 대해서 부족한 점이 많아 규칙을 찾아서 풀었다.</p>
</blockquote>

<p>정수를 비트(2진수)로 변환한 후, 이 수보다 큰 수이면서 비트일 때의 차이가 1~2개이여야 한다. 여기서 어떤 규칙을 찾아낼 수 있을까?</p>

<p>먼저 십진수 1부터 6까지를 비트로 표현해보자.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">십진수/비트</th>
      <th style="text-align: center">16</th>
      <th style="text-align: center">8</th>
      <th style="text-align: center">4</th>
      <th style="text-align: center">2</th>
      <th style="text-align: center">1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><em>1</em></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center"><em>2</em></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">0</td>
    </tr>
    <tr>
      <td style="text-align: center"><em>3</em></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center"><em>4</em></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">0</td>
    </tr>
    <tr>
      <td style="text-align: center"><em>5</em></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">0</td>
      <td style="text-align: center">1</td>
    </tr>
    <tr>
      <td style="text-align: center"><em>6</em></td>
      <td style="text-align: center"> </td>
      <td style="text-align: center"> </td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">1</td>
      <td style="text-align: center">0</td>
    </tr>
  </tbody>
</table>

<p>잘보면 짝수일 때는 모두 0으로 끝나는 것을 알 수 있다. 그렇다면 여기서 짝수의 규칙을 찾아낼 수 있다!</p>

<blockquote>
  <p><strong>짝수일 때의 규칙</strong>
비트의 끝자리가 0인, 즉 짝수인 십진수의 경우 <strong>+1인 값이 조건에 충족</strong>된다. <br />
Ex. <code class="language-plaintext highlighter-rouge">2(10) -&gt; 3(11)</code>, <code class="language-plaintext highlighter-rouge">4(100) -&gt; 5(101)</code>, <code class="language-plaintext highlighter-rouge">6(110) -&gt; 7(111)</code></p>
</blockquote>

<p>짝수의 규칙은 쉽지만, 홀수의 규칙을 찾기가 어려웠다. 홀수의 경우는 끝자리가 1인데, <strong>비트값을 기준으로 0이 섞인 홀수와 0이 없는 홀수로 나뉘게 된다.</strong></p>

<blockquote>
  <p><strong>홀수일 때의 규칙</strong></p>
  <ol>
    <li>0이 존재할 경우, <strong>하위 비트에서부터 “01”을 찾아 “10”으로 바꾼다.</strong> <br />
Ex. <code class="language-plaintext highlighter-rouge">5(101) -&gt; "1" + "10" = "110"</code>, <code class="language-plaintext highlighter-rouge">9(1001) -&gt; "10" + "10" = "1010"</code></li>
    <li>0이 없을 경우, 큰 수이면서 가까운 수이려면 <strong>상위비트에 0을 삽입</strong>한다. <br />
Ex. <code class="language-plaintext highlighter-rouge">7(111) -&gt; "10" + "11" = "1011"</code>, <code class="language-plaintext highlighter-rouge">11111 -&gt; "10" + "1111" =&gt; "101111"</code></li>
  </ol>
</blockquote>

<p>위와 같이 주어진 수가 짝수일 경우와 홀수일 경우를 나누어 규칙을 반영하여 조건에 맞는 십진수를 배열에 담아 반환하면 된다.</p>

<p><br /></p>

<p>다음으로 문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre></td><td class="rouge-code"><pre>
<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">long</span><span class="o">[]</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">long</span><span class="o">[]</span> <span class="n">numbers</span><span class="o">)</span> <span class="o">{</span>
    
        <span class="kt">long</span><span class="o">[]</span> <span class="n">answer</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="n">numbers</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">numbers</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            
            <span class="cm">/*
             * numbers의 원소가 짝수일 경우
             * 해당 수의 바로 다음 비트는 다른 점이 1개이면서 큰 수라는 조건을 충족한다.
             * f(n) = n + 1
             */</span>
            <span class="k">if</span><span class="o">(</span><span class="n">numbers</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            
            <span class="cm">/*
             * numbers의 원소가 홀수일 경우
             * 해당 수의 최하위 비트(마지막)부터 "01"을 찾아 "01"이 있다면, "10"으로 바꿔준다.
             * "01"이 없다면 최상위 비트(처음)를 제거하고 "10"을 추가한다.
             * 변환한 비트인 2진수를 Long형 타입으로 변환하여 배열에 삽입한다.
             */</span>
            <span class="nc">String</span> <span class="n">binary</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">toBinaryString</span><span class="o">(</span><span class="n">numbers</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            
            <span class="c1">// 해당 2진수에서 "01"의 인덱스를 마지막 비트에서부터 찾아 "10"으로 변환한다.</span>
            <span class="kt">int</span> <span class="n">zeroIdx</span> <span class="o">=</span> <span class="n">binary</span><span class="o">.</span><span class="na">lastIndexOf</span><span class="o">(</span><span class="s">"01"</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(</span><span class="n">zeroIdx</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">binary</span> <span class="o">=</span> <span class="n">binary</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">zeroIdx</span><span class="o">)</span> <span class="o">+</span> <span class="s">"10"</span> <span class="o">+</span> <span class="n">binary</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">zeroIdx</span><span class="o">+</span><span class="mi">2</span><span class="o">,</span> <span class="n">binary</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
                <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">parseLong</span><span class="o">(</span><span class="n">binary</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>
            
            <span class="c1">// "01"이 없다면 상위 비트 하나를 제거하고 "10"을 삽입한다.</span>
            <span class="n">binary</span> <span class="o">=</span> <span class="s">"10"</span> <span class="o">+</span> <span class="n">binary</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">binary</span><span class="o">.</span><span class="na">length</span><span class="o">());</span>
            <span class="n">answer</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">parseLong</span><span class="o">(</span><span class="n">binary</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>

        <span class="o">}</span>

        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        
        <span class="kt">long</span><span class="o">[]</span> <span class="n">numbers</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[]{</span><span class="mi">2</span><span class="o">,</span> <span class="mi">7</span><span class="o">};</span>
        <span class="c1">// long[] numbers = new long[]{5, 7, 11};</span>
        <span class="c1">// long[] numbers = new long[]{1001,337}; // 1002, 338</span>
        
        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">numbers</span><span class="o">);</span>

    <span class="o">}</span>

<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<p>-</p>

<hr />

<p><br /></p>

<h3 id="출처">출처</h3>
<p>-</p>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://school.programmers.co.kr/learn/courses/30/lessons/77885">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 2 - 2개 이하로 다른 비트]]></summary></entry><entry><title type="html">[Java] 백준(실버-2) 11053번 - 가장 긴 증가하는 부분 수열</title><link href="http://localhost:4000/java/268-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-2) 11053번 - 가장 긴 증가하는 부분 수열" /><published>2023-09-04T00:00:00+09:00</published><updated>2023-09-04T00:00:00+09:00</updated><id>http://localhost:4000/java/268-post</id><content type="html" xml:base="http://localhost:4000/java/268-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 <strong>동적 계획법 DP</strong>를 이용해 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>필자는 반복문을 활용한 Bottom-Up 방식이 아닌 재귀 함수를 이용한 Top-Down 방식을 이용해 풀었다.</p>

<p>이번 문제는 이전에 풀었던 <a href="https://langoustinee.github.io/java/232-post/">계단 오르기</a>와 같은 계열의 문제로써, <strong>LIS(최장 증가 부분 수열) 유형의 문제</strong>이다.</p>

<blockquote>
  <p>최장 증가 부분 수열(LIS)란 <strong>주어진 수열에서 오름차순으로 구성 가능한 원소들을 선택하여 최대 길이를 찾아내는 것</strong>이다. 잘 활용하면 O(N logN) 의 시간복잡도를 가진다.</p>
</blockquote>

<p>예제1을 살펴보면, <code class="language-plaintext highlighter-rouge">{10, 20, 10, 30, 20, 50}</code>라는 수열이 주어진다. N의 크기를 가지는 arr 배열에 해당 수열을 담고 DP 테이블에 해당 위치마다의 수열 길이를 메모이제이션하는 방식으로 접근하면 된다.</p>

<blockquote>

  <ol>
    <li>arr[0]=10일 경우 증가 부분 수열은 arr[0]보다 이전 값이 없기에 <strong>{10}이라는 부분 수열만이 존재하여 1의 길이</strong>를 가진다. <code class="language-plaintext highlighter-rouge">DP[0] = 1</code><br /></li>
    <li>arr[1]=20의 경우 arr[0]이 10으로 arr[1]보다 작기때문에 <strong>{10, 20}이라는 부분 수열</strong>을 만들 수 있다. <code class="language-plaintext highlighter-rouge">DP[1] = 2</code><br /></li>
    <li>arr[2]=10의 경우, 이전 값들 중 작은 값이 없기 때문에 <strong>{10} 부분 수열</strong>을 만들 수 있다. <code class="language-plaintext highlighter-rouge">DP[2] = 1</code><br />
…</li>
  </ol>
</blockquote>

<p>위 과정을 N까지 반복하게 되면 <code class="language-plaintext highlighter-rouge">D = {1, 2, 1, 3, 2, 4}</code>라는 DP 테이블을 만들 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="no">DP</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">}</span> <span class="c1">// 길이 1</span>
<span class="no">DP</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">}</span> <span class="c1">// 길이 2</span>
<span class="no">DP</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">}</span> <span class="c1">// 길이 1</span>
<span class="no">DP</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="o">}</span> <span class="c1">// 길이 3</span>
<span class="no">DP</span><span class="o">[</span><span class="mi">4</span><span class="o">]</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">}</span> <span class="c1">// 길이 2</span>
<span class="no">DP</span><span class="o">[</span><span class="mi">5</span><span class="o">]</span> <span class="o">=</span> <span class="o">{</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">,</span> <span class="mi">30</span><span class="o">,</span> <span class="mi">50</span><span class="o">}</span> <span class="c1">// 길이 4</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>위와 같이 부분 수열들의 길이를 DP 테이블의 위치마다 갱신하면 가장 긴 부분수열의 길이는 4라는 것을 알 수 있다.</p>

<p>이를 DP로 어떻게 접근하여 풀 수 있을까? 아이디어를 생각해보자.</p>

<ol>
  <li>일단 <strong>모든 부분 수열의 최소 길이는 1</strong>이기에 탐색시 D[N]의 값을 1로 초기화한다.</li>
  <li>0부터 N-1까지 재귀 호출하여 탐색한다.</li>
  <li>재귀 함수에서는 <strong>N-1부터 0까지 거꾸로 이전 위치까지 다시 찾아나가며</strong>, 현재의 값보다 이전 값들 중 작은 값이 있을 경우 <strong>재귀호출을 통해 작은 값이 있는 위치의 길이와 비교해가며 부분 수열의 길이를 DP 테이블에 갱신</strong>한다.</li>
  <li>DP 테이블 갱신을 완료했다면, DP 테이블의 값 중 최댓값이 가장 긴 부분수열의 길이가 된다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// DP 테이블 선언</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="no">D</span><span class="o">;</span>
    
    <span class="c1">// 수열 입력 배열 선언</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
                
                <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

                <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
                <span class="no">D</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>

                <span class="c1">// DP 테이블의 모든 값을 -1로 초기화</span>
                <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="no">D</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">);</span>

                <span class="c1">// 수열 입력</span>
                <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                <span class="o">}</span>
                
                <span class="c1">// 0부터 N-1까지 재귀함수 호출하여 탐색</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="n">recursion</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
                <span class="o">}</span>

                <span class="c1">// DP 테이블의 최댓값을 구하기 위해 오름차순 정렬</span>
                <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="no">D</span><span class="o">);</span>

                <span class="c1">// DP 테이블의 마지막 원소가 최댓값이 된다.</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="no">D</span><span class="o">[</span><span class="no">D</span><span class="o">.</span><span class="na">length</span><span class="o">-</span><span class="mi">1</span><span class="o">]+</span><span class="s">"\n"</span><span class="o">);</span>
                
        <span class="o">}</span>

    <span class="o">}</span>
    
    <span class="cm">/**
     * DP 테이블을 갱신할 재귀함수
     * 
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">recursion</span><span class="o">(</span><span class="kt">int</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 방문하지 않은 위치라면</span>
        <span class="k">if</span><span class="o">(</span><span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 모든 부분수열의 길이는 최소 1이기에 1로 초기화</span>
            <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
            <span class="cm">/*
             * N-1부터 0까지 탐색하며 현재 값보다 작은 값을 찾는다.
             * 찾을 때, 재귀 호출을 통해 찾아온다.
             */</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="o">[</span><span class="no">N</span><span class="o">])</span> <span class="o">{</span>
                    <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">],</span> <span class="n">recursion</span><span class="o">(</span><span class="n">i</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span>
            <span class="o">}</span>    
        <span class="o">}</span>
        <span class="c1">// 메모이제이션을 통해 방문한 위치의 값을 바로 반환</span>
        <span class="k">return</span> <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/11053">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[11053번 - 가장 긴 증가하는 부분 수열]]></summary></entry><entry><title type="html">[Java] 백준(실버-1) 1149번 - RGB거리</title><link href="http://localhost:4000/java/267-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-1) 1149번 - RGB거리" /><published>2023-09-04T00:00:00+09:00</published><updated>2023-09-04T00:00:00+09:00</updated><id>http://localhost:4000/java/267-post</id><content type="html" xml:base="http://localhost:4000/java/267-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 <strong>동적 계획법 DP</strong>를 이용해 점화식을 세운다면 쉽게 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>처음엔 문제를 잘 이해하기 어려울 수 있다. 하나씩 살펴보며 간단히 정리해보자.</p>

<p>일단 1번부터 N번까지의 집을 색칠해야하는데 이때, 색칠할 수 있는 색의 종류는 빨강, 초록, 파랑 3가지가 주어진다. 그리고 각 집마다 색을 칠하는 비용이 주어진다. 우리는 N번까지의 모든 집을 칠할 때의 최소가 되는 비용을 구해야 한다.</p>

<p>일단 여기까지만 생각해보면, 각 집마다 R,G,B의 비용 중 가장 싼 색을 선택하면 될 것 같은데, 문제의 요구사항을 보면 <strong>근접한 집끼리는 같은 색으로 칠하면 안된다</strong>는 점을 고려해야 한다.</p>

<blockquote>
  <p>예를 들어 3번 집에 초록색을 칠한다면, 2번집과 4번집은 초록색을 칠할 수 없다. 이러한 조건으로 인해 최소 비용을 구할 때 그냥 최솟 비용만을 구한다면 오답이 된다.</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="mi">3</span>
<span class="mi">1</span> <span class="mi">100</span> <span class="mi">103</span>
<span class="mi">1</span> <span class="mi">103</span> <span class="mi">200</span>
<span class="mi">100</span> <span class="mi">1</span> <span class="mi">103</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>위와 같은 예시가 있다고 가정한다면, <code class="language-plaintext highlighter-rouge">1(R) + 103(G) + 100(R) = 204</code>로 조건을 잘 지키며 색을 칠할 수 있다. 하지만 이 비용이 과연 최소비용이 맞을까? 아니다. <code class="language-plaintext highlighter-rouge">100(G) + 1(R) + 1(G) = 102</code>가 정답이 된다. 여기서 볼 수 있듯이 그냥 <strong>단순히 최소가 돠는 비용을 찾아 누적합을 구하면 안된다</strong>는 것을 알 수 있다.</p>

<blockquote>
  <p>결과적으로 집마다 최소비용을 구해 누적합을 구하는 것이 아니라, <strong>모든 집을 칠하는 경우의 수를 찾아서 최종적으로 최소가 되는 누적합</strong>을 찾아야 한다.</p>
</blockquote>

<h4 id="dp-점화식">DP 점화식</h4>

<p>이때, 동적계획법을 어떻게 이용할 수 있을까? R, G, B에 따른 3가지 케이스 별로 비용을 담은 배열과 누적합을 담은 DP 테이블을 이용하면 된다.</p>

<p>DP 테이블을 갱신하기 위한 점화식은 다음과 같다.</p>

<ol>
  <li><strong>Red</strong>일 경우: <strong><code class="language-plaintext highlighter-rouge">Cost[N][0] = min( Cost[N-1][1], Cost[N-1][2] ) + Cost[N][0]</code></strong></li>
  <li><strong>Green</strong>일 경우: <strong><code class="language-plaintext highlighter-rouge">Cost[N][1] = min( Cost[N-1][0], Cost[N-1][2] ) + Cost[N][1]</code></strong></li>
  <li><strong>Blue</strong>일 경우: <strong><code class="language-plaintext highlighter-rouge">Cost[N][2] = min( Cost[N-1][0], Cost[N-1][1] ) + Cost[N][2]</code></strong></li>
</ol>

<p>위와 같은 점화식을 세우고 이를 재귀함수로 구성하여 메모이제이션을 적용해 <strong>해당 배열을 아직 탐색하지 않았다면 재귀</strong>를 해주고, 그 외의 경우는 DP배열의 값을 반환해주면 된다.</p>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// DP 테이블 선언</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="no">D</span><span class="o">;</span>
    
    <span class="c1">// 색상별 비용을 담을 배열</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">arr</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
                
                <span class="c1">// 1번 규칙: 1번 집과 2번 집의 색은 달라야 한다.</span>
                <span class="c1">// 2번 규칙: N-1번 집과 N번 집의 색은 달라야 한다.</span>
                <span class="c1">// 3번 규칙: i번 집은 i-1번 집, i+1번 집의 색과 달라야 한다.</span>

                <span class="c1">// 모든 집을 탐색하며 경로마다 경우의 수를 찾아 가장 작은 누적합을 찾아야 한다.</span>
                <span class="c1">// 1번집을 DP 테이블의 0번째로 초기화</span>

                <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

                <span class="c1">// 안쪽 배열은 R,G,B 3가지이기에 3의 크기로 초기화</span>
                <span class="no">D</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="mi">3</span><span class="o">];</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="mi">3</span><span class="o">];</span>

                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">(),</span> <span class="s">" "</span><span class="o">);</span>
                    <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                <span class="o">}</span>

                <span class="c1">// DP 테이블의 1번 집의 R,G,B 비용 설정</span>
                <span class="no">D</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
                <span class="no">D</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
                <span class="no">D</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>

                <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">recursion</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">recursion</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span> <span class="n">recursion</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)));</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>

        <span class="o">}</span>

    <span class="o">}</span>

    <span class="cm">/**
     * DP 테이블을 갱신할 재귀함수
     *
     * 점화식은 아래와 같다.
     * Red: arr[N][0] = min(arr[N-1][1], arr[N-1][2]) + arr[N][0]
     * Green: arr[N][1] = min(arr[N-1][0], arr[N-1][2]) + arr[N][1]
     * Blue: arr[N][2] = min(arr[N-1][0], arr[N-1][1]) + arr[N][2]
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">recursion</span><span class="o">(</span><span class="kt">int</span> <span class="no">N</span><span class="o">,</span> <span class="kt">int</span> <span class="n">color</span><span class="o">)</span> <span class="o">{</span>
        <span class="cm">/**
         * 탐색하지 않은 집의 위치라면 R,G,B 중 최소 비용을 갱신한다.
         * Red일 경우 == 0
         * Green일 경우 == 1
         * Blue일 경우 == 2
         */</span>
        <span class="k">if</span><span class="o">(</span><span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="n">color</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">color</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">recursion</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span> <span class="n">recursion</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">))</span> <span class="o">+</span> <span class="n">arr</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">color</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">recursion</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="n">recursion</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">))</span> <span class="o">+</span> <span class="n">arr</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
            <span class="o">}</span> 
            <span class="k">else</span> <span class="o">{</span>
                <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">recursion</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span> <span class="n">recursion</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span> <span class="o">+</span> <span class="n">arr</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="mi">2</span><span class="o">];</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="c1">// 메모이제이션을 통해 탐색한 집이라면 위 제어문을 타지 않고 바로 반환한다.</span>
        <span class="k">return</span> <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="n">color</span><span class="o">];</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/1149">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[1149번 - RGB거리]]></summary></entry><entry><title type="html">[Java] 프로그래머스(level-2) - 두 큐 합 같게 만들기</title><link href="http://localhost:4000/java/266-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-2) - 두 큐 합 같게 만들기" /><published>2023-08-31T00:00:00+09:00</published><updated>2023-08-31T00:00:00+09:00</updated><id>http://localhost:4000/java/266-post</id><content type="html" xml:base="http://localhost:4000/java/266-post/"><![CDATA[<p><br /></p>

<center><img src="/assets/images/programmers/" width="100%" /></center>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />

<p>이 문제는 완전탐색을 활용해 풀기보다는 <strong>그리디 알고리즘</strong>을 활용해 풀어야 한다.</p>

<p><br /></p>

<h4 id="아아디어-도출">아아디어 도출</h4>

<p>정직하게 문제에서 주어진대로 접근한다면 1번큐와 2번큐 중 추출시 선택의 기로가 생기게 되고, 결국 <strong>큐의 길이(최대 300,000)만큼 완전 탐색하며 경우의 수를 따지게 된다면 시간초과가 발생</strong>할 수 있다.</p>

<p>모든 큐의 합을 맟추려하지 말고, 아래처럼 접근하며 어떨까?</p>

<blockquote>
  <p>두 큐의 합이 같다 == 한 큐의 합은 <code class="language-plaintext highlighter-rouge">두 큐의 합/2</code>이 된다.</p>
</blockquote>

<p>이 말은 즉, 1번 큐의 모든 원소의 합을 두 큐의 합/2의 값으로 만들면 된다는 것이다. 그렇다면 교체는 어떻게 하면 될까?</p>

<ul>
  <li>1번 큐의 합이 <code class="language-plaintext highlighter-rouge">두 큐의 합/2</code> 보다 <strong>작다면, 2번 큐에서 추출</strong>하여 가져온다.</li>
  <li>1번 큐의 합이 <code class="language-plaintext highlighter-rouge">두 큐의 합/2</code> 보다 <strong>크다면, 1번 큐에서 추출하여 2번 큐로 넣어준다.</strong></li>
</ul>

<p>이때, 필자는 1번 큐를 기준으로 2번 큐를 교체할 큐로 정해 구현했다.
이제 위 내용을 통해 아이디어를 정리해보자.</p>

<ol>
  <li>두 큐의 원소를 각각 큐에 저장하고, 1번 큐의 원소 합과 두 큐의 합/2의 값을 계산한다.(<strong>합 계산 중 문제 방지를 위해 long 타입을 사용!</strong>)</li>
  <li>1번 큐의 합(sum)이 두 큐의 합(total)과 같을 때까지 아래 3-4번 과정을 반복한다.</li>
  <li><code class="language-plaintext highlighter-rouge">sum &gt; total</code>이라면 1번 큐에서 원소를 추출해 2번 큐로 삽입한다. 추출한 원소값만큼을 sum에서 뺀다.</li>
  <li><code class="language-plaintext highlighter-rouge">sum &lt; total</code>이라면 2번 큐에서 원소를 추출하여 1번 큐로 삽입한다. 추출한 원소값만큼을 sum에 증가시킨다.</li>
  <li>이때, 교체횟수는 최대로 <strong><code class="language-plaintext highlighter-rouge">큐의 길이 * 3</code></strong> 만큼을 넘어갈 수 없기 때문에 반복 횟수가 이를 넘어가면 두 큐의 합을 맞출 수 없다고 판단하여 -1을 반환한다.</li>
</ol>

<p><br /></p>

<p>다음으로 문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
</pre></td><td class="rouge-code"><pre>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="c1">// 두 큐 원소의 합이 같다는 것은 하나의 큐의 합을 두 큐의 합/2 이 되면 된다는 것이다.</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">queue1</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">queue2</span><span class="o">)</span> <span class="o">{</span>

        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">q1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">q2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// 문제에서 요구한대로 합 계산 과정 중 문제 방지를 위해 long 타입을 사용한다.</span>
        <span class="kt">long</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">queue1</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">q1</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">queue1</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">q2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">queue2</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">queue1</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">queue2</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">queue1</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
        <span class="o">}</span>

        <span class="c1">// 한쪽 큐의 합은 [두 큐의 합/2] 조건을 충족하면 된다.</span>
        <span class="n">total</span> <span class="o">/=</span> <span class="mi">2</span><span class="o">;</span>

        <span class="kt">int</span> <span class="n">cycle</span> <span class="o">=</span> <span class="n">queue1</span><span class="o">.</span><span class="na">length</span><span class="o">*</span><span class="mi">3</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="cm">/**
         * 두 큐의 합을 동일하게 만드는 로직
         * q1을 기준으로 q2는 교체할 큐로 사용한다.
         * 단, 일정 교체횟수 이상을 반복하게 되면 종료한다.
         */</span>
        <span class="k">while</span><span class="o">(</span><span class="n">sum</span> <span class="o">!=</span> <span class="n">total</span><span class="o">)</span> <span class="o">{</span>

            <span class="cm">/**
             * q1과 a2의 값을 교체하는 횟수는 최대 [한 큐의 길이 * 3] 만큼 을 넘지 않는다.
             * 교체 횟수 이상 반복되면 두 큐의 합을 맞추지 못하기에 -1을 반환한다.
             */</span>
            <span class="k">if</span><span class="o">(</span><span class="n">cycle</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
            
            <span class="cm">/**
             * q1의 합이 total보다 크다면, 첫번째 원소를 추출하고 q2의 원소를 가져온다.
             * 이때, q1의 합을 다시 계산하기 위해 추출한 수만큼을 뺀다.
             * 그 반대라면 q2의 첫번째 원소를 추출하고 q1의 원소를 가져간다.
             */</span>
            <span class="k">if</span><span class="o">(</span><span class="n">sum</span> <span class="o">&gt;</span> <span class="n">total</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">temp1</span> <span class="o">=</span> <span class="n">q1</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="n">sum</span> <span class="o">-=</span> <span class="n">temp1</span><span class="o">;</span>
                <span class="n">q2</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">temp1</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">else</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">temp2</span> <span class="o">=</span> <span class="n">q2</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">temp2</span><span class="o">;</span>
                <span class="n">q1</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">temp2</span><span class="o">);</span>
            <span class="o">}</span>
            
            <span class="c1">// 교체 횟수를 차감한다.</span>
            <span class="n">cycle</span><span class="o">--;</span>

        <span class="o">}</span>

        <span class="c1">// 두 큐의 합을 같게 한 이후, 총 교체횟수를 구한다.</span>
        <span class="k">return</span> <span class="n">queue1</span><span class="o">.</span><span class="na">length</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">-</span> <span class="n">cycle</span><span class="o">;</span>
    <span class="o">}</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        
        <span class="c1">// int[] queue1 = new int[]{3,2,7,2};</span>
        <span class="c1">// int[] queue2 = new int[]{4,6,5,1};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">queue1</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">};</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="n">queue2</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span><span class="mi">10</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">};</span>
        
        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">queue1</span><span class="o">,</span> <span class="n">queue2</span><span class="o">);</span>

    <span class="o">}</span>

<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<p>-</p>

<hr />

<p><br /></p>

<h3 id="출처">출처</h3>
<p>-</p>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://school.programmers.co.kr/learn/courses/30/lessons/118667">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 2 - 두 큐 합 같게 만들기]]></summary></entry><entry><title type="html">[Java] 프로그래머스(level-2) - 숫자 변환하기</title><link href="http://localhost:4000/java/265-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-2) - 숫자 변환하기" /><published>2023-08-30T00:00:00+09:00</published><updated>2023-08-30T00:00:00+09:00</updated><id>http://localhost:4000/java/265-post</id><content type="html" xml:base="http://localhost:4000/java/265-post/"><![CDATA[<p><br /></p>

<center><img src="/assets/images/programmers/" width="100%" /></center>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />

<p>이번 문제는 <strong>동적 계획법(DP)</strong>을 통해 풀 수 있다.</p>

<p>처음엔 단순히 재귀를 통해 x<em>n, x</em>2, x*3 경우별로 재귀 호출하여 y가 되는 순간의 최소 깊이를 반환하는 방식으로 풀었으나 <strong>시간초과가 발생</strong>했다.</p>

<h4 id="재귀-코드---오답시간초과-발생">재귀 코드 - 오답(시간초과 발생)</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre><span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">answer</span><span class="o">;</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">answer</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
        <span class="n">recursion</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">answer</span> <span class="o">==</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">answer</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
    
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">recursion</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">answer</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">answer</span><span class="o">,</span> <span class="n">depth</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">recursion</span><span class="o">(</span><span class="n">x</span><span class="o">+</span><span class="n">n</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">recursion</span><span class="o">(</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
        <span class="n">recursion</span><span class="o">(</span><span class="n">x</span><span class="o">*</span><span class="mi">3</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>그렇다면 어떻게 시간초과를 줄일 수 있을까? 완전탐색을 하지 않고 효율적인 방법이 없는지를 고민해보니 <strong>DP 테이블에 x가 y로 변환되는 최소 연산횟수를 갱신해가며 접근하는 방법</strong>으로 풀 수 있다고 판단하여 DP를 이용해 풀 수 있었다.</p>

<p>DP를 이용한 아이디어를 살펴보자.</p>

<ol>
  <li>y만큼의 크기를 가지는 DP 테이블을 선언하고 x부터 y까지 순회하며 DP 테이블의 값을 갱신한다.</li>
  <li>DP 테이블의 값을 갱신하는 경우는 <strong>index+n, index<em>2, index</em>3과 같이 3가지 경우로 나누어 DP 테이블의 원소를 기록</strong>한다.</li>
  <li>현재 위치의 DP 테이블 값이 변환될 수 없는 수라면 -1을 기록하고 순회를 넘어간다.</li>
</ol>

<p><br /></p>

<p>다음으로 문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre></td><td class="rouge-code"><pre>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="c1">// x와 y의 최대 범위 값을 상수로 활용한다.</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MAX_VALUE</span> <span class="o">=</span> <span class="mi">1_000_000</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="c1">// DP 테이블을 MAX_VALUE 값으로 초기화한다.</span>
        <span class="kt">int</span><span class="o">[]</span> <span class="no">D</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>
        <span class="nc">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="no">D</span><span class="o">,</span> <span class="no">MAX_VALUE</span><span class="o">);</span>

        <span class="c1">// DP 테이블의 x번째 원소를 0으로 초기화한다.</span>
        <span class="no">D</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="cm">/**
         * DP 테이블에 연산 횟수를 갱신하는 반복문
         * x부터 y까지 순회하면서 x의 값에서 변환할 수 있는 i+n일 경우, i*2일 경우, i*3일 경우를 비교한다.
         * 변환할 수 없는 값이라면 
         * 변환할 수 있는 값일 경우 i번째 연산 횟수에서 1씩 증가한 값과 최솟값을 비교하여 갱신한다.
         */</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">x</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="n">y</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            
            <span class="c1">// 현재 위치의 x값이 y로 변환할 수 없다면 -1로 기록하고 넘어간다.</span>
            <span class="k">if</span><span class="o">(</span><span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="no">MAX_VALUE</span><span class="o">)</span> <span class="o">{</span>
                <span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// 연산횟수를 기록한다.</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
                <span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="n">n</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="n">n</span><span class="o">],</span> <span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
                <span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">],</span> <span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
                <span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">*</span><span class="mi">3</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">*</span><span class="mi">3</span><span class="o">],</span> <span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">]+</span><span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>

        <span class="o">}</span>
        
        <span class="k">return</span> <span class="no">D</span><span class="o">[</span><span class="n">y</span><span class="o">];</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">40</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        
        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>

    <span class="o">}</span>

<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<p>-</p>

<hr />

<p><br /></p>

<h3 id="출처">출처</h3>
<p>-</p>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://school.programmers.co.kr/learn/courses/30/lessons/154538">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 2 - 숫자 변환하기]]></summary></entry><entry><title type="html">[Java] 백준(실버-1) 20529번 - 가장 가까운 세 사람의 심리적 거리</title><link href="http://localhost:4000/java/264-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-1) 20529번 - 가장 가까운 세 사람의 심리적 거리" /><published>2023-08-29T00:00:00+09:00</published><updated>2023-08-29T00:00:00+09:00</updated><id>http://localhost:4000/java/264-post</id><content type="html" xml:base="http://localhost:4000/java/264-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 <strong>문제의 제약사항을 잘 파악</strong>한 뒤, <strong>완전탐색</strong>을 이용해 쉽게 풀 수 있다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>처음에 단순히 완전탐색을 통해 모든 경우를 탐색하려 했으나 N의 범위가 최대 100,000이기에 시간초과를 어느정도 고려해야 했다.</p>

<p>시간 초과를 어떻게 줄일 수 있을까?</p>

<p>우리는 가까운 <strong>3 사람의 MBTI</strong>를 통해 최소가 되는 심리거리를 구해야 한다. 문제에서 주어지는 <strong>MBTI는 총 16가지이며 이것이 큰 힌트</strong>가 된다.</p>

<p><strong>세 사람의 MBTI가 같다면, 서로간의 심리거리는 0으로 가장 최소</strong>가 될테니 이후로는 더이상 탐색할 필요가 없다.</p>

<p>그런데 MBTI는 한 사람당 16가지 중 1가지가 나오며 두 사람일 경우는 32가지가 된다. <strong>33가지가 넘어가는 순간 세 사람이 같은 MBTI가 될 수 있기 때문</strong>에 33명의 학생(N)을 입력받을 경우 묻지도 않고 따지지도 않고 <strong>0을 출력</strong>하면 나머지 탐색을 줄일 수 있어 시간복잡도 측면에서 이득이 된다.</p>

<p>그렇다면 이제 아이디어를 정리해보자.</p>

<ol>
  <li>N(학생)이 33 이상이 주어질 경우 0을 출력하고 다음 순회로 넘어간다.</li>
  <li>N이 32 이하일 경우 3중 for문(세 사람)으로 완전 탐색을 하며 서로 간의 심리거리를 구하고 이 심리거리들 중 최솟값으로 갱신한다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>

                <span class="kt">int</span> <span class="no">T</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

                <span class="k">while</span><span class="o">(</span><span class="no">T</span> <span class="o">--&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>

                    <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                    <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

                    <span class="cm">/**
                     * 세 사람의 심리적 거리가 0이 될 경우 최소이기에 더 탐색을 진행할 필요가 없다.
                     * MBIT의 종류는 총 16가지이기에 N이 33 이상이라면 중복되는 3개의 MBTI가 주어질 수 있기에 불필요한 탐색을 하게 된다.
                     * N이 33 이상이라면 바로 0을 반환할 수 있도록 한다.
                     */</span>
                    <span class="k">if</span><span class="o">(</span><span class="no">N</span> <span class="o">&gt;</span> <span class="mi">32</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"0"</span> <span class="o">+</span> <span class="s">"\n"</span><span class="o">);</span>
                        <span class="k">continue</span><span class="o">;</span>
                    <span class="o">}</span>

                    <span class="c1">// * N이 32 이하일 경우 아래 로직을 수행한다.</span>

                    <span class="c1">// N개의 MBTI 문자열을 입력받는다.</span>
                    <span class="nc">String</span><span class="o">[]</span> <span class="n">mbtis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                        <span class="n">mbtis</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">();</span>
                    <span class="o">}</span>

                    <span class="c1">// 세 사람의 심리거리의 최소값을 구하기 위한 변수 초기화한다.</span>
                    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

                    <span class="c1">// N개 중 3 사람의 조합을 이용해 최소가 되는 심리거리를 구한다.</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>
                                <span class="n">result</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">getDistance</span><span class="o">(</span><span class="n">mbtis</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">mbtis</span><span class="o">[</span><span class="n">j</span><span class="o">],</span> <span class="n">mbtis</span><span class="o">[</span><span class="n">k</span><span class="o">]));</span>
                            <span class="o">}</span>
                        <span class="o">}</span>
                    <span class="o">}</span>

                    <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
                <span class="o">}</span>

        <span class="o">}</span>

    <span class="o">}</span>

    <span class="c1">// 3개의 MBTI를 통해 심리거리를 구하는 함수</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">getDistance</span><span class="o">(</span><span class="nc">String</span> <span class="n">a</span><span class="o">,</span> <span class="nc">String</span> <span class="n">b</span><span class="o">,</span> <span class="nc">String</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">)</span> <span class="o">{</span>
                <span class="n">result</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">c</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">result</span><span class="o">++;</span>
            <span class="o">}</span>
            <span class="k">if</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">!=</span> <span class="n">c</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">result</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/20529">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[20529번 - 가장 가까운 세 사람의 심리적 거리]]></summary></entry></feed>