<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-07-22T23:50:36+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">lango’s DevLog</title><subtitle>developer</subtitle><author><name>lango</name></author><entry><title type="html">[Java] 백준(실버-2) 11279번 - 최대 힙</title><link href="http://localhost:4000/java/231-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-2) 11279번 - 최대 힙" /><published>2023-07-22T00:00:00+09:00</published><updated>2023-07-22T00:00:00+09:00</updated><id>http://localhost:4000/java/231-post</id><content type="html" xml:base="http://localhost:4000/java/231-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이 문제는 주어진대로 <strong>최대 힙을 우선순위 큐를 이용</strong>해 구현하면 되는 간단한 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>우선순위 큐를 이용했던 이전 문제 <a href="https://langoustinee.github.io/java/230-post/">최소 힙</a>과 동일한 풀이 방법으로 풀 수 있다.</p>

<p>최소 힙은 PriorityQueue의 기본 값으로 설정되어 있어 그냥 선언만 해도 최소 힙을 구현할 수 있었으나 최대 힙의 경우 추가적인 설정이 필요하다. 필자가 최대 힙을 구하기 위해 설정한 방법은 2가지이다.</p>

<ol>
  <li>Collections 패키지의 reverseOrder() 메소드 이용하기</li>
  <li>Comparator 클래스를 상속받아 compare() 메소드 오버라이딩하기</li>
</ol>

<p>2가지 방법 모두 우선순위 큐의 우선순위를 높은 순으로 설정할 수 있는 방법들이니 자유롭게 원하는 것을 선택하여 풀면 된다.</p>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
        
        <span class="c1">// Collections 패키지의 reverseOrder() 메소드로 우선순위를 높은 순으로 설정할 수 있다.</span>
        <span class="c1">// PriorityQueue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;(Collections.reverseOrder());</span>
        
        <span class="c1">// Comparator 클래스를 상속받아 compare() 메소드를 오버라이딩하여 우선순위를 높은 순으로 설정한다.</span>
        <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;(</span><span class="k">new</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;()</span> <span class="o">{</span>

            <span class="nd">@Override</span>
            <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">o1</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">o1</span> <span class="o">&gt;</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">o1</span> <span class="o">&lt;</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">else</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            
        <span class="o">});</span>

        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
            
            <span class="c1">// 만약 입력값이 0보다 큰 자연수라면 우선순위 큐에 삽입.</span>
            <span class="k">if</span><span class="o">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// 0일 때 우선순위 큐가 비어있다면 0을, 비어있지 않다면 가장 높은 수를 꺼낸다.</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">()+</span><span class="s">"\n"</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"0"</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
            <span class="o">}</span>
            
        <span class="o">}</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/11279">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[11279번 - 최대 힙]]></summary></entry><entry><title type="html">[Java] 백준(실버-2) 1927번 - 최소 힙</title><link href="http://localhost:4000/java/230-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-2) 1927번 - 최소 힙" /><published>2023-07-22T00:00:00+09:00</published><updated>2023-07-22T00:00:00+09:00</updated><id>http://localhost:4000/java/230-post</id><content type="html" xml:base="http://localhost:4000/java/230-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이 문제는 주어진대로 <strong>최소 힙을 우선순위 큐를 이용</strong>해 구현하면 되는 간단한 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>이 문제에서 요구하는 최소 힙을 어떻게 우선순위 큐로 구현할 수 있는 걸까?</p>

<p>일반적인 큐(Queue)는 FIFO(First in - First Out) 구조로, 먼저 들어온 데이터가 먼저 나가는 구조이다. 그런데 <strong>우선순위 큐(Priority Queue)는 들어간 순서와는 상관없이 우선순위가 높은 데이터가 먼저 나오는 구조</strong>로 이루여져있다.</p>

<blockquote>
  <p>우선순위 큐인 PriorityQueue를 선언할 때, 인자로 Comparator 클래스를 넣어서 우선순위의 기준을 설정할수 있다. 다만 이번 문제에서는 기본값인 최소 힙을 구현하기에 별도의 Comparator 설정 없이 풀 수 있다.</p>
</blockquote>

<p>따라서 이러한 우선순위 큐를 이용하면 쉽게 최소 힙을 구현할 수 있다.</p>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>

        <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;();</span>

        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
            
            <span class="c1">// 만약 입력값이 0보다 큰 자연수라면 우선순위 큐에 삽입.</span>
            <span class="k">if</span><span class="o">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">num</span><span class="o">);</span>
                <span class="k">continue</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// 0일 때 우선순위 큐가 비어있다면 0을, 비어있지 않다면 가장 작은 수를 꺼낸다.</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">()+</span><span class="s">"\n"</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"0"</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
            <span class="o">}</span>
            
        <span class="o">}</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/1927">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[1927번 - 최소 힙]]></summary></entry><entry><title type="html">[Java] 백준(실버-1) 1074번 - Z</title><link href="http://localhost:4000/java/229-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-1) 1074번 - Z" /><published>2023-07-20T00:00:00+09:00</published><updated>2023-07-20T00:00:00+09:00</updated><id>http://localhost:4000/java/229-post</id><content type="html" xml:base="http://localhost:4000/java/229-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이 문제는 <strong>분할 정복 재귀</strong>를 이용해 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>이 문제는 배열을 사분면으로 나누고, 입력받은 R, C의 위치가 몇 번째 사분면에 속하는지 알아내는 것이 중요하다.</p>

<ol>
  <li>입력받은 N을 통해 2의 거듭제곱 N 값으로 배열 한 변의 길이(size)를 구한다.</li>
  <li>재귀를 호출하면서 현재 R, C의 위치가 몇 사분면에 속하는지 확인한 후 방문순서를 갱신한다.
    <blockquote>
      <p>1사분면의 위치라면 방문 순서를 갱신할 필요가 없고, 2사분면일 경우 <strong>1사분면의 위치 <code class="language-plaintext highlighter-rouge">(size*size)/4</code></strong> 를, 3사분면일 경우 <strong>1,2사분면의 모든 위치 <code class="language-plaintext highlighter-rouge">((size*size)/4) * 2</code></strong>를, 4사분면일 경우 <strong>1,2,3사분면의 위치 <code class="language-plaintext highlighter-rouge">((size*size)/4) * 3</code></strong>를 모두 더해준다.</p>
    </blockquote>
  </li>
  <li>R, C의 위치가 몇 사분면인지 확인하여 방문 순서를 갱신했다면, R, C의 위치를 찾기 위해 해당 사분면의 시작점으로 배열을 절반씩 줄여가면서 재귀 호출해준다.</li>
  <li>위 과정을 반복하면서 길이(size)가 1이 된다면 R, C의 위치를 찾은 것이니 재귀를 종요하고 이전까지 갱신했던 방문순서를 출력하면 된다.</li>
</ol>

<p>말로 설명하면 이해하기 어려울 수  있으니 예시를 몇 가지 들어보자.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>N=3,R=7,C=7일 경우 size=8, newSize=4 이다.
(R&gt;=newSize &amp;&amp; C&gt;=newSize) 조건을 만족하기에 4사분면에 속한다.
7행 7열은 63번째로 방문하게 된다.

N=3,R=3,C=7일 경우 size=8, newSize=4 이다.
(R&lt;newSize &amp;&amp; C&gt;=newSize) 조건을 만족하기에 2사분면에 속한다.
3행 7열은 31번째로 방문하게 된다.
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p>이때, 1사분면 중 0행 0열은 어차피 0번째로 방문하여 방문 순서가 0번째기에 1사분면 조건에서 방문 순서를 갱신할 필요는 없다.</p>
</blockquote>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">static</span> <span class="kt">int</span> <span class="n">result</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>

        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="kt">int</span> <span class="no">R</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="kt">int</span> <span class="no">C</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

        <span class="c1">// 분할정복 재귀 문제</span>
        
        <span class="c1">// N이 1보다 크다면, NXN 배열을 4사분면으로 두어 재귀로 탐색을 한다.</span>
        <span class="c1">// N=2이면 4X4, N=3이면 8X8 배열이 된다.</span>

        <span class="c1">// 1,2,3,4 사분면을 탐색하며 R, C가 어디범위에 속해있는지 확인한다.</span>
        <span class="c1">// R, C의 사분면이 어디인지 파악했다면, 해당 사분면만 재귀 호출을 한다.</span>
        <span class="c1">// size를 절반씩 나눠가면서 해당 사분면에서 R, C 값을 찾아간다.</span>
        <span class="c1">// size가 1이 된다면 R,C를 찾은 것이기에 값을 저장하고 return 하면 된다.</span>

        <span class="c1">// 배열의 크기를 2의 N승 형태의 거듭제곱으로 정한다.</span>
        <span class="c1">// 즉 여기서의 size는 한 변의 길이가 된다.</span>
        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="nc">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="no">N</span><span class="o">);</span>

        <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="c1">// 재귀함수를 통해 result에 방문 순서를 갱신한다.</span>
        <span class="n">recursion</span><span class="o">(</span><span class="no">R</span><span class="o">,</span> <span class="no">C</span><span class="o">,</span> <span class="n">size</span><span class="o">);</span>

        <span class="c1">// 갱신된 방문 순서가 담긴 result를 출력한다.</span>
        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 사분면을 탐색해가며 R,C를 찾을 재귀함수
     */</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">recursion</span><span class="o">(</span><span class="kt">int</span> <span class="no">R</span><span class="o">,</span> <span class="kt">int</span> <span class="no">C</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="c1">// 가장 작은 단위로 사분면을 쪼개어 </span>
        <span class="k">if</span><span class="o">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        
        <span class="c1">// R,C의 위치가 어떤 사분면인지 확인하기 위해 배열을 절반으로 줄인다.</span>
        <span class="kt">int</span> <span class="n">newSize</span> <span class="o">=</span> <span class="n">size</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

        <span class="cm">/**
         * 특정 사분면 파악
         * 1사분면: R &lt; newSize 그리고 C &lt; newSize
         * 2사분면: R &lt; newSize 그리고 C &gt;= newSize 
         * 3사분면: R &gt;= newSize 그리고 C &lt; newSize
         * 4사분면: R &gt;= newSIze 그리고 C &gt;= newSize
         * 
         * 방문 순서
         * R과 C의 위치가 1사분면이면 방문 순서를 기록하지 않았기에 그대로 둔다.
         * R과 C의 위치가 2사분면이라면, 1 사분면을 모두 방문해야 하므로 result에 (size * size / 4) 값을 더해준다.
         * R과 C의 위치가 3사분면이라면, 1,2 사분면을 모두 방문해야 하므로 result에  (size * size / 4 * 2) 값을 더해준다.
         * R과 C의 위치가 4사분면이라면, 1,2,3 사분면을 모두 방문해야 하므로 result에 (size * size / 4 * 3) 값을 더해준다.
         */</span>

        <span class="k">if</span><span class="o">(</span><span class="no">R</span> <span class="o">&lt;</span> <span class="n">newSize</span> <span class="o">&amp;&amp;</span> <span class="no">C</span> <span class="o">&lt;</span> <span class="n">newSize</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 1사분면 위치일 경우</span>
            <span class="n">recursion</span><span class="o">(</span><span class="no">R</span><span class="o">,</span> <span class="no">C</span><span class="o">,</span> <span class="n">newSize</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="no">R</span> <span class="o">&lt;</span> <span class="n">newSize</span> <span class="o">&amp;&amp;</span> <span class="no">C</span> <span class="o">&gt;=</span> <span class="n">newSize</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 2사분면 위치일 경우</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="o">(</span><span class="n">size</span> <span class="o">*</span> <span class="n">size</span><span class="o">)</span> <span class="o">/</span> <span class="mi">4</span><span class="o">;</span>
            <span class="n">recursion</span><span class="o">(</span><span class="no">R</span><span class="o">,</span> <span class="no">C</span><span class="o">-</span><span class="n">newSize</span><span class="o">,</span> <span class="n">newSize</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="no">R</span> <span class="o">&gt;=</span> <span class="n">newSize</span> <span class="o">&amp;&amp;</span> <span class="no">C</span> <span class="o">&lt;</span> <span class="n">newSize</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 3사분면 위치일 경우</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="o">((</span><span class="n">size</span> <span class="o">*</span> <span class="n">size</span><span class="o">)</span> <span class="o">/</span> <span class="mi">4</span><span class="o">)</span> <span class="o">*</span> <span class="mi">2</span><span class="o">;</span>
            <span class="n">recursion</span><span class="o">(</span><span class="no">R</span><span class="o">-</span><span class="n">newSize</span><span class="o">,</span> <span class="no">C</span><span class="o">,</span> <span class="n">newSize</span><span class="o">);</span>

        <span class="o">}</span>
        <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="no">R</span> <span class="o">&gt;=</span> <span class="n">newSize</span> <span class="o">&amp;&amp;</span> <span class="no">C</span> <span class="o">&gt;=</span> <span class="n">newSize</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 4사분면 위치일 경우</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="o">((</span><span class="n">size</span> <span class="o">*</span> <span class="n">size</span><span class="o">)</span> <span class="o">/</span> <span class="mi">4</span><span class="o">)</span> <span class="o">*</span> <span class="mi">3</span><span class="o">;</span>
            <span class="n">recursion</span><span class="o">(</span><span class="no">R</span><span class="o">-</span><span class="n">newSize</span><span class="o">,</span> <span class="no">C</span><span class="o">-</span><span class="n">newSize</span><span class="o">,</span> <span class="n">newSize</span><span class="o">);</span>
        <span class="o">}</span>

    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/1074">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[1074번 - Z]]></summary></entry><entry><title type="html">[Java] 백준(실버-1) 14940번 - 쉬운 최단거리</title><link href="http://localhost:4000/java/228-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-1) 14940번 - 쉬운 최단거리" /><published>2023-07-19T00:00:00+09:00</published><updated>2023-07-19T00:00:00+09:00</updated><id>http://localhost:4000/java/228-post</id><content type="html" xml:base="http://localhost:4000/java/228-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이 문제는 <strong>너비 우선 탐색인 BFS</strong>를 이용해 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>BFS 문제를 여러 번 풀어봤다면 어떤 식으로 문제 해결을 할 수 있을지 금방 알 수 있을 것이다! 풀이를 위한 아이디어는 다음과 같다.</p>

<ol>
  <li>도달할 수 없는 땅의 위치(-1)일 경우 -1로 갱신하기 위해 미리 새로운 배열의 모든 원소를 -1로 초기화한다.</li>
  <li>기존 지도를 입력받으며 갈 수 없는 땅의 위치(0)와 목표 지점 2의 위치(2)일 경우 0으로 먼저 갱신한다.</li>
  <li>그리고 목표 지점 2의 위치를 구하고 2의 위치부터 BFS 함수를 통해 너비 우선 탐색을 진행한다.</li>
  <li>지도의 위치별로 2로부터의 거리를 갱신하기 위해 새로운 배열에 이동거리를 갱신한다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    
    
    <span class="c1">// 상,하,좌,우로 탐색하기 위한 dx,dy 배열</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dx</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>

    <span class="c1">// 위치를 입력받을 기존 지도와 이동거리를 기록할 새로운 지도 배열 선언</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">arr</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">result</span><span class="o">;</span>

    <span class="c1">// 방문 배열 선언</span>
    <span class="kd">static</span> <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">visited</span><span class="o">;</span>

    <span class="c1">// 지도의 크기 변수</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="no">N</span><span class="o">,</span> <span class="no">M</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>

        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        
        <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
        <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

        <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">M</span><span class="o">];</span>
        <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">M</span><span class="o">];</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">M</span><span class="o">];</span>

        <span class="c1">// 도달할 수 없는 땅의 위치를 구하기 위해 새로운 지도의 모든 원소를 미리 -1로 설정해둔다.</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="no">M</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 목표 지점 2의 위치를 구하기 위한 좌표 변수</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="no">M</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                
                <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                
                <span class="c1">// 목표 지점 2의 위치를 구하고 새로운 지도에 해당 위치를 갱신한다.</span>
                <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>
                <span class="o">}</span>
                
                <span class="c1">// 새로운 지도에 갈 수 없는 땅의 위치(0)을 갱신한다.</span>
                <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="o">}</span>

            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// BFS 함수를 통해 기존 지도를 탐색하며 새로운 지도에 목표 지점을 기준으로 이동거리를 갱신한다.</span>
        <span class="no">BFS</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span> <span class="o">:</span> <span class="n">result</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">:</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">num</span><span class="o">+</span><span class="s">" "</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"\n"</span><span class="o">);</span>
        <span class="o">}</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">BFS</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">});</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">now</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">dir</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">dir</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">;</span> <span class="n">dir</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">now</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">dx</span><span class="o">[</span><span class="n">dir</span><span class="o">];</span>
                <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">now</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">dy</span><span class="o">[</span><span class="n">dir</span><span class="o">];</span>
                <span class="k">if</span><span class="o">(</span><span class="n">isRange</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">});</span>
                        <span class="c1">// 새로운 지도에 목표지점으로부터 현재 위치까지의 이동거리를 갱신한다.ㅁ</span>
                        <span class="n">result</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">result</span><span class="o">[</span><span class="n">now</span><span class="o">[</span><span class="mi">0</span><span class="o">]][</span><span class="n">now</span><span class="o">[</span><span class="mi">1</span><span class="o">]]+</span><span class="mi">1</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isRange</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">&lt;</span><span class="no">N</span> <span class="o">&amp;&amp;</span> <span class="n">y</span><span class="o">&lt;</span><span class="no">M</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/14940">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[14940번 - 쉬운 최단거리]]></summary></entry><entry><title type="html">[Java] 백준(실버-5) 11726번 - 2×n 타일링</title><link href="http://localhost:4000/java/226-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-5) 11726번 - 2×n 타일링" /><published>2023-07-17T00:00:00+09:00</published><updated>2023-07-17T00:00:00+09:00</updated><id>http://localhost:4000/java/226-post</id><content type="html" xml:base="http://localhost:4000/java/226-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이 문제는 <strong>동적 계획법(DP)</strong>를 이용해 푼다면 쉽게 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>주어지는 N을 통해 순서대로 패턴을 그려보면 어떤 유형으로 1X2, 2X1의 직사각형을 채울 수 있는지 알 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre><span class="no">N</span> <span class="o">=</span> <span class="mi">1</span>
<span class="mi">2</span><span class="no">X1</span> <span class="n">직사각형</span> <span class="mi">1</span><span class="n">개</span> <span class="n">필요</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="n">가지</span>
<span class="n">총</span> <span class="mi">1</span><span class="n">가지의</span> <span class="n">방법</span>

<span class="no">N</span> <span class="o">=</span> <span class="mi">2</span>
<span class="mi">1</span><span class="no">X2</span> <span class="n">직시각형</span> <span class="mi">2</span><span class="n">개</span> <span class="n">필요</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="n">가지</span>
<span class="mi">2</span><span class="no">X1</span> <span class="n">직사각형</span> <span class="mi">2</span><span class="n">개</span> <span class="n">필요</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="n">가지</span>
<span class="n">총</span> <span class="mi">2</span><span class="n">가지의</span> <span class="n">방법</span>

<span class="no">N</span> <span class="o">=</span> <span class="mi">3</span>
<span class="mi">1</span><span class="no">X2</span> <span class="n">직사각형</span> <span class="mi">3</span><span class="n">개</span> <span class="n">필요</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="n">가지</span>
<span class="mi">1</span><span class="no">X2</span> <span class="n">직사각형</span> <span class="mi">1</span><span class="n">개</span><span class="o">,</span> <span class="mi">2</span><span class="no">X1</span> <span class="n">직사각형</span> <span class="mi">1</span><span class="n">개</span> <span class="n">필요</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="n">가지</span>
<span class="n">총</span> <span class="mi">3</span><span class="n">가지의</span> <span class="n">방법</span>

<span class="no">N</span> <span class="o">=</span> <span class="mi">4</span>
<span class="mi">1</span><span class="no">X2</span> <span class="n">직사각형</span> <span class="mi">4</span><span class="n">개</span> <span class="n">필요</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="n">가지</span>
<span class="mi">2</span><span class="no">X1</span> <span class="n">직사각형</span> <span class="mi">4</span><span class="n">개</span> <span class="n">필요</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="n">가지</span>
<span class="mi">1</span><span class="no">X2</span> <span class="n">직사각형</span> <span class="mi">2</span><span class="n">개</span><span class="o">,</span> <span class="mi">2</span><span class="no">X1</span> <span class="n">직사각형</span> <span class="mi">2</span><span class="n">개</span> <span class="n">필요</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="n">가지</span>
<span class="n">총</span> <span class="mi">5</span><span class="n">가지의</span> <span class="n">방법</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>자 N을 4까지만 대입해보면 두가지의 직사각형으로 만들어낼 수 있는 가짓수의 패턴이 <strong>피보나치 수열과 동일</strong>함을 알 수 있다. <code class="language-plaintext highlighter-rouge">N=5</code>일 때는 당연하게도 8가지의 방법이 필요할 것이다.</p>

<p>그렇다면 피보나치 수열에서 N번째 수를 구하는 것과 동일한 로직으로 문제를 풀면 간단하다. 이를 위한 아이디어는 다음과 같다.</p>

<ul>
  <li>DP를 이용해 피보나치 수열의 N번째 수를 피보나치 함수로 구현한다.</li>
  <li>DP 테이블을 별도로 두고 이미 구한 가짓수라면 바로 반환(메모이제이션)할 수 있도록 구성한다.</li>
</ul>

<blockquote>
  <p>이때, 유의해야 할 점은 문제의 요구사항대로 <code class="language-plaintext highlighter-rouge">방법의 수를 10,007로 나눈 나머지</code>를 출력해야 하므로 <strong>DP 테이블에 가짓수를 갱신할 때 10,007을 나눈 나머지를 저장</strong>해야 한다.</p>
</blockquote>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="no">D</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>

        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="no">D</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 2*1 일때는 1가지의 방법이 있으며, 2*2일 때는 2가지의 방법이 있다.</span>
        <span class="no">D</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        <span class="no">D</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
        
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">fibo</span><span class="o">(</span><span class="no">N</span><span class="o">);</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>
    
    <span class="kd">static</span> <span class="kt">int</span> <span class="nf">fibo</span><span class="o">(</span><span class="kt">int</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="n">fibo</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">fibo</span><span class="o">(</span><span class="no">N</span><span class="o">-</span><span class="mi">2</span><span class="o">))</span> <span class="o">%</span> <span class="mi">10007</span> <span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/11726">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[11726번 - 2×n 타일링]]></summary></entry><entry><title type="html">[Java] 백준(실버-2) 2630번 - 색종이 만들기</title><link href="http://localhost:4000/java/227-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-2) 2630번 - 색종이 만들기" /><published>2023-07-17T00:00:00+09:00</published><updated>2023-07-17T00:00:00+09:00</updated><id>http://localhost:4000/java/227-post</id><content type="html" xml:base="http://localhost:4000/java/227-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이 문제는 <strong>재귀</strong>를 이용한 <strong>분할 정복</strong> 과정을 통해 풀 수 있는 문제 중 하나이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>문제에서 요구하는 내용은 하얀색과 파란색 정사각형 색종이의 개수이다. 그런데, 부분 색종이는 모두 같은 색으로 이루어져야 한다.
만약, 같은 색상으로 이루어진 색종이가 아닐 경우 색종이를 잘라야 한다. 이떄, 색종이를 자를 때는 절반인 <code class="language-plaintext highlighter-rouge">1/2</code> 씩 잘라서 새로운 색종이로 만들어야 한다.</p>

<p>이를 통해 생각해낸 아이디어는 다음과 같다.</p>

<ol>
  <li>재귀를 통해 현재 색종이가 같은 색상으로 이루어졌는지, 다른 색상이 하나라도 있는지 확인하고, 다른 색상이 있다면 색종이를 분할한다.</li>
  <li>색종이를 분할할 때, <strong>4등분(크기 절반)으로 분할하여 1번 과정을 반복</strong>한다.(재귀 호출)</li>
  <li>분할해낸 색종이가 모두 같은 색상으로 이루어졌다면, 해당 색상의 개수를 1 증가시키고 재귀 함수는 종료한다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">arr</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">w</span><span class="o">,</span> <span class="n">b</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>

        <span class="c1">// 첫째줄에는 하얀색 색종이(0)의 개수, 둘째줄에는 파란 색종이(1)의 개수를 출력</span>

        <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">N</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="c1">// 하얀색, 파란색 색종이의 개수를 세기 위해 0으로 초기화</span>
        <span class="n">w</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="n">recursion</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="no">N</span><span class="o">);</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">w</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">b</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">recursion</span><span class="o">(</span><span class="kt">int</span> <span class="n">r</span><span class="o">,</span> <span class="kt">int</span> <span class="n">c</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// 1. 현재 파티션의 색종이가 모두 같은 색으로 이루어졌다면 개수를 1 증가시키고 함수를 종료한다.</span>
        <span class="k">if</span><span class="o">(</span><span class="n">isEquals</span><span class="o">(</span><span class="n">r</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">size</span><span class="o">))</span> <span class="o">{</span>
            
            <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">w</span><span class="o">++;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">b</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 2. 만약 현재 파티션이 다른 색으로 이루어졌다면, 4등분한 후 다시 확인한다.</span>
        <span class="kt">int</span> <span class="n">newSize</span> <span class="o">=</span> <span class="n">size</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">;</span>
        <span class="n">recursion</span><span class="o">(</span><span class="n">r</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">newSize</span><span class="o">);</span>
        <span class="n">recursion</span><span class="o">(</span><span class="n">r</span><span class="o">+</span><span class="n">newSize</span><span class="o">,</span> <span class="n">c</span><span class="o">,</span> <span class="n">newSize</span><span class="o">);</span>
        <span class="n">recursion</span><span class="o">(</span><span class="n">r</span><span class="o">,</span> <span class="n">c</span><span class="o">+</span><span class="n">newSize</span><span class="o">,</span> <span class="n">newSize</span><span class="o">);</span>
        <span class="n">recursion</span><span class="o">(</span><span class="n">r</span><span class="o">+</span><span class="n">newSize</span><span class="o">,</span> <span class="n">c</span><span class="o">+</span><span class="n">newSize</span><span class="o">,</span> <span class="n">newSize</span><span class="o">);</span>

    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isEquals</span><span class="o">(</span><span class="kt">int</span> <span class="n">r</span><span class="o">,</span> <span class="kt">int</span> <span class="n">c</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="c1">// 색종이의 첫번째 원소</span>
        <span class="kt">int</span> <span class="n">color</span> <span class="o">=</span> <span class="n">arr</span><span class="o">[</span><span class="n">r</span><span class="o">][</span><span class="n">c</span><span class="o">];</span>

        <span class="c1">// 해당 파티션을 순회하면서 같은 색 여부를 확인하여 결과 반환</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">r</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">r</span><span class="o">+</span><span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">c</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">c</span><span class="o">+</span><span class="n">size</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="n">color</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        
        <span class="c1">// 같은 색이라면 true 반환</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/2630">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[2630번 - 색종이 만들기]]></summary></entry><entry><title type="html">[Java] 백준(실버-5) 11723번 - 집합</title><link href="http://localhost:4000/java/225-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-5) 11723번 - 집합" /><published>2023-07-15T00:00:00+09:00</published><updated>2023-07-15T00:00:00+09:00</updated><id>http://localhost:4000/java/225-post</id><content type="html" xml:base="http://localhost:4000/java/225-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 문제의 요구사항대로 <strong>구현</strong>만 잘 하면 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>연산마다 문자열이 주어지는데, 공백을 기준으로 첫번째 문자열은 명령, 두번째 문자열은 명령을 수행할 수가 된다.
명령이 add, remove, check, toggle, all, empty 일 때마다 다른 연산을 수행해야 하는데, 그 중 check 명령일 때만 출력을 수행한다.</p>

<p>명령마다 수행해야 할 내용은 다음과 같다. 참고로 필자는 문제에서 말하는 <strong>공집합 S를 ArrayList로 정의</strong>하고 풀었다.</p>

<blockquote>
  <ol>
    <li>add: 리스트 S에 x가 존재하지 않는다면, x를 삽입한다.</li>
    <li>remove: 리스트 S에 x가 존재한다면, x를 제거한다.</li>
    <li>check: 리스트 S에 x가 존재한다면 “1”을, 아니라면 “0”을 출력한다.</li>
    <li>toggle: 리스트 S에 x가 존재한다면, x를 제거하고, 아니라면 x를 삽입한다.</li>
    <li>all: 리스트 S를 비운 뒤, S의 원소를 1~20까지의 수로 다시 채운다.</li>
    <li>empty: 리스트 S를 비운다.</li>
  </ol>
</blockquote>

<p>ArrayList를 공집합으로 두고 연산을 수행하면 되니 간단하다.</p>

<blockquote>
  <p>다만, 유의할 점은 모든 명령이 “명령 x”로 들어오는게 아니다. <code class="language-plaintext highlighter-rouge">all</code>이나 <code class="language-plaintext highlighter-rouge">empty</code>의 경우 x가 없는 공백없는 문자열로 들어오게 되니 x가 항상 입력으로 주어지는 것으로 판단하면 안된다.</p>
</blockquote>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    



    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>
        
        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>

        <span class="kt">int</span> <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="no">S</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">M</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            
            <span class="nc">String</span><span class="o">[]</span> <span class="n">input</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">().</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>

            <span class="nc">String</span> <span class="n">cmd</span> <span class="o">=</span> <span class="n">input</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            
            <span class="k">if</span><span class="o">(</span><span class="n">input</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">x</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">input</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
            <span class="o">}</span>
            
            <span class="k">switch</span><span class="o">(</span><span class="n">cmd</span><span class="o">)</span> <span class="o">{</span>

                <span class="k">case</span> <span class="s">"add"</span><span class="o">:</span>
                    <span class="k">if</span><span class="o">(!</span><span class="no">S</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="no">S</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
                    <span class="k">break</span><span class="o">;</span>

                <span class="k">case</span> <span class="s">"remove"</span><span class="o">:</span>
                    <span class="k">if</span><span class="o">(</span><span class="no">S</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="no">S</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="no">S</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="n">x</span><span class="o">));</span>
                    <span class="k">break</span><span class="o">;</span>

                <span class="k">case</span> <span class="s">"check"</span><span class="o">:</span>
                    <span class="k">if</span><span class="o">(</span><span class="no">S</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"1"</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
                    <span class="k">else</span> <span class="nf">if</span><span class="o">(!</span><span class="no">S</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"0"</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
                    <span class="k">break</span><span class="o">;</span>

                <span class="k">case</span> <span class="s">"toggle"</span><span class="o">:</span>
                    <span class="k">if</span><span class="o">(</span><span class="no">S</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="no">S</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="no">S</span><span class="o">.</span><span class="na">indexOf</span><span class="o">(</span><span class="n">x</span><span class="o">));</span>
                    <span class="k">else</span> <span class="nf">if</span><span class="o">(!</span><span class="no">S</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="no">S</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
                    <span class="k">break</span><span class="o">;</span>

                <span class="k">case</span> <span class="s">"all"</span><span class="o">:</span>
                    <span class="no">S</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="mi">20</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                        <span class="no">S</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
                    <span class="o">}</span>
                    <span class="k">break</span><span class="o">;</span>

                <span class="k">case</span> <span class="s">"empty"</span><span class="o">:</span>
                    <span class="no">S</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
                    <span class="k">break</span><span class="o">;</span>

                <span class="k">default</span><span class="o">:</span>
                    <span class="k">break</span><span class="o">;</span>

            <span class="o">}</span>

        <span class="o">}</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>    

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/11723">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[11723번 - 집합]]></summary></entry><entry><title type="html">[Java] 프로그래머스(level-2) - 스킬트리</title><link href="http://localhost:4000/java/222-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-2) - 스킬트리" /><published>2023-07-14T00:00:00+09:00</published><updated>2023-07-14T00:00:00+09:00</updated><id>http://localhost:4000/java/222-post</id><content type="html" xml:base="http://localhost:4000/java/222-post/"><![CDATA[<p><br /></p>

<center><img src="/assets/images/programmers/" width="100%" /></center>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />

<p>이번 문제는 문제의 요구사항대로 <strong>구현</strong>하면 풀 수 있는 간단한 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>사용자들이 만든 스킬트리들이 정해진 스킬트리를 잘 따랐는지를 확인하기 위한 방법은 많으나 필자가 떠올린 방법은 간단하다.</p>

<ol>
  <li>만든 스킬트리들을 순회하며 선행스킬에 포함된 스킬인지를 확인한다.</li>
  <li>선행스킬에 포함된 스킬이라면 1번째 스킬인지, 2번째 ~ N번째 스킬인지 확인한다.</li>
  <li>현재 스킬이 1번째 스킬이라면 바로 습득한다.</li>
  <li>현재 스킬이 2번째 ~ N번째 스킬이라면 이전 스킬 습득여부를 확인한다. <br />
 4.1. 이전 스킬을 습득하지 않았다면 선행스킬순서를 지키지 않았기에 순회를 종료하고 가능여부를 불가능으로 갱신한다. <br />
 4.2. 이전 스킬을 습득했다면 현재 스킬을 습득한다.</li>
</ol>

<blockquote>
  <p>위 아이디어를 구현하기 위해 <strong>HashMap</strong>과 <strong>Array</strong>를 적절하게 사용했다.</p>
</blockquote>

<p><br /></p>

<p>다음으로 문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
</pre></td><td class="rouge-code"><pre>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="nc">String</span> <span class="n">skill</span><span class="o">,</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">skill_trees</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="c1">// 가능한 스킬트리의 개수를 담을 변수</span>
        <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// 만든 스킬트리들 중에서 정해진 스킬트리를 잘 따랐는지 확인하기 위해 Map에 담는다.</span>
        <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">hm</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">skill</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">hm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">skill</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span><span class="o">)),</span> <span class="n">i</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">skill_trees</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            
            <span class="c1">// 스킬트리 가능 여부</span>
            <span class="kt">boolean</span> <span class="n">possiable</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            
            <span class="c1">// 선행 스킬 습득 여부를 담을 배열</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">check</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">skill</span><span class="o">.</span><span class="na">length</span><span class="o">()];</span>

            <span class="cm">/**
             * 만든 스킬트리를 순회하며 가능한 스킬트리인지를 검증한다.
             * 정해진 스킬트리의 스킬이 아니라면 검사하기 않는다.
             * 스킬트리의 포함된 스킬이라면 첫번째 스킬인지, 두번째~N번째 스킬인지 확인한 후,
             * 선행 스킬 습득 여부를 판단하여 스킬 가능 여부를 갱신한다.
             */</span> 
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">skill_trees</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">length</span><span class="o">();</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                
                <span class="nc">String</span> <span class="n">now</span> <span class="o">=</span> <span class="nc">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">skill_trees</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">));</span>
                
                <span class="c1">// 스킬트리에 존재하지 않는 스킬이라면 스킵.</span>
                <span class="k">if</span><span class="o">(!</span><span class="n">hm</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">now</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="c1">// 스킬트리의 첫번째 스킬일 경우</span>
                <span class="k">if</span><span class="o">(</span><span class="n">hm</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">now</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">check</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span> 
                <span class="c1">// 스킬트리의 두번째부터 N번째 스킬일 경우</span>
                <span class="k">else</span> <span class="o">{</span>
                    <span class="c1">// 이전 스킬을 습득하지 않은 경우 불가능한 스킬트리이다.</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">check</span><span class="o">[</span><span class="n">hm</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">now</span><span class="o">)-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">possiable</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                        <span class="k">break</span><span class="o">;</span>
                    <span class="o">}</span>
                    <span class="c1">// 이전 스킬을 습득했을 경우 현재 스킬도 습득 가능하다.</span>
                    <span class="k">else</span> <span class="o">{</span>
                        <span class="n">check</span><span class="o">[</span><span class="n">hm</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">now</span><span class="o">)]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
            
            <span class="c1">// 만든 스킬트리는 가능한 스킬트리이다.</span>
            <span class="k">if</span><span class="o">(</span><span class="n">possiable</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">answer</span><span class="o">++;</span>
            <span class="o">}</span>

        <span class="o">}</span>
        
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>

    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        
        <span class="nc">String</span> <span class="n">skill</span> <span class="o">=</span> <span class="s">"CBD"</span><span class="o">;</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">skill_trees</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[]{</span><span class="s">"BACDE"</span><span class="o">,</span> <span class="s">"CBADF"</span><span class="o">,</span> <span class="s">"AECB"</span><span class="o">,</span> <span class="s">"BDA"</span><span class="o">};</span>

        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">skill</span><span class="o">,</span> <span class="n">skill_trees</span><span class="o">);</span>

    <span class="o">}</span>

<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>

<ul>
  <li>다른 분들의 풀이를 보니 스트림 공부의 필요성을 절실히 느낀다.</li>
</ul>

<hr />

<p><br /></p>

<h3 id="출처">출처</h3>
<p>-
—</p>

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://school.programmers.co.kr/learn/courses/30/lessons/49993">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 2 - 스킬트리]]></summary></entry><entry><title type="html">[Java] 프로그래머스(level-2) - 게임 맵 최단거리</title><link href="http://localhost:4000/java/221-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-2) - 게임 맵 최단거리" /><published>2023-07-14T00:00:00+09:00</published><updated>2023-07-14T00:00:00+09:00</updated><id>http://localhost:4000/java/221-post</id><content type="html" xml:base="http://localhost:4000/java/221-post/"><![CDATA[<p><br /></p>

<center><img src="/assets/images/programmers/" width="100%" /></center>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />

<p>이 문제는 <strong>그래프 탐색 알고리즘</strong> 를 이용해 풀 수 있는 문제이다. DFS나 BFS 모두를 이용할 수 있지만 필자는 <strong>너비우선탐색인 BFS를 이용</strong>했다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>이 문제는 BFS를 이용해 캐릭터의 위치인 <code class="language-plaintext highlighter-rouge">(0,0)</code> 부터 게임 맵을 탐색해가며 상대방 진영의 위치인 `(N,M) 위치까지의 최단 이동거리를 구하면 된다.</p>

<p>상대방 진영까지의 최단거리를 구하기 위해 생각한 아이디어는 다음과 같다.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">(0,0)</code> 위치부터 벽이 아닌 이동할 수 있는 칸을 탐색해가며 이동한다.</li>
  <li>캐릭터를 이동해가며 <strong>위치마다 이동한 거리를 기록</strong>한다.</li>
  <li>상대방 진영에 도착했다면, 상대방 진영의 위치인 <code class="language-plaintext highlighter-rouge">(N,M)</code> 에 기록된 이동거리를 반환한다.
    <blockquote>
      <p>이때, 만약 <code class="language-plaintext highlighter-rouge">(N,M)</code> 위치에 이동거리가 1이라면 주변이 벽(0)으로 막혀 상대방 진영에 도착할 수 없는 것이기에 -1을 반환한다.</p>
    </blockquote>
  </li>
</ol>

<p>위와 같이 BFS의 원리만 잘 이해하고 있다면 쉽게 풀 수 있다.</p>

<p><br /></p>

<p>다음으로 문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
</pre></td><td class="rouge-code"><pre>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="c1">// 상,하,좌,우로 탐색할 dx, dy 배열</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dx</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>

    <span class="c1">// 방문 여부를 체크할 배열</span>
    <span class="kd">static</span> <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">visited</span><span class="o">;</span>
    
    <span class="c1">// 전역으로 사용할 게임 맵 2차원 배열</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">map</span><span class="o">;</span>
    
    <span class="c1">// 게임 맵의 크기 NXM</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="no">N</span><span class="o">,</span> <span class="no">M</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">maps</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// 게임 맵의 크기 N과 M 초기화</span>
        <span class="no">N</span> <span class="o">=</span> <span class="n">maps</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
        <span class="no">M</span> <span class="o">=</span> <span class="n">maps</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span>

        <span class="c1">// 게임 맵 배열 초기화</span>
        <span class="n">map</span> <span class="o">=</span> <span class="n">maps</span><span class="o">;</span>
        
        <span class="c1">// 방문 배열 초기화</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">M</span><span class="o">];</span>

        <span class="c1">// 캐릭터의 위치인 0,0 위치에서 BFS 함수 호출</span>
        <span class="no">BFS</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>

        <span class="cm">/**
         * BFS 탐색이 종료되면, map 배열의 N,M 위치에 기록된 이동거리 반환
         * 만약, 벽에 가로막혀 상대방 진영에 도착하지 못한다면, -1 반환
         */</span>
        <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="no">M</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">map</span><span class="o">[</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="no">M</span><span class="o">-</span><span class="mi">1</span><span class="o">];</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">BFS</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">});</span>
        
        <span class="n">visited</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

        <span class="k">while</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            
            <span class="kt">int</span><span class="o">[]</span> <span class="n">now</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">dir</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">dir</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">;</span> <span class="n">dir</span><span class="o">++)</span> <span class="o">{</span>
                
                <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">now</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">dx</span><span class="o">[</span><span class="n">dir</span><span class="o">];</span>
                <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">now</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">dy</span><span class="o">[</span><span class="n">dir</span><span class="o">];</span>
                
                <span class="cm">/**
                 * 게임 맵 배열의 범위를 벗어나지 않고 이동할 수 있는 칸인지를 확인해간다.
                 * 이동할 수 있는 칸으로 이동할 경우, map 배열 각 위치에 이동거리를 갱신한다.
                 */</span> 
                <span class="k">if</span><span class="o">(</span><span class="n">isRange</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">))</span> <span class="o">{</span>
                    
                    <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">map</span><span class="o">[</span><span class="n">now</span><span class="o">[</span><span class="mi">0</span><span class="o">]][</span><span class="n">now</span><span class="o">[</span><span class="mi">1</span><span class="o">]]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">});</span>
                    <span class="o">}</span>

                <span class="o">}</span>

            <span class="o">}</span>

        <span class="o">}</span>
        
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isRange</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">&lt;</span><span class="no">N</span> <span class="o">&amp;&amp;</span> <span class="n">y</span><span class="o">&lt;</span><span class="no">M</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">maps</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[][]{{</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">},</span>
                                   <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">},</span>
                                   <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">},</span>
                                   <span class="o">{</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">},</span>
                                   <span class="o">{</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">}};</span>
        <span class="c1">// int[][] maps = new int[][]{{1,0,1,1,1},</span>
        <span class="c1">//                             {1,0,1,0,1},</span>
        <span class="c1">//                             {1,0,1,1,1},</span>
        <span class="c1">//                             {1,1,1,0,0},</span>
        <span class="c1">//                             {0,0,0,0,1}};</span>

        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">maps</span><span class="o">);</span>

    <span class="o">}</span>

<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<ul>
  <li>
    <hr />
  </li>
</ul>

<p><br /></p>

<h3 id="출처">출처</h3>
<p>-
—</p>

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://school.programmers.co.kr/learn/courses/30/lessons/1844">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 2 - 게임 맵 최단거리]]></summary></entry><entry><title type="html">[Java] 프로그래머스(level-2) - 모음 사전</title><link href="http://localhost:4000/java/223-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-2) - 모음 사전" /><published>2023-07-14T00:00:00+09:00</published><updated>2023-07-14T00:00:00+09:00</updated><id>http://localhost:4000/java/223-post</id><content type="html" xml:base="http://localhost:4000/java/223-post/"><![CDATA[<p><br /></p>

<center><img src="/assets/images/programmers/" width="100%" /></center>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />

<p>이번 문제는 <strong>재귀(DFS)</strong>를 이용해 풀 수 있다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>문자가 정해진 단어 안에서 어떤 규칙이 있는지 살펴보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="mi">1</span>   <span class="no">A</span>
<span class="mi">2</span>   <span class="no">AA</span>
<span class="mi">3</span>   <span class="no">AAA</span>
<span class="mi">4</span>   <span class="no">AAAA</span>
<span class="mi">5</span>   <span class="no">AAAAA</span>
<span class="mi">6</span>   <span class="no">AAAAE</span>
<span class="mi">7</span>   <span class="no">AAAAI</span>
<span class="mi">8</span>   <span class="no">AAAAO</span>
<span class="mi">9</span>   <span class="no">AAAAU</span>
<span class="mi">10</span>  <span class="no">AAAE</span> 
<span class="mi">11</span>  <span class="no">AAAEA</span>
<span class="mi">12</span>  <span class="no">AAAEE</span>
<span class="mi">13</span>  <span class="no">AAAEI</span>
<span class="mi">14</span>  <span class="no">AAAEO</span>
<span class="mi">15</span>  <span class="no">AAAEU</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>재귀를 통해 깊이우선탐색하는 것과 유사하지 않은가? 그래서 생각해낸 아이디어는 다음과 같다.</p>

<ul>
  <li>모음인 <code class="language-plaintext highlighter-rouge">A, E, I, O, U</code>를 모두 탐색하면서 <strong>재귀</strong>를 통해 문자열을 <strong>5의 길이만큼 만들어가는 조합</strong>을 적용한다.</li>
</ul>

<blockquote>
  <p>모든 경우의 수를 구해야 주어진 word의 순서를 구할 수 있으니 재귀함수를 통해 5의 길이까지의 모음의 모든 경우를 리스트에 담아둔 후, 리스트에서 선형 탐색으로 word의 순서를 찾으면 된다.</p>
</blockquote>

<p><br /></p>

<p>다음으로 문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
</pre></td><td class="rouge-code"><pre>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="c1">// A,E,I,O,U 모음 배열과 최대길이가 될 상수 선언</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">words</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[]{</span><span class="s">"A"</span><span class="o">,</span> <span class="s">"E"</span><span class="o">,</span> <span class="s">"I"</span><span class="o">,</span> <span class="s">"O"</span><span class="o">,</span> <span class="s">"U"</span><span class="o">};</span>
    <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">MAX_LENGTH</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>

    <span class="c1">// 모든 모음을 경우의 수를 담을 List</span>
    <span class="kd">static</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="c1">// 주어진 word가 몇번째 순서인지를 담을 변수</span>
        <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="c1">// 재귀 함수 호출</span>
        <span class="n">recursion</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="s">""</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>

        <span class="c1">// 재귀함수 종료 후, 선형탐색으로 word의 순서를 찾는다.</span>
        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">i</span><span class="o">).</span><span class="na">equals</span><span class="o">(</span><span class="n">word</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">answer</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>

        <span class="o">}</span>

        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>

    <span class="o">}</span>

    <span class="cm">/**
     * 모음 문자열 배열을 완전탐색하며 모든 모음을 깊이 우선으로 탐색할 재귀함수
     * 모음의 모든 조합을 만들어야 word의 순서를 찾을 수 있다.
     */</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">recursion</span><span class="o">(</span><span class="nc">String</span> <span class="n">word</span><span class="o">,</span> <span class="nc">String</span> <span class="n">str</span><span class="o">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// 길이가 5가 되면 탐색을 종료한다.</span>
        <span class="k">if</span><span class="o">(</span><span class="n">depth</span> <span class="o">==</span> <span class="no">MAX_LENGTH</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 모든 조합의 수를 List에 담는다.</span>
        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
        
        <span class="c1">// A,E,I,O,U를 탐색하며 재귀호출</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">words</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">recursion</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">str</span><span class="o">+</span><span class="n">words</span><span class="o">[</span><span class="n">i</span><span class="o">],</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
        
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        
        <span class="c1">// String word = "AAAAE";</span>
        <span class="c1">// String word = "AAAE";</span>
        <span class="nc">String</span> <span class="n">word</span> <span class="o">=</span> <span class="s">"EIO"</span><span class="o">;</span>

        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">word</span><span class="o">);</span>

    <span class="o">}</span>

<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<p>-
—</p>

<p><br /></p>

<h3 id="출처">출처</h3>
<p>-
—</p>

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://school.programmers.co.kr/learn/courses/30/lessons/84512">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 2 - 모음 사전]]></summary></entry></feed>