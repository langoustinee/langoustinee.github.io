<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-08-14T12:21:51+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">lango’s DevLog</title><subtitle>developer</subtitle><author><name>lango</name></author><entry><title type="html">[Java] 프로그래머스(level-2) - 프렌즈 4블록</title><link href="http://localhost:4000/java/253-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-2) - 프렌즈 4블록" /><published>2023-08-14T00:00:00+09:00</published><updated>2023-08-14T00:00:00+09:00</updated><id>http://localhost:4000/java/253-post</id><content type="html" xml:base="http://localhost:4000/java/253-post/"><![CDATA[<p><br /></p>

<center><img src="/assets/images/programmers/" width="100%" /></center>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />

<p>이번 문제는 문제에서 요구한 대로 구현하기만 하면 되는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>문제의 요구사항대로 정리하면 아이디어는 간단하다.</p>

<ol>
  <li>2X2 블록을 체크한다.</li>
  <li>체크된 2x2 블록을 제거한다. <strong>블록의 제거는 ‘#’으로 치환</strong>하는 것으로 한다.</li>
  <li>블록을 떨어뜨린다.</li>
  <li>제거할 블록이 없을 때까지 1-3번 과정을 반복한다.</li>
</ol>

<p>2X2 블록을 체크하고 제거하는 것은 크게 어렵지 않았지만, 블록을 떨어뜨리는(윗블록과 아랫블록을 교체하는) 작업에서 배열을 잘 다룰 수 있어야 함을 느꼈다.</p>

<blockquote>
  <p>블록을 떨어뜨릴 때는 board를 탐색하면서 3중 for문을 이용해 세로 열로 제거된 블록과 제거되지 않은 블록을 교체하도록 구현하였다.</p>
</blockquote>

<p><br /></p>

<p>다음으로 문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
</pre></td><td class="rouge-code"><pre>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="c1">// 1. 2X2 블록을 체크한다.</span>
    <span class="c1">// 2. 체크된 2x2 블록을 제거한다. 블록의 제거는 '#'으로 치환하는 것으로 한다.</span>
    <span class="c1">// 3. 블록을 떨어뜨린다.</span>
    <span class="c1">// 4. 제거할 블록이 없을 때까지 1-3번 과정을 반복한다.</span>

    <span class="kd">static</span> <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">visited</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">char</span><span class="o">[][]</span> <span class="n">map</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">board</span><span class="o">)</span> <span class="o">{</span>

        <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">input</span> <span class="o">=</span> <span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 제거된 블록의 수를 담기 위해 0으로 초기화</span>
        <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        
        <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
            
            <span class="kt">boolean</span> <span class="n">isContinue</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>

            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">++</span> <span class="o">)</span> <span class="o">{</span>
                    
                    <span class="c1">// 이미 지워진 블록은 체크할 필요가 없다.</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'#'</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">continue</span><span class="o">;</span>
                    <span class="o">}</span>

                    <span class="c1">// 현재 위치부터 2X2 블록이 같다면 체크해둔다.</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">checkBlock</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">))</span> <span class="o">{</span>
                        <span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="n">isContinue</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="o">}</span>

                <span class="o">}</span>
            <span class="o">}</span>

            <span class="c1">// 종료조건: 제거할 블록이 없다면 종료한다.</span>
            <span class="k">if</span><span class="o">(</span><span class="n">isContinue</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            
            <span class="c1">// 지워진 블록의 수를 담는다.</span>
            <span class="n">answer</span> <span class="o">+=</span> <span class="n">removeBlock</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
            
            <span class="c1">// 블록 제거 후 위에 있는 블록을 떨어뜨린다.</span>
            <span class="n">dropBlock</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>

        <span class="o">}</span>


        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">answer</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>

    <span class="o">}</span>

    <span class="c1">// 현재 위치의 블록으로부터 오른쪽, 아래, 오른쪽 아래 블록이 같은 블록인지 확인하는 함수</span>
    <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">checkBlock</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">char</span> <span class="n">block</span> <span class="o">=</span> <span class="n">map</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">];</span>
        <span class="k">if</span><span class="o">(</span><span class="n">block</span> <span class="o">==</span> <span class="n">map</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">block</span> <span class="o">==</span> <span class="n">map</span><span class="o">[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">block</span> <span class="o">==</span> <span class="n">map</span><span class="o">[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 블록을 '#'으로 치환해 제거한다.</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="nf">removeBlock</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>

        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// 블록을 제거하면서 제거된 블록의 수 카운트</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
                    <span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'#'</span><span class="o">;</span>
                    <span class="n">cnt</span><span class="o">++;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">dropBlock</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">--)</span> <span class="o">{</span>
                
                <span class="c1">// '#' 로 제거된 블록만 위로 올린다.</span>
                <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'#'</span><span class="o">)</span> <span class="o">{</span>
                    
                    <span class="c1">// 세로로 탐색하며 제거된 블록을 스왑하여 위의 블록을 아래로 내린다.</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">k</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">;</span> <span class="n">k</span><span class="o">--)</span> <span class="o">{</span>
                        
                        <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'#'</span><span class="o">)</span> <span class="o">{</span>
                            <span class="k">continue</span><span class="o">;</span>
                        <span class="o">}</span>

                        <span class="n">map</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">map</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">i</span><span class="o">];</span>
                        <span class="n">map</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'#'</span><span class="o">;</span>
                        <span class="k">break</span><span class="o">;</span>

                    <span class="o">}</span>

                <span class="o">}</span>
                
            <span class="o">}</span>

        <span class="o">}</span>

    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        
        <span class="c1">// int m = 6;</span>
        <span class="c1">// int n = 6;</span>
        <span class="c1">// String[] board = new String[]{"TTTANT", "RRFACC", "RRRFCC", "TRRRAA", "TTMMMF", "TMMTTJ"};</span>

        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">board</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[]{</span><span class="s">"CCBDE"</span><span class="o">,</span> <span class="s">"AAADE"</span><span class="o">,</span> <span class="s">"AAABF"</span><span class="o">,</span> <span class="s">"CCBBF"</span><span class="o">};</span>

        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span> <span class="o">,</span> <span class="n">board</span><span class="o">);</span>

    <span class="o">}</span>

<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<p>-</p>

<hr />

<p><br /></p>

<h3 id="출처">출처</h3>
<p>-</p>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://school.programmers.co.kr/learn/courses/30/lessons/17679">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 2 - 프렌즈 4블록]]></summary></entry><entry><title type="html">[Java] 백준(골드-4) 9663번 - N-Queen</title><link href="http://localhost:4000/java/251-post/" rel="alternate" type="text/html" title="[Java] 백준(골드-4) 9663번 - N-Queen" /><published>2023-08-11T00:00:00+09:00</published><updated>2023-08-11T00:00:00+09:00</updated><id>http://localhost:4000/java/251-post</id><content type="html" xml:base="http://localhost:4000/java/251-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이 문제는 <strong>백트래킹</strong> 유형의 대표 문제 중 하나이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>이 문제에서는 아래 두가지를 유심히 살펴봐야 한다.</p>

<ol>
  <li>재귀함수를 어떻게 호출할까?</li>
  <li>퀸을 놓을 수 있는지 어떻게 확인할까?</li>
</ol>

<p>예시를 살펴보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="c1">// N = 4일 때 경우의 수는 2가지</span>

<span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span>
<span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span>
<span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span>
<span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span>
<span class="o">=&gt;</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">]</span>

<span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span>
<span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span>
<span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span>
<span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span>
<span class="o">=&gt;</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>잘 보면 <strong>각 원소의 값을 행</strong>이라고 하고, <strong>각 원소의 인덱스를 열</strong>이라고 하면 1차원 배열로 표현할 수 있다는 것을 알 수 있다.</p>

<p>위 예시의 첫번째 경우를 보면 <code class="language-plaintext highlighter-rouge">[2, 0, 3, 1]</code> 으로 원소의 값을 행, 인덱스를 열이라 생각하면 이해하기 쉽다.</p>

<p><br /></p>

<h4 id="재귀-호출-아이디어">재귀 호출 아이디어</h4>
<p>그러면 재귀호출을 어떻게 해야할지 어느정도 그림이 그려진다.</p>

<p><strong>첫 번째 열부터 퀸을 놓을 수 있는 위치라면 퀸을 놓아가면서 재귀호출을 하며 마지막 열까지 채웠을 때 N개의 퀸을 놓았으면 재귀 호출을 종료</strong>하면 된다.</p>

<h4 id="퀸-검증-아이디어">퀸 검증 아이디어</h4>
<p>재귀 호출 중 맵의 위치를 탐색해가며 현재 위치에 퀸을 놓을 수 있는지 어떻게 알 수 있을까? 다음 2가지 조건을 고려해야 한다.</p>

<ol>
  <li>해당 열, 같은 행에 다른 퀸이 놓여있을 경우, <strong>해당 열의 행과 i열의 행이 일치할 경우 같은 행에 놓여있다</strong>는 의미이다.</li>
  <li>대각선상에 다른 퀸이 놓여있을 경우, <strong>행의 차와 열의 차가 같다면 대각선에 놓여있다</strong>는 의미이다.</li>
</ol>

<p>위 2가지 조건 중 하나라도 걸린다면 현재 위치에 퀸을 놓지 못한다고 보면 된다.</p>

<p><br /></p>

<p>자 위 내용들을 통해 정리한 문제 풀이 아이디어를 보자.</p>

<ol>
  <li>0번째 열부터 DFS를 호출해가며 퀸을 놓을 수 있는 위치인지 확인하여 퀸을 놓는다.</li>
  <li>퀸을 놓을 수 있는 위치인지 확인할 때, 현재 열의 다른 행에 퀸이 이미 놓여있는지, 현재 위치 기준 대각선 상에 이미 퀸이 놓여있는지를 검사한다.</li>
  <li>위 과정을 반복하며 N-1번째 열까지 탐색했을 때 N개의 퀸을 놓았다면 경우의 수의 카운트를 1 증가시키고 재귀를 종료한다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// 퀸이 서로 공격할 수 없도록 배치하는 모든 경우의 수를 구해야 한다.</span>

    <span class="c1">// 게임판의 크기</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="no">N</span><span class="o">;</span>

    <span class="c1">// 퀸을 놓을 배열</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">map</span><span class="o">;</span>

    <span class="c1">// 경우의 수를 담을 변수</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">result</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
            
                <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
                
                <span class="c1">// 재귀함수 호출</span>
                <span class="n">dfs</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>

                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span> <span class="o">+</span> <span class="s">"\n"</span><span class="o">);</span>
                
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">depth</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="c1">// 깊이가 N이 되면 즉 행을 다 채우면 카운트 1 증가시키고 재귀 종료</span>
        <span class="k">if</span><span class="o">(</span><span class="n">depth</span> <span class="o">==</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">++;</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 1부터 N까지의 열을 탐색하며 i번째 행에 퀸을 놓는다.</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            
            <span class="c1">// i열 depth행에 퀸을 놓는다.</span>
            <span class="n">map</span><span class="o">[</span><span class="n">depth</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>

            <span class="c1">// 현재 열에서 i번째 행에 퀸을 놓을 수 있는지 확인하여 재귀 호출한다.</span>
            <span class="k">if</span><span class="o">(</span><span class="n">checkQueen</span><span class="o">(</span><span class="n">depth</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>

        <span class="o">}</span>

    <span class="o">}</span>

    <span class="c1">// 현재 위치가 퀸을 놓을 수 있는지 확인할 함수</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">checkQueen</span><span class="o">(</span><span class="kt">int</span> <span class="n">col</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">col</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            
            <span class="c1">// 해당 열의 행과 i열의 행이 일치할 경우</span>
            <span class="c1">// 즉, 같은 행에 퀸이 놓여있을 경우는 퀸을 놓을 수 없기에 false</span>
            <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">col</span><span class="o">]</span> <span class="o">==</span> <span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// 대각선 상에 퀸이 놓여있을 경우 불가하기에 false</span>
            <span class="c1">// 열의 차와 행의 차가 같은 경우는 대각선에 놓여 있다는 뜻이다.</span>
            <span class="c1">// col - i: 열의 차</span>
            <span class="c1">// map[col] - map[i]: 행의 차</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">col</span> <span class="o">-</span> <span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">col</span><span class="o">]</span> <span class="o">-</span> <span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/9663">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[9663번 - N-Queen]]></summary></entry><entry><title type="html">[Java] 백준(실버-3) 15652번 - N과 M (4)</title><link href="http://localhost:4000/java/250-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-3) 15652번 - N과 M (4)" /><published>2023-08-11T00:00:00+09:00</published><updated>2023-08-11T00:00:00+09:00</updated><id>http://localhost:4000/java/250-post</id><content type="html" xml:base="http://localhost:4000/java/250-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 유사한 유형인 <a href="https://langoustinee.github.io/java/194-post/">N과 M (2)</a> 문제처럼 <strong>백트래킹</strong>을 이용해 풀 수 있다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>오름차순 수열을 유지해야 하는 N과 M (2) 문제와 유사해보이지만, 이번 문제에서는 <strong>비내림차순으로 중복 여부가 허용</strong>됨을 고려해야 한다.</p>

<p>재귀함수를 어떻게 짜야 할까?</p>

<p>여기서도 깊이를 의미하는 depth와 함께 현재 위치를 의미하는 at을 함께 사용해야 한다. <strong>비내림차순으로 중복 여부가 허용</strong>되기에 1부터 N까지 탐색하며 다음 재귀를 호출할 때 <strong>i값을 at으로 넘겨 재귀호출</strong>하면 된다.</p>

<blockquote>
  <p>N과 M (2) 문제처럼 오름차순으로 수열을 담기 위해 i+1 값을 at으로 넘겨주는 것이 아니라, <strong>비내림차순으로 현재 위츼 i값도 허용</strong>되기에 i+1값이 아닌 i값을 at으로 넘겨준다.</p>
</blockquote>

<p>문제 풀이를 위한 아이디어는 다음과 같다.</p>

<ol>
  <li>DFS 재귀함수를 통해 1부터 N까지 탐색한다.</li>
  <li>탐색하며 재귀 호출할 때 현재 위치를 의히마는 at 변수와 깊이인 depth 변수 2가지를 인자로 호출한다.</li>
  <li>비내림차순의 수열을 유지하기 위해 중복이 허용되도록 <strong>1 ~ N까지 탐색할 때, at 변수를 현재 위치 i값으로 다음 재귀를 호출</strong>하며 수열을 갱신한다.</li>
  <li>수열의 길이(재귀함수의 깊이)가 M이 된다면 배열에 담아둔 수열을 저장하고 종료한다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// 1. 1~N까지 길이가 M인 수열을 선택해야 한다.</span>
    <span class="c1">// 2. 선택한 수열은 비내림차순이어야 한다. (비내림차순 != 오름차순)</span>
    <span class="c1">// 3. 중복 여부를 고려하지 않으므로 중복이 허용된다.</span>

    <span class="c1">// 수열 배열 선언</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">;</span>

    <span class="c1">// 입력 N, M 선언</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="no">N</span><span class="o">,</span> <span class="no">M</span><span class="o">;</span>

    <span class="c1">// 출력할 수열을 담을 StringBuilder 선언</span>
    <span class="kd">static</span> <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
            
                <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                
                <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                
                <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">M</span><span class="o">];</span>

                <span class="n">dfs</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>

                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">sb</span> <span class="o">+</span> <span class="s">"\n"</span><span class="o">);</span>
                
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="cm">/**
     * 백트래킹 DFS 재귀함수
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">at</span><span class="o">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// 재귀 인덱스가 마지막 위치인 M이 된다면 수열을 sb에 담은 후 종료</span>
        <span class="k">if</span><span class="o">(</span><span class="n">depth</span> <span class="o">==</span> <span class="no">M</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">M</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]).</span><span class="na">append</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"\n"</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="cm">/**
         * 1부터 N까지 깊이를 1씩 증가시키며 DFS를 재귀호출한다.
         * arr 배열에 M 길이만큼의 조합을 담아나간다.
         * 오름차순과는 다르게 비내림차순으로 중복이 허용되기에 동일한 i값을 at으로 넘겨준다.
         */</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">at</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">depth</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/15652">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[15652번 - N과 M (4)]]></summary></entry><entry><title type="html">[Java] 백준(실버-3) 15651번 - N과 M (3)</title><link href="http://localhost:4000/java/249-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-3) 15651번 - N과 M (3)" /><published>2023-08-11T00:00:00+09:00</published><updated>2023-08-11T00:00:00+09:00</updated><id>http://localhost:4000/java/249-post</id><content type="html" xml:base="http://localhost:4000/java/249-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 유사한 유형인 <a href="https://langoustinee.github.io/java/193-post/">N과 M (1)</a> 문제처럼 <strong>백트래킹</strong>을 이용해 풀 수 있다. 사실 저 문제보다 더 쉽게 풀 수 있다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>1~N까지 길이가 M인 수열을 선택해야 한다는 조건은 N과 M (1) 문제와 동일하다. 그런데, 이번 문제에서는 <strong>수열의 중복 여부가 허용</strong>되기 때문에 더 쉽다고 볼 수 있다.</p>

<p>문제 풀이를 위한 아이디어는 다음과 같다.</p>

<ol>
  <li>DFS 재귀함수를 통해 1부터 N까지 탐색한다.</li>
  <li>수열의 길이(재귀함수의 깊이)가 M이 된다면 배열에 담아둔 수열을 저장하고 종료한다.</li>
</ol>

<blockquote>
  <p>이번 문제에서도 결과로 출력할 수열을 <strong>StringBuilder</strong>에 담아서 출력하도록 하였다.</p>
</blockquote>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// 1. 1~N까지 길이가 M인 수열을 선택해야 한다.</span>
    <span class="c1">// 2. 수열 중복이 가능하다. 그렇기에 방문 배열이 필요없다.</span>

    <span class="c1">// 수열 배열 선언</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">;</span>

    <span class="c1">// 입력 N, M 선언</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="no">N</span><span class="o">,</span> <span class="no">M</span><span class="o">;</span>

    <span class="c1">// 출력할 수열을 담을 StringBuilder 선언</span>
    <span class="kd">static</span> <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
            
                <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                
                <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">M</span><span class="o">];</span>

                <span class="n">dfs</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>

                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">sb</span> <span class="o">+</span> <span class="s">"\n"</span><span class="o">);</span>
                
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="cm">/**
     * 백트래킹 DFS 재귀함수
     * 
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">depth</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// 재귀 인덱스가 마지막 위치인 M이 된다면 수열을 sb에 담은 후 종료</span>
        <span class="k">if</span><span class="o">(</span><span class="n">depth</span> <span class="o">==</span> <span class="no">M</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">M</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]).</span><span class="na">append</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"\n"</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="cm">/**
         * 1부터 N까지 깊이를 1씩 증가시키며 DFS를 재귀호출한다.
         * arr 배열에 M 길이만큼의 조합을 담아나간다.
         */</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">depth</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/15651">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[15651번 - N과 M (3)]]></summary></entry><entry><title type="html">[Java] 백준(실버-1) 14888번 - 연산자 끼워넣기</title><link href="http://localhost:4000/java/252-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-1) 14888번 - 연산자 끼워넣기" /><published>2023-08-11T00:00:00+09:00</published><updated>2023-08-11T00:00:00+09:00</updated><id>http://localhost:4000/java/252-post</id><content type="html" xml:base="http://localhost:4000/java/252-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이 문제는 재귀를 통한 <strong>백트래킹</strong> 유형으로 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>문제의 입력을 살펴보면 다음과 같다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="n">첫째</span> <span class="n">줄</span> <span class="o">:</span> <span class="n">수의</span> <span class="n">개수</span> <span class="no">N</span>
<span class="n">둘째</span> <span class="n">줄</span> <span class="o">:</span> <span class="n">수</span>
<span class="n">셋째</span> <span class="n">줄</span> <span class="o">:</span> <span class="n">덧셈</span><span class="o">,</span> <span class="n">뺄셈</span><span class="o">,</span> <span class="n">곱셈</span><span class="o">,</span> <span class="n">나눗셈</span> <span class="n">각각의</span> <span class="n">개수</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>필자는 연산자를 입력받는 셋째 줄에서 각 연산자를 1차원 배열로 처리하도록 구현하였다. 문제풀이를 위한 아이디어는 다음과 같다.</p>

<ol>
  <li>N개의 수를 N 크기의 배열에 입력받고, 4칸의 배열에 연산자의 개수를 입력받는다.</li>
  <li>연산자 개수만큼 4번을 반복하며 +, -, *, / 경우에 따른 DFS 재귀함수를 호출해나간다.</li>
  <li>첫번째 수부터 N번째 수까지 +, -, *, / 연산한 값을 깊이를 1 증가시키며 다음 DFS로 재귀 호출한다.</li>
  <li>이때, 연산자 개수를 1씩 감소시키고 DFS를 호출한 뒤 연산자 개수를 다시 1 증가시켜줘야 한다.</li>
  <li>재귀의 깊이가 N과 같다면 모든 수를 탐색하며 연산자 개수를 사용했으니 이때의 연산 값이 최대값인지 최솟값인지 갱신해주고 재귀를 종료한다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// 둘째줄에 N개의 수를 담을 배열 선언</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">;</span>
    
    <span class="c1">// +,-,*,/ 4개의 연산자 개수를 담을 배열 선언</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">operator</span><span class="o">;</span>

    <span class="c1">// 수의 개수 N, 최댓값 max, 최솟값 min 선언</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="no">N</span><span class="o">,</span> <span class="n">max</span><span class="o">,</span> <span class="n">min</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
            
                <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

                <span class="c1">// 수 배열 및 연산자 배열 초기화</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
                <span class="n">operator</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">4</span><span class="o">];</span>

                <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                <span class="o">}</span>
                
                <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="n">operator</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                <span class="o">}</span>
                
                <span class="c1">// 최댓값 및 최솟값을 찾기 위한 초기화</span>
                <span class="n">max</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MIN_VALUE</span><span class="o">;</span>
                <span class="n">min</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

                <span class="c1">// DFS 함수 호출</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="mi">1</span><span class="o">);</span>

                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">max</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">min</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>

        <span class="o">}</span>

    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="kt">int</span> <span class="n">idx</span><span class="o">)</span> <span class="o">{</span>

        <span class="cm">/**
         * 재귀 종료 조건
         * 1부터 N 수까지의 탐색을 완료했다면 재귀를 종료한다.
         * 이때, 현재 수와 재귀호출을 통해 만들어낸 n이 최대일 때와 최소인 값을 담은 후 종료한다.
         */</span>
        <span class="k">if</span><span class="o">(</span><span class="n">idx</span> <span class="o">==</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">max</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">max</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
            <span class="n">min</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">min</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            
            <span class="c1">// 현재 연산자 개수가 1개 이상이라면</span>
            <span class="k">if</span><span class="o">(</span><span class="n">operator</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                
                <span class="c1">// 해당 연산자 개수 1 차감</span>
                <span class="n">operator</span><span class="o">[</span><span class="n">i</span><span class="o">]--;</span>

                <span class="cm">/*
                 * i 별로 재귀호출한다.
                 * i==0 이면 +
                 * i==1 이면 -
                 * i==2 이면 *
                 * i==3 이면 /
                 */</span>
                <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">dfs</span><span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">arr</span><span class="o">[</span><span class="n">idx</span><span class="o">],</span> <span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">dfs</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">arr</span><span class="o">[</span><span class="n">idx</span><span class="o">],</span> <span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">dfs</span><span class="o">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">arr</span><span class="o">[</span><span class="n">idx</span><span class="o">],</span> <span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span> <span class="k">else</span> <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">3</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">dfs</span><span class="o">(</span><span class="n">n</span> <span class="o">/</span> <span class="n">arr</span><span class="o">[</span><span class="n">idx</span><span class="o">],</span> <span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span>

                <span class="c1">// 해당 연산자 개수를 다시 원복한다.</span>
                <span class="n">operator</span><span class="o">[</span><span class="n">i</span><span class="o">]++;</span>

            <span class="o">}</span>

        <span class="o">}</span>

    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/14888">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[14888번 - 연산자 끼워넣기]]></summary></entry><entry><title type="html">[Java] 백준(실버-1) 6064번 - 카잉 달력</title><link href="http://localhost:4000/java/248-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-1) 6064번 - 카잉 달력" /><published>2023-08-10T00:00:00+09:00</published><updated>2023-08-10T00:00:00+09:00</updated><id>http://localhost:4000/java/248-post</id><content type="html" xml:base="http://localhost:4000/java/248-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 문제의 요구사항을 통해 두 수의 관계를 고려하여 나머지 연산을 활용해 풀어야 한다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>문제 요구사항을 다시 살펴보자.</p>

<blockquote>
  <p>만일 x &lt; M 이면 x’ = x + 1이고, 그렇지 않으면 x’ = 1이다. 같은 방식으로 만일 y &lt; N이면 y’ = y + 1이고, 그렇지 않으면 y’ = 1이다.</p>
</blockquote>

<p>그렇다면 예를 들어보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="c1">// &lt;M, N&gt;이 &lt;10, 12&gt;일 때</span>
<span class="mi">1</span><span class="n">번째</span> <span class="n">해</span> <span class="o">:</span> <span class="o">&lt;</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">&gt;</span>
<span class="mi">2</span><span class="n">번째</span> <span class="n">해</span> <span class="o">:</span> <span class="o">&lt;</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">&gt;</span>
<span class="o">...</span>
<span class="mi">10</span><span class="n">번째</span> <span class="n">해</span> <span class="o">:</span> <span class="o">&lt;</span><span class="mi">10</span><span class="o">,</span> <span class="mi">10</span><span class="o">&gt;</span>
<span class="mi">11</span><span class="n">번째</span> <span class="n">해</span> <span class="o">:</span> <span class="o">&lt;</span><span class="mi">1</span><span class="o">,</span> <span class="mi">11</span><span class="o">&gt;</span>
<span class="mi">12</span><span class="n">번째</span> <span class="n">해</span> <span class="o">:</span> <span class="o">&lt;</span><span class="mi">2</span><span class="o">,</span> <span class="mi">12</span><span class="o">&gt;</span>
<span class="mi">13</span><span class="n">번째</span> <span class="n">해</span> <span class="o">:</span> <span class="o">&lt;</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">&gt;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>위처럼 x가 M, y가 N에 도달하는 순간 1로 변경된다.</p>

<blockquote>
  <p>여기서 완전탐색을 통해 하나씩 모두 계산할 경우 O(nm)의 시간복잡도를 가지기에 시간초과가 발생할 수 있다.</p>
</blockquote>

<p>문제를 풀기 위한 아이디어는 바로 <strong>나머지 연산</strong>에 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="c1">// &lt;10, 12&gt;</span>
<span class="mi">1</span><span class="n">번째</span> <span class="n">해</span> <span class="o">:</span> <span class="o">&lt;</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">&gt;</span>
<span class="mi">2</span><span class="n">번째</span> <span class="n">해</span> <span class="o">:</span> <span class="o">&lt;</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">&gt;</span>
<span class="mi">3</span><span class="n">번째</span> <span class="n">해</span> <span class="o">:</span> <span class="o">&lt;</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">&gt;</span>
<span class="o">...</span>
<span class="mi">13</span><span class="n">번째</span> <span class="n">해</span> <span class="o">:</span> <span class="o">&lt;</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">&gt;</span>
<span class="o">...</span>
<span class="mi">23</span><span class="n">번째</span> <span class="n">해</span> <span class="o">:</span> <span class="o">&lt;</span><span class="mi">3</span><span class="o">,</span> <span class="mi">11</span><span class="o">&gt;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>3, 13, 23번째를 보면 M의 배수에서 3만큼 더한 값을 넘어야 3이 나오게 된다. 시간초과를 고려해 모든 경우를 다 구하며 계산할 순 없기 때문에, <strong>x값을 기준으로 y값을 함께 N으로 나눈 나머지가 y가 나오는지 확인</strong>하면 된다.</p>

<p>결국, 구할 수 있는 최대 범위는 M과 N의 최소공배수인데 이를 초과하는 경우는 표현될 수 있는 해가 없다는 것이기에 -1로 만들면 된다.</p>

<p>문제 풀이를 위한 아이디어는 다음과 같다.</p>

<ol>
  <li>M과 N의 최소공배수를 구하여 최소공배수까지 순회한다.</li>
  <li>순회하며 x값을 기준으로 y값도 N으로 나눈 나머지가 y가 된다면 해를 출력한다.</li>
  <li>순회하며 2번 기준이 충족되지 않는다면 구할 수 없는 해이기에 -1을 출력한다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
            
                <span class="kt">int</span> <span class="no">T</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

                <span class="k">while</span><span class="o">(</span><span class="no">T</span> <span class="o">--&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>

                    <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                    <span class="kt">int</span> <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

                    <span class="c1">// 최소 공배수 구해오기</span>
                    <span class="kt">int</span> <span class="n">lcm</span> <span class="o">=</span> <span class="no">LCM</span><span class="o">(</span><span class="no">M</span><span class="o">,</span> <span class="no">N</span><span class="o">);</span>

                    <span class="c1">// while 조건을 충족하지 않아 구할 수 없는 해라면 -1을 출력하기 위해 -1로 초기화한다.</span>
                    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>

                    <span class="c1">// 최소공배수의 범위를 벗어나면 구할 수 없는 해이다.</span>
                    <span class="c1">// x값과 y값을 N으로 나눈 나머지가 y인지 확인하여 해를 구한다.</span>
                    <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="k">while</span><span class="o">((</span><span class="n">cnt</span> <span class="o">*</span> <span class="no">M</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">lcm</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">if</span><span class="o">(((</span><span class="n">cnt</span> <span class="o">*</span> <span class="no">M</span><span class="o">)</span> <span class="o">+</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="o">)</span> <span class="o">%</span> <span class="no">N</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="n">cnt</span> <span class="o">*</span> <span class="no">M</span><span class="o">)</span> <span class="o">+</span> <span class="n">x</span><span class="o">;</span>
                            <span class="k">break</span><span class="o">;</span>
                        <span class="o">}</span>
                        <span class="n">cnt</span><span class="o">++;</span>
                    <span class="o">}</span>

                    <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>

                <span class="o">}</span>
                
                
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="c1">// 최소 공배수</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">LCM</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">/</span> <span class="no">GCD</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 최대 공약수</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">GCD</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span><span class="o">(</span><span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">x</span> <span class="o">%</span> <span class="n">y</span><span class="o">;</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">r</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/6064">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[6064번 - 카잉 달력]]></summary></entry><entry><title type="html">[Java] 프로그래머스(level-2) - 파일명 정렬</title><link href="http://localhost:4000/java/247-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-2) - 파일명 정렬" /><published>2023-08-09T00:00:00+09:00</published><updated>2023-08-09T00:00:00+09:00</updated><id>http://localhost:4000/java/247-post</id><content type="html" xml:base="http://localhost:4000/java/247-post/"><![CDATA[<p><br /></p>

<center><img src="/assets/images/programmers/" width="100%" /></center>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />

<p>이번 문제는 주어진 배열을 조건별로 <strong>정렬</strong>하여 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>문제에서 요구하는 정렬 기준에 따라서 정렬을 해야한다. 
필자는 Java를 이용해 풀기 때문에 <code class="language-plaintext highlighter-rouge">Comparator</code>의 <code class="language-plaintext highlighter-rouge">compare()</code> 메서드를 재정의하여 커스텀 정렬을 구현하였다.</p>

<p>문제 풀이를 위한 아이디어는 다음과 같다.</p>

<ol>
  <li>files 배열을 정렬하는 데, 파일명 별로 HEAD, NUMBER, TAIL를 분리한다.</li>
  <li>HEAD의 경우 대소문자 구분을 하지 않기에 대문자든, 소문자든 통일시킨다.</li>
  <li>HEAD와 NUMBER가 모두 같다면, <strong>HEAD를 기준으로 사전 순 정렬하여 입력 순서를 보장</strong>하도록 한다.</li>
  <li>HEAD만 같다면, <strong>NUMBER를 int형으로 비교하여 오름차순으로 정렬</strong>한다.</li>
</ol>

<p><br /></p>

<p>다음으로 문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
</pre></td><td class="rouge-code"><pre>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>


    <span class="kd">public</span> <span class="nc">String</span><span class="o">[]</span> <span class="nf">solution</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">files</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// 1. HEAD: 사전 순 정렬, 대소문자 구분 X</span>
        <span class="c1">// 2. NUMBER: 숫자 순 정렬, 숫자 앞 0 무시</span>
        <span class="c1">// 3. HEAD와 NUMBER가 같다면 입력 순서 유지</span>

        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">files</span><span class="o">,</span> <span class="o">(</span><span class="n">o1</span><span class="o">,</span> <span class="n">o2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            
            <span class="nc">String</span><span class="o">[]</span> <span class="n">o1_sep</span> <span class="o">=</span> <span class="n">separate</span><span class="o">(</span><span class="n">o1</span><span class="o">);</span>
            <span class="nc">String</span><span class="o">[]</span> <span class="n">o2_sep</span> <span class="o">=</span> <span class="n">separate</span><span class="o">(</span><span class="n">o2</span><span class="o">);</span>

            <span class="cm">/*
             * HEAD를 기준으로 사전 순 정렬을 한다.
             * 두 문자의 head가 같다면 0
             * o1의 head가 크면 양수
             * o2가 크면 음수
             */</span>
            <span class="kt">int</span> <span class="n">compareHead</span> <span class="o">=</span> <span class="n">o1_sep</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">compareTo</span><span class="o">(</span><span class="n">o2_sep</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
            
            <span class="cm">/*
             * HEAD가 같다면 NUMBER를 기준으로 오름차순 정렬한다.
             * NUMBER도 같다면 0을 반환하여 입력 순서를 보장한다.
             * 
             * 두 수의 HEAD가 다르다면, HEAD를 기준으로 정렬한다.
             */</span>
            <span class="k">if</span><span class="o">(</span><span class="n">compareHead</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">o1_num</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">o1_sep</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
                <span class="kt">int</span> <span class="n">o2_num</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">o2_sep</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
                <span class="k">return</span> <span class="n">o1_num</span> <span class="o">-</span> <span class="n">o2_num</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">compareHead</span><span class="o">;</span>
            <span class="o">}</span>
            
        <span class="o">});</span>

        <span class="k">return</span> <span class="n">files</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span><span class="o">[]</span> <span class="nf">separate</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>

        <span class="nc">String</span> <span class="n">head</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">number</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">tail</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>

        <span class="c1">// 하나의 인덱스를 통해 head를 먼저 갱신하고 숫자부터 number를 갱신한다. 이후는 tail에 갱신한다.</span>
        <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        
        <span class="c1">// 숫자가 나올때까지 head 갱신</span>
        <span class="k">for</span><span class="o">(;</span> <span class="n">idx</span><span class="o">&lt;</span><span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">idx</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">idx</span><span class="o">);</span>
            <span class="k">if</span><span class="o">((</span><span class="sc">'0'</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="sc">'9'</span><span class="o">))</span> <span class="k">break</span><span class="o">;</span>
            <span class="n">head</span> <span class="o">+=</span> <span class="n">c</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 숫자부터 number 갱신</span>
        <span class="k">for</span><span class="o">(;</span> <span class="n">idx</span><span class="o">&lt;</span><span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">idx</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">idx</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(!(</span><span class="sc">'0'</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="sc">'9'</span><span class="o">))</span> <span class="k">break</span><span class="o">;</span>
            <span class="n">number</span> <span class="o">+=</span> <span class="n">c</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 나머지 문자열 tail에 갱신</span>
        <span class="k">for</span><span class="o">(;</span> <span class="n">idx</span><span class="o">&lt;</span><span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">idx</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">idx</span><span class="o">);</span>
            <span class="n">tail</span> <span class="o">+=</span> <span class="n">c</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[]{</span><span class="n">head</span><span class="o">.</span><span class="na">toLowerCase</span><span class="o">(),</span> <span class="n">number</span><span class="o">,</span> <span class="n">tail</span><span class="o">};</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        
        <span class="c1">// String[] files = new String[]{"img12.png", </span>
        <span class="c1">//                                 "img10.png", </span>
        <span class="c1">//                                 "img02.png", </span>
        <span class="c1">//                                 "img1.png", </span>
        <span class="c1">//                                 "IMG01.GIF",</span>
        <span class="c1">//                                 "img2.JPG"};</span>

        <span class="nc">String</span><span class="o">[]</span> <span class="n">files</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[]{</span><span class="s">"F-5 Freedom Fighter"</span><span class="o">,</span> 
                                        <span class="s">"B-50 Superfortress"</span><span class="o">,</span> 
                                        <span class="s">"A-10 Thunderbolt II"</span><span class="o">,</span> 
                                        <span class="s">"F-14 Tomcat"</span><span class="o">};</span>

        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">files</span><span class="o">);</span>

    <span class="o">}</span>

<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<p>-
—</p>

<p><br /></p>

<h3 id="출처">출처</h3>
<p>-
—</p>

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://school.programmers.co.kr/learn/courses/30/lessons/17686">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 2 - 파일명 정렬]]></summary></entry><entry><title type="html">[Java] 백준(골드-4) 7662번 - 이중 우선순위 큐</title><link href="http://localhost:4000/java/246-post/" rel="alternate" type="text/html" title="[Java] 백준(골드-4) 7662번 - 이중 우선순위 큐" /><published>2023-08-08T00:00:00+09:00</published><updated>2023-08-08T00:00:00+09:00</updated><id>http://localhost:4000/java/246-post</id><content type="html" xml:base="http://localhost:4000/java/246-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 문제명인 <strong>이중 우선순위 큐를 이용하면 시간 초과가 발생</strong>하기에 <strong>TreeMap 자료구조</strong>를 이용해 풀어야 한다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>별 다른 생각없이 최소 힙, 최대 힙을 구현한 2개의 우선순위 큐를 이용하여 풀었지만, <strong>큐의 삭제 연산 remove() 메서드를 수행할 때 시간복잡도가 O(n)이기에 시간초과가 발생</strong>했다.</p>

<h4 id="최소-힙-최대-힙-우선순위-큐-2개를-이용한-풀이---시간초과-발생">최소 힙, 최대 힙 우선순위 큐 2개를 이용한 풀이 - 시간초과 발생</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="c1">// 1. 이중 우선순위 큐를 구현하기 위해 최소 힙, 최대 힙인 우선순위 큐 2개를 활용한다.</span>
        <span class="c1">// 2. I 명령이면 N을 삽입하고, D 1 명령이면 큐의 최댓값 제거, D -1 명령이면 큐의 최솟값을 제거한다.</span>
        <span class="c1">// 3. D 명령 수행시 큐가 비었다면 무시하고 진행한다.</span>
        <span class="c1">// 4. 큐에 저장되는 정수의 범위는 -2^31 부터 2^31까지 이기에 long형 타입을 사용해야 한다.</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
            
                <span class="kt">int</span> <span class="no">T</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

                <span class="k">while</span><span class="o">(</span><span class="no">T</span> <span class="o">--&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    
                    <span class="c1">// 최솟값을 기준으로 정렬할 최소 힙 우선순위 큐 선언</span>
                    <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">min_q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;();</span>
                    
                    <span class="c1">// 최댓값을 기준으로 정렬할 최대 힙 우선순위 큐 선언</span>
                    <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">max_q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;(</span><span class="k">new</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;()</span> <span class="o">{</span>
                        <span class="nd">@Override</span>
                        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="nc">Long</span> <span class="n">o1</span><span class="o">,</span> <span class="nc">Long</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
                            <span class="k">if</span><span class="o">(</span><span class="n">o1</span> <span class="o">&gt;</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
                                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                            <span class="o">}</span>
                            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">o1</span> <span class="o">&lt;</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
                                <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
                            <span class="o">}</span>
                            <span class="k">else</span> <span class="o">{</span>
                                <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
                            <span class="o">}</span>
                        <span class="o">}</span>
                    <span class="o">});</span>

                    <span class="kt">int</span> <span class="no">K</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                    
                    <span class="k">while</span><span class="o">(</span><span class="no">K</span> <span class="o">--&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        
                        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                        <span class="nc">String</span> <span class="n">cmd</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">();</span>
                        <span class="kt">long</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">parseLong</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

                        <span class="c1">// cmd == I</span>
                        <span class="k">if</span><span class="o">(</span><span class="n">cmd</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"I"</span><span class="o">))</span> <span class="o">{</span>
                            <span class="n">min_q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="no">N</span><span class="o">);</span>
                            <span class="n">max_q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="no">N</span><span class="o">);</span>
                        <span class="o">}</span> 
                        <span class="c1">// cmd == D</span>
                        <span class="k">else</span> <span class="o">{</span>
                            <span class="c1">// 최댓값 제거일 경우 최대 힙(max_q)에서만 제거</span>
                            <span class="k">if</span><span class="o">(</span><span class="no">N</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                                <span class="k">if</span><span class="o">(</span><span class="n">max_q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="k">continue</span><span class="o">;</span>
                                <span class="kt">long</span> <span class="n">target</span> <span class="o">=</span> <span class="n">max_q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                                <span class="n">min_q</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">target</span><span class="o">);</span>
                            <span class="o">}</span> 
                            <span class="c1">// 최솟값 제거일 경우 최소 힙(min_q)에서만 제거</span>
                            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="no">N</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                                <span class="k">if</span><span class="o">(</span><span class="n">min_q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="k">continue</span><span class="o">;</span>
                                <span class="kt">long</span> <span class="n">target</span> <span class="o">=</span> <span class="n">min_q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                                <span class="n">max_q</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">target</span><span class="o">);</span>
                            <span class="o">}</span>
                        <span class="o">}</span>

                    <span class="o">}</span>

                    <span class="cm">/**
                     * 큐가 비어있다면 "EMPTY"를 출력하고
                     * 비어있지 않다면, 최댓값과 최솟값을 공백을 두고 출력한다.
                     */</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">min_q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">max_q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"EMPTY"</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">max_q</span><span class="o">.</span><span class="na">peek</span><span class="o">()+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">min_q</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">+</span> <span class="s">"\n"</span><span class="o">);</span>
                    <span class="o">}</span>

                <span class="o">}</span>

        <span class="o">}</span>

    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><br /></p>

<p>이를 위해, 시간 초과가 발생하는 큐를 사용하는 것이 아니라 원소 추가 및 삭제에 <strong>O(logN)의 시간복잡도를 가지는 TreeMap</strong>를 이용하여 풀게 되었다. TreeMap을 활용해 풀 수 있는 아이디어를 다음과 같이 생각해보았다.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">I N</code> 명령일 경우, N을 TreeMap에 Key로, N의 빈도수(개수)를 Value로 삽입한다.</li>
  <li>D 명령일 경우 TreeMap이 비어있다면 D 연산을 무시하고 넘어간다.</li>
  <li><code class="language-plaintext highlighter-rouge">D 1</code> 명령일 경우, TreeMap의 마지막 값(<code class="language-plaintext highlighter-rouge">lastKey()</code>)을 제거한다.</li>
  <li><code class="language-plaintext highlighter-rouge">D -1</code> 명령일 경우, TreeMap의 첫번째 값(<code class="language-plaintext highlighter-rouge">firstKey()</code>)을 제거한다.</li>
</ol>

<blockquote>
  <p><strong>TreeMap 자료구조는 오름차순 정렬</strong>이 기본으로 설정되어있다. 또한, <strong>firstKey()</strong> 메서드와 <strong>lastKey()</strong> 메서드가 존재한다. firstKey() 메서드는 Map의 첫번째 키를, lastKey() 메서드는 Map의 마지막 키를 가져올 수 있다.</p>
</blockquote>

<p>결국, TreeMap의 두 메서드를 통해 이중 우선순위 큐에서 서로의 큐의 삭제연산을 할 때의 비용을 절감하여 시간 초과를 해결할 수 있었다.</p>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="c1">// 1. 이중 우선순위 큐를 구현하기 위해 최소 힙, 최대 힙인 우선순위 큐 2개를 활용한다.</span>
        <span class="c1">// 2. I 명령이면 N을 삽입하고, D 1 명령이면 큐의 최댓값 제거, D -1 명령이면 큐의 최솟값을 제거한다.</span>
        <span class="c1">// 3. D 명령 수행시 큐가 비었다면 무시하고 진행한다.</span>
        <span class="c1">// 4. 큐에 저장되는 정수의 범위는 -2^31 부터 2^31까지 이기에 long형 타입을 사용해야 한다.</span>
        <span class="c1">// 5. D 명령 수행시 큐 remove() 연산을 수행하게 되면 시간초과가 발생한다.</span>
        <span class="c1">// 6. 원소의 추가, 삭제 이후에 정렬 상태를 유지하는데 O(logN)의 시간복잡도를 가지는 TreeMap 자료구조를 이용해 풀어야 한다.</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
            
                <span class="kt">int</span> <span class="no">T</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

                <span class="k">while</span><span class="o">(</span><span class="no">T</span> <span class="o">--&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>

                    <span class="c1">// 최소힙과 최대힙의 원소와 개수를 담을 TreeMap 선언</span>
                    <span class="nc">TreeMap</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">tm</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeMap</span><span class="o">&lt;&gt;();</span>

                    <span class="kt">int</span> <span class="no">K</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                    
                    <span class="k">while</span><span class="o">(</span><span class="no">K</span> <span class="o">--&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        
                        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                        <span class="nc">String</span> <span class="n">cmd</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">();</span>
                        <span class="kt">long</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">parseLong</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

                        <span class="c1">// cmd == I</span>
                        <span class="k">if</span><span class="o">(</span><span class="n">cmd</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"I"</span><span class="o">))</span> <span class="o">{</span>
                            <span class="n">tm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="no">N</span><span class="o">,</span> <span class="n">tm</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="no">N</span><span class="o">,</span> <span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
                        <span class="o">}</span> 
                        <span class="c1">// cmd == D</span>
                        <span class="k">else</span> <span class="o">{</span>
                            
                            <span class="c1">// TreeMap이 비어있다면 D 연산은 무시한다.</span>
                            <span class="k">if</span><span class="o">(</span><span class="n">tm</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="k">continue</span><span class="o">;</span>
                            
                            <span class="c1">// 최댓값 제거</span>
                            <span class="k">if</span><span class="o">(</span><span class="no">N</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>

                                <span class="c1">// 최댓값 key</span>
                                <span class="kt">long</span> <span class="n">last</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="na">lastKey</span><span class="o">();</span>
                                
                                <span class="c1">// 1개밖에 없다면 Map에서 제거</span>
                                <span class="k">if</span><span class="o">(</span><span class="n">tm</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">last</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                                    <span class="n">tm</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">last</span><span class="o">);</span>
                                    <span class="k">continue</span><span class="o">;</span>
                                <span class="o">}</span>
                                
                                <span class="c1">// 2개 이상이라면 개수 1개 차감</span>
                                <span class="n">tm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">last</span><span class="o">,</span> <span class="n">tm</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">last</span><span class="o">)-</span><span class="mi">1</span><span class="o">);</span>

                            <span class="o">}</span> 
                            <span class="c1">// 최솟값 제거</span>
                            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="no">N</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                                
                                <span class="c1">// 최솟값 key</span>
                                <span class="kt">long</span> <span class="n">first</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="na">firstKey</span><span class="o">();</span>
                                
                                <span class="c1">// 1개밖에 없다면 Map에서 제거</span>
                                <span class="k">if</span><span class="o">(</span><span class="n">tm</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">first</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                                    <span class="n">tm</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">first</span><span class="o">);</span>
                                    <span class="k">continue</span><span class="o">;</span>
                                <span class="o">}</span>

                                <span class="c1">// 2개 이상이라면 개수 1개 차감</span>
                                <span class="n">tm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">first</span><span class="o">,</span> <span class="n">tm</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">first</span><span class="o">)-</span><span class="mi">1</span><span class="o">);</span>


                            <span class="o">}</span>
                        <span class="o">}</span>

                    <span class="o">}</span>

                    <span class="cm">/**
                     * 큐가 비어있다면 "EMPTY"를 출력하고
                     * 비어있지 않다면, 최댓값과 최솟값을 공백을 두고 출력한다.
                     */</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">tm</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"EMPTY"</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">tm</span><span class="o">.</span><span class="na">lastKey</span><span class="o">()+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">tm</span><span class="o">.</span><span class="na">firstKey</span><span class="o">()</span> <span class="o">+</span> <span class="s">"\n"</span><span class="o">);</span>
                    <span class="o">}</span>

                <span class="o">}</span>
                
        <span class="o">}</span>

    <span class="o">}</span>


<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/7662">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[7662번 - 이중 우선순위 큐]]></summary></entry><entry><title type="html">[Java] 백준(실버-2) 21736번 - 헌내기는 친구가 필요해</title><link href="http://localhost:4000/java/244-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-2) 21736번 - 헌내기는 친구가 필요해" /><published>2023-08-07T00:00:00+09:00</published><updated>2023-08-07T00:00:00+09:00</updated><id>http://localhost:4000/java/244-post</id><content type="html" xml:base="http://localhost:4000/java/244-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 <strong>너비 우선 탐색 BFS</strong>를 이용해 간단하게 풀 수 있다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>너비 우선 탐색인 BFS를 잘 숙지하고 있다면 쉽게 도연이가 사람들과 만난 횟수를 구할 수 있을 것이다.</p>

<p>문제풀이를 위한 아이디어는 다음과 같다.</p>

<ol>
  <li>지도를 입력받고 BFS 탐색을 수행한다.</li>
  <li>BFS로 탐색하면서 벽(X)이 아닌 빈공간(0)과 사람(P)일 경우만 상,하,좌,우 탐색을 이어나간다.</li>
  <li>사람(P)을 만날 경우 만난 횟수를 1 증가시킨다.</li>
  <li>BFS 탐색 종료후, 만난 룃수가 1 이상이라면 만난 횟수를, 사람을 만나지 못했다면 “TT”를 출력한다.</li>
</ol>

<p>유의할 점은 다음과 같다.</p>
<blockquote>
  <p>지도의 (0,0) 위치부터 탐색을 하는 것이 아니라, <strong>도연이의 위치부터 탐색을 시작</strong>해야 벽을 고려하여 사람들과의 만난 횟수를 구할 수 있다.</p>
</blockquote>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dx</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>

    <span class="kd">static</span> <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">visited</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">char</span><span class="o">[][]</span> <span class="n">map</span><span class="o">;</span>

    <span class="kd">static</span> <span class="kt">int</span> <span class="no">N</span><span class="o">,</span> <span class="no">M</span><span class="o">;</span>

    <span class="kd">static</span> <span class="kt">int</span> <span class="n">result</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
            
            <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

            <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
            <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

            <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">M</span><span class="o">];</span>
            <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">M</span><span class="o">];</span>

            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="nc">String</span> <span class="n">input</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="no">M</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
                    <span class="c1">// 도연이의 위치를 x와 y에 담는다.</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'I'</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                        <span class="n">y</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>  
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
            
            <span class="c1">// 만난 횟수를 담을 변수 초기화</span>
            <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

            <span class="c1">// 도연이의 위치부터 BFS를 수행한다.</span>
            <span class="no">BFS</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
            
            <span class="c1">// 만난 횟수가 1번 이상이라면 횟수를, 아니라면 "TT"를 출력한다.</span>
            <span class="k">if</span><span class="o">(</span><span class="n">result</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"TT"</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
            <span class="o">}</span>
            
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="cm">/**
     * BFS 탐색 함수
     * 벽(X)아닌 위치로 상,하,좌,우 탐색을 한다.
     * 탐색 중, 사람(P)의 위치일 경우 result를 1 증가시킨다.
     */</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">BFS</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">});</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">now</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">dir</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">dir</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">;</span> <span class="n">dir</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">now</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">dx</span><span class="o">[</span><span class="n">dir</span><span class="o">];</span>
                <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">now</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">dy</span><span class="o">[</span><span class="n">dir</span><span class="o">];</span>
                <span class="k">if</span><span class="o">(</span><span class="n">isRange</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="sc">'X'</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'P'</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">result</span><span class="o">++;</span>
                        <span class="o">}</span>
                        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">});</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isRange</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">&lt;</span><span class="no">N</span> <span class="o">&amp;&amp;</span> <span class="n">y</span><span class="o">&lt;</span><span class="no">M</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/21736">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[21736번 - 헌내기는 친구가 필요해]]></summary></entry><entry><title type="html">[Java] 백준(실버-3) 17626번 - Four Squares</title><link href="http://localhost:4000/java/243-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-3) 17626번 - Four Squares" /><published>2023-08-07T00:00:00+09:00</published><updated>2023-08-07T00:00:00+09:00</updated><id>http://localhost:4000/java/243-post</id><content type="html" xml:base="http://localhost:4000/java/243-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 얼핏 보면 그리디 알고리즘과 헷갈리지만, <strong>동적계획법 DP</strong>를 이용해 풀어야 한다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>처음엔 무작정 제곱수가 큰 것부터 접근해나가려 했지만 N=12일 경우 <code class="language-plaintext highlighter-rouge">2^2 + 2^2 + 2^2</code>의 경우도 고려해야 하기 때문에 그리디 알고리즘이 아닌 DP로 풀어야 함을 알게 되었다.</p>

<p>DP를 이용해 부분 문제를 구해주면, 결국 최적해를 구할 수 있게 된다.</p>

<p>어떻게 최적해인 N을 만들기 위한 최소 제곱수의 개수를 구할 수 있을까? 1부터 9까지 최소 제곱수의 개수를 한번 나열하고 살펴보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="mi">1</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="n">개</span>
<span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="n">개</span>
<span class="mi">3</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="n">개</span>
<span class="mi">4</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">^</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="n">개</span>
<span class="mi">5</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="n">개</span>
<span class="mi">6</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="n">개</span>
<span class="mi">7</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">4</span><span class="n">개</span>
<span class="mi">8</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">^</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="n">개</span>
<span class="mi">9</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="o">^</span><span class="mi">3</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="n">개</span>
<span class="o">...</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>위처럼 1부터 9까지 살펴보면, N을 만들 수 있는 최소 제곱수의 개수의 패턴을 도출할 수 있다. <strong>N보다 작은 제곱수들 중에서 가장 작은 값을 가지는 D[N-제곱수] 값에 1을 더해</strong>주면 된다.</p>

<p>즉 이를 통해 도출한 점화식은 다음과 같다.</p>

<blockquote>
  <p>점화식: <code class="language-plaintext highlighter-rouge">D[i] = min(D[i-j*j])+1</code></p>
</blockquote>

<p>그러면 문제풀이를 위한 아이디어를 그려보자.</p>

<ol>
  <li>DP 테이블에 D[0]을 0으로, D[1]을 1인 초기값으로 설정한다.</li>
  <li>D[2]부터 D[N]까지 DP 테이블의 값을 채우기 위해 2부터 N까지 순회하며, 각 <strong>순회(이중for문)마다 최소가 되는 <code class="language-plaintext highlighter-rouge">D[i-j*j]</code>의 값을 D[i]번째에 채운다.</strong></li>
  <li>완전 탐색 종료 후 D[N]번째 값을 출력한다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// DP 테이블 선언</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="no">D</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>

            <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

            <span class="c1">// DP 테이블 초기화</span>
            <span class="no">D</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>

            <span class="c1">// 초기값 설정</span>
            <span class="no">D</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="no">D</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

            <span class="c1">// DP 함수 실행</span>
            <span class="no">DP</span><span class="o">(</span><span class="no">N</span><span class="o">);</span>
            
            <span class="c1">// DP 테이블의 N번째 값 출력</span>
            <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">]+</span><span class="s">"\n"</span><span class="o">);</span>
            
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="cm">/**
     * DP 함수
     * 점화식: D[i] = min(D[i-j*j])+1
     */</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">DP</span><span class="o">(</span><span class="kt">int</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="c1">// 2부터 N까지 완전탐색으로 순회한다.</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            
            <span class="c1">// 최솟값을 비교하기 위한 변수</span>
            <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
            
            <span class="c1">// 1. i보다 작은 제곱수를 뺄셈한 DP 테이블의 값 중 최솟값을 구한다.</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">*</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">min</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">min</span><span class="o">,</span> <span class="no">D</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span> <span class="o">*</span> <span class="n">j</span><span class="o">]);</span>  
            <span class="o">}</span>
            
            <span class="c1">// 2. D[i]에 1을 더해준다.</span>
            <span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">min</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

        <span class="o">}</span>

    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/17626">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[17626번 - Four Squares]]></summary></entry></feed>