<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-08-11T16:03:21+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">lango’s DevLog</title><subtitle>developer</subtitle><author><name>lango</name></author><entry><title type="html">[Java] 백준(실버-3) 15651번 - N과 M (3)</title><link href="http://localhost:4000/java/249-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-3) 15651번 - N과 M (3)" /><published>2023-08-11T00:00:00+09:00</published><updated>2023-08-11T00:00:00+09:00</updated><id>http://localhost:4000/java/249-post</id><content type="html" xml:base="http://localhost:4000/java/249-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 유사한 유형인 <a href="https://langoustinee.github.io/java/193-post/">N과 M (1)</a> 문제처럼 <strong>백트래킹</strong>을 이용해 풀 수 있다. 사실 저 문제보다 더 쉽게 풀 수 있다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>1~N까지 길이가 M인 수열을 선택해야 한다는 조건은 N과 M (1) 문제와 동일하다. 그런데, 이번 문제에서는 <strong>수열의 중복 여부가 허용</strong>되기 때문에 더 쉽다고 볼 수 있다.</p>

<p>문제 풀이를 위한 아이디어는 다음과 같다.</p>

<ol>
  <li>DFS 재귀함수를 통해 1부터 N까지 탐색한다.</li>
  <li>수열의 길이(재귀함수의 깊이)가 M이 된다면 배열에 담아둔 수열을 저장하고 종료한다.</li>
</ol>

<blockquote>
  <p>이번 문제에서도 결과로 출력할 수열을 <strong>StringBuilder</strong>에 담아서 출력하도록 하였다.</p>
</blockquote>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// 1. 1~N까지 길이가 M인 수열을 선택해야 한다.</span>
    <span class="c1">// 2. 수열 중복이 가능하다. 그렇기에 방문 배열이 필요없다.</span>

    <span class="c1">// 수열 배열 선언</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">;</span>

    <span class="c1">// 입력 N, M 선언</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="no">N</span><span class="o">,</span> <span class="no">M</span><span class="o">;</span>

    <span class="c1">// 출력할 수열을 담을 StringBuilder 선언</span>
    <span class="kd">static</span> <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
            
                <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                
                <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">M</span><span class="o">];</span>

                <span class="n">dfs</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>

                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">sb</span> <span class="o">+</span> <span class="s">"\n"</span><span class="o">);</span>
                
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="cm">/**
     * 백트래킹 DFS 재귀함수
     * 
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">depth</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// 재귀 인덱스가 마지막 위치인 M이 된다면 수열을 sb에 담은 후 종료</span>
        <span class="k">if</span><span class="o">(</span><span class="n">depth</span> <span class="o">==</span> <span class="no">M</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">M</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]).</span><span class="na">append</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"\n"</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="cm">/**
         * 1부터 N까지 깊이를 1씩 증가시키며 DFS를 재귀호출한다.
         * arr 배열에 M 길이만큼의 조합을 담아나간다.
         */</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">depth</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/15651">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[15651번 - N과 M (3)]]></summary></entry><entry><title type="html">[Java] 백준(실버-3) 15652번 - N과 M (4)</title><link href="http://localhost:4000/java/250-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-3) 15652번 - N과 M (4)" /><published>2023-08-11T00:00:00+09:00</published><updated>2023-08-11T00:00:00+09:00</updated><id>http://localhost:4000/java/250-post</id><content type="html" xml:base="http://localhost:4000/java/250-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 유사한 유형인 <a href="https://langoustinee.github.io/java/194-post/">N과 M (2)</a> 문제처럼 <strong>백트래킹</strong>을 이용해 풀 수 있다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>오름차순 수열을 유지해야 하는 N과 M (2) 문제와 유사해보이지만, 이번 문제에서는 <strong>비내림차순으로 중복 여부가 허용</strong>됨을 고려해야 한다.</p>

<p>재귀함수를 어떻게 짜야 할까?</p>

<p>여기서도 깊이를 의미하는 depth와 함께 현재 위치를 의미하는 at을 함께 사용해야 한다. <strong>비내림차순으로 중복 여부가 허용</strong>되기에 1부터 N까지 탐색하며 다음 재귀를 호출할 때 <strong>i값을 at으로 넘겨 재귀호출</strong>하면 된다.</p>

<blockquote>
  <p>N과 M (2) 문제처럼 오름차순으로 수열을 담기 위해 i+1 값을 at으로 넘겨주는 것이 아니라, <strong>비내림차순으로 현재 위츼 i값도 허용</strong>되기에 i+1값이 아닌 i값을 at으로 넘겨준다.</p>
</blockquote>

<p>문제 풀이를 위한 아이디어는 다음과 같다.</p>

<ol>
  <li>DFS 재귀함수를 통해 1부터 N까지 탐색한다.</li>
  <li>탐색하며 재귀 호출할 때 현재 위치를 의히마는 at 변수와 깊이인 depth 변수 2가지를 인자로 호출한다.</li>
  <li>비내림차순의 수열을 유지하기 위해 중복이 허용되도록 <strong>1 ~ N까지 탐색할 때, at 변수를 현재 위치 i값으로 다음 재귀를 호출</strong>하며 수열을 갱신한다.</li>
  <li>수열의 길이(재귀함수의 깊이)가 M이 된다면 배열에 담아둔 수열을 저장하고 종료한다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// 1. 1~N까지 길이가 M인 수열을 선택해야 한다.</span>
    <span class="c1">// 2. 선택한 수열은 비내림차순이어야 한다. (비내림차순 != 오름차순)</span>
    <span class="c1">// 3. 중복 여부를 고려하지 않으므로 중복이 허용된다.</span>

    <span class="c1">// 수열 배열 선언</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">;</span>

    <span class="c1">// 입력 N, M 선언</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="no">N</span><span class="o">,</span> <span class="no">M</span><span class="o">;</span>

    <span class="c1">// 출력할 수열을 담을 StringBuilder 선언</span>
    <span class="kd">static</span> <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
            
                <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                
                <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                
                <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">M</span><span class="o">];</span>

                <span class="n">dfs</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>

                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">sb</span> <span class="o">+</span> <span class="s">"\n"</span><span class="o">);</span>
                
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="cm">/**
     * 백트래킹 DFS 재귀함수
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">at</span><span class="o">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// 재귀 인덱스가 마지막 위치인 M이 된다면 수열을 sb에 담은 후 종료</span>
        <span class="k">if</span><span class="o">(</span><span class="n">depth</span> <span class="o">==</span> <span class="no">M</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">M</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]).</span><span class="na">append</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"\n"</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="cm">/**
         * 1부터 N까지 깊이를 1씩 증가시키며 DFS를 재귀호출한다.
         * arr 배열에 M 길이만큼의 조합을 담아나간다.
         * 오름차순과는 다르게 비내림차순으로 중복이 허용되기에 동일한 i값을 at으로 넘겨준다.
         */</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">at</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">depth</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/15652">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[15652번 - N과 M (4)]]></summary></entry><entry><title type="html">[Java] 백준(실버-1) 6064번 - 카잉 달력</title><link href="http://localhost:4000/java/248-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-1) 6064번 - 카잉 달력" /><published>2023-08-10T00:00:00+09:00</published><updated>2023-08-10T00:00:00+09:00</updated><id>http://localhost:4000/java/248-post</id><content type="html" xml:base="http://localhost:4000/java/248-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 문제의 요구사항을 통해 두 수의 관계를 고려하여 나머지 연산을 활용해 풀어야 한다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>문제 요구사항을 다시 살펴보자.</p>

<blockquote>
  <p>만일 x &lt; M 이면 x’ = x + 1이고, 그렇지 않으면 x’ = 1이다. 같은 방식으로 만일 y &lt; N이면 y’ = y + 1이고, 그렇지 않으면 y’ = 1이다.</p>
</blockquote>

<p>그렇다면 예를 들어보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="c1">// &lt;M, N&gt;이 &lt;10, 12&gt;일 때</span>
<span class="mi">1</span><span class="n">번째</span> <span class="n">해</span> <span class="o">:</span> <span class="o">&lt;</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">&gt;</span>
<span class="mi">2</span><span class="n">번째</span> <span class="n">해</span> <span class="o">:</span> <span class="o">&lt;</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">&gt;</span>
<span class="o">...</span>
<span class="mi">10</span><span class="n">번째</span> <span class="n">해</span> <span class="o">:</span> <span class="o">&lt;</span><span class="mi">10</span><span class="o">,</span> <span class="mi">10</span><span class="o">&gt;</span>
<span class="mi">11</span><span class="n">번째</span> <span class="n">해</span> <span class="o">:</span> <span class="o">&lt;</span><span class="mi">1</span><span class="o">,</span> <span class="mi">11</span><span class="o">&gt;</span>
<span class="mi">12</span><span class="n">번째</span> <span class="n">해</span> <span class="o">:</span> <span class="o">&lt;</span><span class="mi">2</span><span class="o">,</span> <span class="mi">12</span><span class="o">&gt;</span>
<span class="mi">13</span><span class="n">번째</span> <span class="n">해</span> <span class="o">:</span> <span class="o">&lt;</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">&gt;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>위처럼 x가 M, y가 N에 도달하는 순간 1로 변경된다.</p>

<blockquote>
  <p>여기서 완전탐색을 통해 하나씩 모두 계산할 경우 O(nm)의 시간복잡도를 가지기에 시간초과가 발생할 수 있다.</p>
</blockquote>

<p>문제를 풀기 위한 아이디어는 바로 <strong>나머지 연산</strong>에 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="c1">// &lt;10, 12&gt;</span>
<span class="mi">1</span><span class="n">번째</span> <span class="n">해</span> <span class="o">:</span> <span class="o">&lt;</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">&gt;</span>
<span class="mi">2</span><span class="n">번째</span> <span class="n">해</span> <span class="o">:</span> <span class="o">&lt;</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">&gt;</span>
<span class="mi">3</span><span class="n">번째</span> <span class="n">해</span> <span class="o">:</span> <span class="o">&lt;</span><span class="mi">3</span><span class="o">,</span> <span class="mi">3</span><span class="o">&gt;</span>
<span class="o">...</span>
<span class="mi">13</span><span class="n">번째</span> <span class="n">해</span> <span class="o">:</span> <span class="o">&lt;</span><span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">&gt;</span>
<span class="o">...</span>
<span class="mi">23</span><span class="n">번째</span> <span class="n">해</span> <span class="o">:</span> <span class="o">&lt;</span><span class="mi">3</span><span class="o">,</span> <span class="mi">11</span><span class="o">&gt;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>3, 13, 23번째를 보면 M의 배수에서 3만큼 더한 값을 넘어야 3이 나오게 된다. 시간초과를 고려해 모든 경우를 다 구하며 계산할 순 없기 때문에, <strong>x값을 기준으로 y값을 함께 N으로 나눈 나머지가 y가 나오는지 확인</strong>하면 된다.</p>

<p>결국, 구할 수 있는 최대 범위는 M과 N의 최소공배수인데 이를 초과하는 경우는 표현될 수 있는 해가 없다는 것이기에 -1로 만들면 된다.</p>

<p>문제 풀이를 위한 아이디어는 다음과 같다.</p>

<ol>
  <li>M과 N의 최소공배수를 구하여 최소공배수까지 순회한다.</li>
  <li>순회하며 x값을 기준으로 y값도 N으로 나눈 나머지가 y가 된다면 해를 출력한다.</li>
  <li>순회하며 2번 기준이 충족되지 않는다면 구할 수 없는 해이기에 -1을 출력한다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
            
                <span class="kt">int</span> <span class="no">T</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

                <span class="k">while</span><span class="o">(</span><span class="no">T</span> <span class="o">--&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>

                    <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                    <span class="kt">int</span> <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

                    <span class="c1">// 최소 공배수 구해오기</span>
                    <span class="kt">int</span> <span class="n">lcm</span> <span class="o">=</span> <span class="no">LCM</span><span class="o">(</span><span class="no">M</span><span class="o">,</span> <span class="no">N</span><span class="o">);</span>

                    <span class="c1">// while 조건을 충족하지 않아 구할 수 없는 해라면 -1을 출력하기 위해 -1로 초기화한다.</span>
                    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>

                    <span class="c1">// 최소공배수의 범위를 벗어나면 구할 수 없는 해이다.</span>
                    <span class="c1">// x값과 y값을 N으로 나눈 나머지가 y인지 확인하여 해를 구한다.</span>
                    <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="k">while</span><span class="o">((</span><span class="n">cnt</span> <span class="o">*</span> <span class="no">M</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">lcm</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">if</span><span class="o">(((</span><span class="n">cnt</span> <span class="o">*</span> <span class="no">M</span><span class="o">)</span> <span class="o">+</span> <span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="o">)</span> <span class="o">%</span> <span class="no">N</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="n">cnt</span> <span class="o">*</span> <span class="no">M</span><span class="o">)</span> <span class="o">+</span> <span class="n">x</span><span class="o">;</span>
                            <span class="k">break</span><span class="o">;</span>
                        <span class="o">}</span>
                        <span class="n">cnt</span><span class="o">++;</span>
                    <span class="o">}</span>

                    <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>

                <span class="o">}</span>
                
                
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="c1">// 최소 공배수</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">LCM</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">/</span> <span class="no">GCD</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 최대 공약수</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">GCD</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">while</span><span class="o">(</span><span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">x</span> <span class="o">%</span> <span class="n">y</span><span class="o">;</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">r</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/6064">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[6064번 - 카잉 달력]]></summary></entry><entry><title type="html">[Java] 프로그래머스(level-2) - 파일명 정렬</title><link href="http://localhost:4000/java/247-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-2) - 파일명 정렬" /><published>2023-08-09T00:00:00+09:00</published><updated>2023-08-09T00:00:00+09:00</updated><id>http://localhost:4000/java/247-post</id><content type="html" xml:base="http://localhost:4000/java/247-post/"><![CDATA[<p><br /></p>

<center><img src="/assets/images/programmers/" width="100%" /></center>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />

<p>이번 문제는 주어진 배열을 조건별로 <strong>정렬</strong>하여 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>문제에서 요구하는 정렬 기준에 따라서 정렬을 해야한다. 
필자는 Java를 이용해 풀기 때문에 <code class="language-plaintext highlighter-rouge">Comparator</code>의 <code class="language-plaintext highlighter-rouge">compare()</code> 메서드를 재정의하여 커스텀 정렬을 구현하였다.</p>

<p>문제 풀이를 위한 아이디어는 다음과 같다.</p>

<ol>
  <li>files 배열을 정렬하는 데, 파일명 별로 HEAD, NUMBER, TAIL를 분리한다.</li>
  <li>HEAD의 경우 대소문자 구분을 하지 않기에 대문자든, 소문자든 통일시킨다.</li>
  <li>HEAD와 NUMBER가 모두 같다면, <strong>HEAD를 기준으로 사전 순 정렬하여 입력 순서를 보장</strong>하도록 한다.</li>
  <li>HEAD만 같다면, <strong>NUMBER를 int형으로 비교하여 오름차순으로 정렬</strong>한다.</li>
</ol>

<p><br /></p>

<p>다음으로 문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
</pre></td><td class="rouge-code"><pre>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>


    <span class="kd">public</span> <span class="nc">String</span><span class="o">[]</span> <span class="nf">solution</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">files</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// 1. HEAD: 사전 순 정렬, 대소문자 구분 X</span>
        <span class="c1">// 2. NUMBER: 숫자 순 정렬, 숫자 앞 0 무시</span>
        <span class="c1">// 3. HEAD와 NUMBER가 같다면 입력 순서 유지</span>

        <span class="nc">Arrays</span><span class="o">.</span><span class="na">sort</span><span class="o">(</span><span class="n">files</span><span class="o">,</span> <span class="o">(</span><span class="n">o1</span><span class="o">,</span> <span class="n">o2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
            
            <span class="nc">String</span><span class="o">[]</span> <span class="n">o1_sep</span> <span class="o">=</span> <span class="n">separate</span><span class="o">(</span><span class="n">o1</span><span class="o">);</span>
            <span class="nc">String</span><span class="o">[]</span> <span class="n">o2_sep</span> <span class="o">=</span> <span class="n">separate</span><span class="o">(</span><span class="n">o2</span><span class="o">);</span>

            <span class="cm">/*
             * HEAD를 기준으로 사전 순 정렬을 한다.
             * 두 문자의 head가 같다면 0
             * o1의 head가 크면 양수
             * o2가 크면 음수
             */</span>
            <span class="kt">int</span> <span class="n">compareHead</span> <span class="o">=</span> <span class="n">o1_sep</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">compareTo</span><span class="o">(</span><span class="n">o2_sep</span><span class="o">[</span><span class="mi">0</span><span class="o">]);</span>
            
            <span class="cm">/*
             * HEAD가 같다면 NUMBER를 기준으로 오름차순 정렬한다.
             * NUMBER도 같다면 0을 반환하여 입력 순서를 보장한다.
             * 
             * 두 수의 HEAD가 다르다면, HEAD를 기준으로 정렬한다.
             */</span>
            <span class="k">if</span><span class="o">(</span><span class="n">compareHead</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">o1_num</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">o1_sep</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
                <span class="kt">int</span> <span class="n">o2_num</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">o2_sep</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
                <span class="k">return</span> <span class="n">o1_num</span> <span class="o">-</span> <span class="n">o2_num</span><span class="o">;</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">compareHead</span><span class="o">;</span>
            <span class="o">}</span>
            
        <span class="o">});</span>

        <span class="k">return</span> <span class="n">files</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span><span class="o">[]</span> <span class="nf">separate</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">)</span> <span class="o">{</span>

        <span class="nc">String</span> <span class="n">head</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">number</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">tail</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>

        <span class="c1">// 하나의 인덱스를 통해 head를 먼저 갱신하고 숫자부터 number를 갱신한다. 이후는 tail에 갱신한다.</span>
        <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        
        <span class="c1">// 숫자가 나올때까지 head 갱신</span>
        <span class="k">for</span><span class="o">(;</span> <span class="n">idx</span><span class="o">&lt;</span><span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">idx</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">idx</span><span class="o">);</span>
            <span class="k">if</span><span class="o">((</span><span class="sc">'0'</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="sc">'9'</span><span class="o">))</span> <span class="k">break</span><span class="o">;</span>
            <span class="n">head</span> <span class="o">+=</span> <span class="n">c</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 숫자부터 number 갱신</span>
        <span class="k">for</span><span class="o">(;</span> <span class="n">idx</span><span class="o">&lt;</span><span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">idx</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">idx</span><span class="o">);</span>
            <span class="k">if</span><span class="o">(!(</span><span class="sc">'0'</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="sc">'9'</span><span class="o">))</span> <span class="k">break</span><span class="o">;</span>
            <span class="n">number</span> <span class="o">+=</span> <span class="n">c</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 나머지 문자열 tail에 갱신</span>
        <span class="k">for</span><span class="o">(;</span> <span class="n">idx</span><span class="o">&lt;</span><span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">();</span> <span class="n">idx</span><span class="o">++)</span> <span class="o">{</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">idx</span><span class="o">);</span>
            <span class="n">tail</span> <span class="o">+=</span> <span class="n">c</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[]{</span><span class="n">head</span><span class="o">.</span><span class="na">toLowerCase</span><span class="o">(),</span> <span class="n">number</span><span class="o">,</span> <span class="n">tail</span><span class="o">};</span>
    <span class="o">}</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        
        <span class="c1">// String[] files = new String[]{"img12.png", </span>
        <span class="c1">//                                 "img10.png", </span>
        <span class="c1">//                                 "img02.png", </span>
        <span class="c1">//                                 "img1.png", </span>
        <span class="c1">//                                 "IMG01.GIF",</span>
        <span class="c1">//                                 "img2.JPG"};</span>

        <span class="nc">String</span><span class="o">[]</span> <span class="n">files</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[]{</span><span class="s">"F-5 Freedom Fighter"</span><span class="o">,</span> 
                                        <span class="s">"B-50 Superfortress"</span><span class="o">,</span> 
                                        <span class="s">"A-10 Thunderbolt II"</span><span class="o">,</span> 
                                        <span class="s">"F-14 Tomcat"</span><span class="o">};</span>

        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">files</span><span class="o">);</span>

    <span class="o">}</span>

<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<p>-
—</p>

<p><br /></p>

<h3 id="출처">출처</h3>
<p>-
—</p>

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://school.programmers.co.kr/learn/courses/30/lessons/17686">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 2 - 파일명 정렬]]></summary></entry><entry><title type="html">[Java] 백준(골드-4) 7662번 - 이중 우선순위 큐</title><link href="http://localhost:4000/java/246-post/" rel="alternate" type="text/html" title="[Java] 백준(골드-4) 7662번 - 이중 우선순위 큐" /><published>2023-08-08T00:00:00+09:00</published><updated>2023-08-08T00:00:00+09:00</updated><id>http://localhost:4000/java/246-post</id><content type="html" xml:base="http://localhost:4000/java/246-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 문제명인 <strong>이중 우선순위 큐를 이용하면 시간 초과가 발생</strong>하기에 <strong>TreeMap 자료구조</strong>를 이용해 풀어야 한다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>별 다른 생각없이 최소 힙, 최대 힙을 구현한 2개의 우선순위 큐를 이용하여 풀었지만, <strong>큐의 삭제 연산 remove() 메서드를 수행할 때 시간복잡도가 O(n)이기에 시간초과가 발생</strong>했다.</p>

<h4 id="최소-힙-최대-힙-우선순위-큐-2개를-이용한-풀이---시간초과-발생">최소 힙, 최대 힙 우선순위 큐 2개를 이용한 풀이 - 시간초과 발생</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="c1">// 1. 이중 우선순위 큐를 구현하기 위해 최소 힙, 최대 힙인 우선순위 큐 2개를 활용한다.</span>
        <span class="c1">// 2. I 명령이면 N을 삽입하고, D 1 명령이면 큐의 최댓값 제거, D -1 명령이면 큐의 최솟값을 제거한다.</span>
        <span class="c1">// 3. D 명령 수행시 큐가 비었다면 무시하고 진행한다.</span>
        <span class="c1">// 4. 큐에 저장되는 정수의 범위는 -2^31 부터 2^31까지 이기에 long형 타입을 사용해야 한다.</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
            
                <span class="kt">int</span> <span class="no">T</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

                <span class="k">while</span><span class="o">(</span><span class="no">T</span> <span class="o">--&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    
                    <span class="c1">// 최솟값을 기준으로 정렬할 최소 힙 우선순위 큐 선언</span>
                    <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">min_q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;();</span>
                    
                    <span class="c1">// 최댓값을 기준으로 정렬할 최대 힙 우선순위 큐 선언</span>
                    <span class="nc">PriorityQueue</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="n">max_q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">PriorityQueue</span><span class="o">&lt;&gt;(</span><span class="k">new</span> <span class="nc">Comparator</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;()</span> <span class="o">{</span>
                        <span class="nd">@Override</span>
                        <span class="kd">public</span> <span class="kt">int</span> <span class="nf">compare</span><span class="o">(</span><span class="nc">Long</span> <span class="n">o1</span><span class="o">,</span> <span class="nc">Long</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
                            <span class="k">if</span><span class="o">(</span><span class="n">o1</span> <span class="o">&gt;</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
                                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
                            <span class="o">}</span>
                            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">o1</span> <span class="o">&lt;</span> <span class="n">o2</span><span class="o">)</span> <span class="o">{</span>
                                <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
                            <span class="o">}</span>
                            <span class="k">else</span> <span class="o">{</span>
                                <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
                            <span class="o">}</span>
                        <span class="o">}</span>
                    <span class="o">});</span>

                    <span class="kt">int</span> <span class="no">K</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                    
                    <span class="k">while</span><span class="o">(</span><span class="no">K</span> <span class="o">--&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        
                        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                        <span class="nc">String</span> <span class="n">cmd</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">();</span>
                        <span class="kt">long</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">parseLong</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

                        <span class="c1">// cmd == I</span>
                        <span class="k">if</span><span class="o">(</span><span class="n">cmd</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"I"</span><span class="o">))</span> <span class="o">{</span>
                            <span class="n">min_q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="no">N</span><span class="o">);</span>
                            <span class="n">max_q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="no">N</span><span class="o">);</span>
                        <span class="o">}</span> 
                        <span class="c1">// cmd == D</span>
                        <span class="k">else</span> <span class="o">{</span>
                            <span class="c1">// 최댓값 제거일 경우 최대 힙(max_q)에서만 제거</span>
                            <span class="k">if</span><span class="o">(</span><span class="no">N</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                                <span class="k">if</span><span class="o">(</span><span class="n">max_q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="k">continue</span><span class="o">;</span>
                                <span class="kt">long</span> <span class="n">target</span> <span class="o">=</span> <span class="n">max_q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                                <span class="n">min_q</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">target</span><span class="o">);</span>
                            <span class="o">}</span> 
                            <span class="c1">// 최솟값 제거일 경우 최소 힙(min_q)에서만 제거</span>
                            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="no">N</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                                <span class="k">if</span><span class="o">(</span><span class="n">min_q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="k">continue</span><span class="o">;</span>
                                <span class="kt">long</span> <span class="n">target</span> <span class="o">=</span> <span class="n">min_q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
                                <span class="n">max_q</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">target</span><span class="o">);</span>
                            <span class="o">}</span>
                        <span class="o">}</span>

                    <span class="o">}</span>

                    <span class="cm">/**
                     * 큐가 비어있다면 "EMPTY"를 출력하고
                     * 비어있지 않다면, 최댓값과 최솟값을 공백을 두고 출력한다.
                     */</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">min_q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">max_q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"EMPTY"</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">max_q</span><span class="o">.</span><span class="na">peek</span><span class="o">()+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">min_q</span><span class="o">.</span><span class="na">peek</span><span class="o">()</span> <span class="o">+</span> <span class="s">"\n"</span><span class="o">);</span>
                    <span class="o">}</span>

                <span class="o">}</span>

        <span class="o">}</span>

    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><br /></p>

<p>이를 위해, 시간 초과가 발생하는 큐를 사용하는 것이 아니라 원소 추가 및 삭제에 <strong>O(logN)의 시간복잡도를 가지는 TreeMap</strong>를 이용하여 풀게 되었다. TreeMap을 활용해 풀 수 있는 아이디어를 다음과 같이 생각해보았다.</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">I N</code> 명령일 경우, N을 TreeMap에 Key로, N의 빈도수(개수)를 Value로 삽입한다.</li>
  <li>D 명령일 경우 TreeMap이 비어있다면 D 연산을 무시하고 넘어간다.</li>
  <li><code class="language-plaintext highlighter-rouge">D 1</code> 명령일 경우, TreeMap의 마지막 값(<code class="language-plaintext highlighter-rouge">lastKey()</code>)을 제거한다.</li>
  <li><code class="language-plaintext highlighter-rouge">D -1</code> 명령일 경우, TreeMap의 첫번째 값(<code class="language-plaintext highlighter-rouge">firstKey()</code>)을 제거한다.</li>
</ol>

<blockquote>
  <p><strong>TreeMap 자료구조는 오름차순 정렬</strong>이 기본으로 설정되어있다. 또한, <strong>firstKey()</strong> 메서드와 <strong>lastKey()</strong> 메서드가 존재한다. firstKey() 메서드는 Map의 첫번째 키를, lastKey() 메서드는 Map의 마지막 키를 가져올 수 있다.</p>
</blockquote>

<p>결국, TreeMap의 두 메서드를 통해 이중 우선순위 큐에서 서로의 큐의 삭제연산을 할 때의 비용을 절감하여 시간 초과를 해결할 수 있었다.</p>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="c1">// 1. 이중 우선순위 큐를 구현하기 위해 최소 힙, 최대 힙인 우선순위 큐 2개를 활용한다.</span>
        <span class="c1">// 2. I 명령이면 N을 삽입하고, D 1 명령이면 큐의 최댓값 제거, D -1 명령이면 큐의 최솟값을 제거한다.</span>
        <span class="c1">// 3. D 명령 수행시 큐가 비었다면 무시하고 진행한다.</span>
        <span class="c1">// 4. 큐에 저장되는 정수의 범위는 -2^31 부터 2^31까지 이기에 long형 타입을 사용해야 한다.</span>
        <span class="c1">// 5. D 명령 수행시 큐 remove() 연산을 수행하게 되면 시간초과가 발생한다.</span>
        <span class="c1">// 6. 원소의 추가, 삭제 이후에 정렬 상태를 유지하는데 O(logN)의 시간복잡도를 가지는 TreeMap 자료구조를 이용해 풀어야 한다.</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
            
                <span class="kt">int</span> <span class="no">T</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

                <span class="k">while</span><span class="o">(</span><span class="no">T</span> <span class="o">--&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>

                    <span class="c1">// 최소힙과 최대힙의 원소와 개수를 담을 TreeMap 선언</span>
                    <span class="nc">TreeMap</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">tm</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeMap</span><span class="o">&lt;&gt;();</span>

                    <span class="kt">int</span> <span class="no">K</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                    
                    <span class="k">while</span><span class="o">(</span><span class="no">K</span> <span class="o">--&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                        
                        <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                        <span class="nc">String</span> <span class="n">cmd</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">();</span>
                        <span class="kt">long</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Long</span><span class="o">.</span><span class="na">parseLong</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

                        <span class="c1">// cmd == I</span>
                        <span class="k">if</span><span class="o">(</span><span class="n">cmd</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"I"</span><span class="o">))</span> <span class="o">{</span>
                            <span class="n">tm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="no">N</span><span class="o">,</span> <span class="n">tm</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="no">N</span><span class="o">,</span> <span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
                        <span class="o">}</span> 
                        <span class="c1">// cmd == D</span>
                        <span class="k">else</span> <span class="o">{</span>
                            
                            <span class="c1">// TreeMap이 비어있다면 D 연산은 무시한다.</span>
                            <span class="k">if</span><span class="o">(</span><span class="n">tm</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="k">continue</span><span class="o">;</span>
                            
                            <span class="c1">// 최댓값 제거</span>
                            <span class="k">if</span><span class="o">(</span><span class="no">N</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>

                                <span class="c1">// 최댓값 key</span>
                                <span class="kt">long</span> <span class="n">last</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="na">lastKey</span><span class="o">();</span>
                                
                                <span class="c1">// 1개밖에 없다면 Map에서 제거</span>
                                <span class="k">if</span><span class="o">(</span><span class="n">tm</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">last</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                                    <span class="n">tm</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">last</span><span class="o">);</span>
                                    <span class="k">continue</span><span class="o">;</span>
                                <span class="o">}</span>
                                
                                <span class="c1">// 2개 이상이라면 개수 1개 차감</span>
                                <span class="n">tm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">last</span><span class="o">,</span> <span class="n">tm</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">last</span><span class="o">)-</span><span class="mi">1</span><span class="o">);</span>

                            <span class="o">}</span> 
                            <span class="c1">// 최솟값 제거</span>
                            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="no">N</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                                
                                <span class="c1">// 최솟값 key</span>
                                <span class="kt">long</span> <span class="n">first</span> <span class="o">=</span> <span class="n">tm</span><span class="o">.</span><span class="na">firstKey</span><span class="o">();</span>
                                
                                <span class="c1">// 1개밖에 없다면 Map에서 제거</span>
                                <span class="k">if</span><span class="o">(</span><span class="n">tm</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">first</span><span class="o">)</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                                    <span class="n">tm</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">first</span><span class="o">);</span>
                                    <span class="k">continue</span><span class="o">;</span>
                                <span class="o">}</span>

                                <span class="c1">// 2개 이상이라면 개수 1개 차감</span>
                                <span class="n">tm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">first</span><span class="o">,</span> <span class="n">tm</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">first</span><span class="o">)-</span><span class="mi">1</span><span class="o">);</span>


                            <span class="o">}</span>
                        <span class="o">}</span>

                    <span class="o">}</span>

                    <span class="cm">/**
                     * 큐가 비어있다면 "EMPTY"를 출력하고
                     * 비어있지 않다면, 최댓값과 최솟값을 공백을 두고 출력한다.
                     */</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">tm</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
                        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"EMPTY"</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
                    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                        <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">tm</span><span class="o">.</span><span class="na">lastKey</span><span class="o">()+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">tm</span><span class="o">.</span><span class="na">firstKey</span><span class="o">()</span> <span class="o">+</span> <span class="s">"\n"</span><span class="o">);</span>
                    <span class="o">}</span>

                <span class="o">}</span>
                
        <span class="o">}</span>

    <span class="o">}</span>


<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/7662">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[7662번 - 이중 우선순위 큐]]></summary></entry><entry><title type="html">[Java] 백준(실버-3) 17626번 - Four Squares</title><link href="http://localhost:4000/java/243-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-3) 17626번 - Four Squares" /><published>2023-08-07T00:00:00+09:00</published><updated>2023-08-07T00:00:00+09:00</updated><id>http://localhost:4000/java/243-post</id><content type="html" xml:base="http://localhost:4000/java/243-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 얼핏 보면 그리디 알고리즘과 헷갈리지만, <strong>동적계획법 DP</strong>를 이용해 풀어야 한다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>처음엔 무작정 제곱수가 큰 것부터 접근해나가려 했지만 N=12일 경우 <code class="language-plaintext highlighter-rouge">2^2 + 2^2 + 2^2</code>의 경우도 고려해야 하기 때문에 그리디 알고리즘이 아닌 DP로 풀어야 함을 알게 되었다.</p>

<p>DP를 이용해 부분 문제를 구해주면, 결국 최적해를 구할 수 있게 된다.</p>

<p>어떻게 최적해인 N을 만들기 위한 최소 제곱수의 개수를 구할 수 있을까? 1부터 9까지 최소 제곱수의 개수를 한번 나열하고 살펴보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="mi">1</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="n">개</span>
<span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="n">개</span>
<span class="mi">3</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="n">개</span>
<span class="mi">4</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">^</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="n">개</span>
<span class="mi">5</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="n">개</span>
<span class="mi">6</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="n">개</span>
<span class="mi">7</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="o">^</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">4</span><span class="n">개</span>
<span class="mi">8</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">^</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="n">개</span>
<span class="mi">9</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="o">^</span><span class="mi">3</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="n">개</span>
<span class="o">...</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>위처럼 1부터 9까지 살펴보면, N을 만들 수 있는 최소 제곱수의 개수의 패턴을 도출할 수 있다. <strong>N보다 작은 제곱수들 중에서 가장 작은 값을 가지는 D[N-제곱수] 값에 1을 더해</strong>주면 된다.</p>

<p>즉 이를 통해 도출한 점화식은 다음과 같다.</p>

<blockquote>
  <p>점화식: <code class="language-plaintext highlighter-rouge">D[i] = min(D[i-j*j])+1</code></p>
</blockquote>

<p>그러면 문제풀이를 위한 아이디어를 그려보자.</p>

<ol>
  <li>DP 테이블에 D[0]을 0으로, D[1]을 1인 초기값으로 설정한다.</li>
  <li>D[2]부터 D[N]까지 DP 테이블의 값을 채우기 위해 2부터 N까지 순회하며, 각 <strong>순회(이중for문)마다 최소가 되는 <code class="language-plaintext highlighter-rouge">D[i-j*j]</code>의 값을 D[i]번째에 채운다.</strong></li>
  <li>완전 탐색 종료 후 D[N]번째 값을 출력한다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// DP 테이블 선언</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="no">D</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>

            <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

            <span class="c1">// DP 테이블 초기화</span>
            <span class="no">D</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>

            <span class="c1">// 초기값 설정</span>
            <span class="no">D</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="no">D</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

            <span class="c1">// DP 함수 실행</span>
            <span class="no">DP</span><span class="o">(</span><span class="no">N</span><span class="o">);</span>
            
            <span class="c1">// DP 테이블의 N번째 값 출력</span>
            <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="no">D</span><span class="o">[</span><span class="no">N</span><span class="o">]+</span><span class="s">"\n"</span><span class="o">);</span>
            
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="cm">/**
     * DP 함수
     * 점화식: D[i] = min(D[i-j*j])+1
     */</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">DP</span><span class="o">(</span><span class="kt">int</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="c1">// 2부터 N까지 완전탐색으로 순회한다.</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            
            <span class="c1">// 최솟값을 비교하기 위한 변수</span>
            <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>
            
            <span class="c1">// 1. i보다 작은 제곱수를 뺄셈한 DP 테이블의 값 중 최솟값을 구한다.</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">*</span><span class="n">j</span><span class="o">&lt;=</span><span class="n">i</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">min</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">min</span><span class="o">,</span> <span class="no">D</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span> <span class="o">*</span> <span class="n">j</span><span class="o">]);</span>  
            <span class="o">}</span>
            
            <span class="c1">// 2. D[i]에 1을 더해준다.</span>
            <span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">min</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

        <span class="o">}</span>

    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/17626">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[17626번 - Four Squares]]></summary></entry><entry><title type="html">[Java] 백준(골드-5) 16928번 - 뱀과 사다리 게임</title><link href="http://localhost:4000/java/245-post/" rel="alternate" type="text/html" title="[Java] 백준(골드-5) 16928번 - 뱀과 사다리 게임" /><published>2023-08-07T00:00:00+09:00</published><updated>2023-08-07T00:00:00+09:00</updated><id>http://localhost:4000/java/245-post</id><content type="html" xml:base="http://localhost:4000/java/245-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 <strong>너비 우선 탐색 BFS</strong>를 이용해 간단하게 풀 수 있다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>10x10 크기의 게임 보드판에서 주사위를 던져 나오는 눈의 숫자만큼 이동하면서 사다리가 나오면 넘어가고, 뱀이 나오면 돌아오면서 100번째 칸에 도달했을 때 던진 주사위 횟수를 구해야 한다.</p>

<blockquote>
  <p>필자는 게임 보드판을 만들 때 상,하,좌,우 탐색 이동이 없어서, 2차원 배열보다 1차원 배열을 활용하는게 쉽다고 느껴서 1치원 배열을 이용했다.</p>
</blockquote>

<p>예제 1번을 토대로 아레 보드판을 만드는 과정을 알아보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="mi">1</span>  <span class="mi">2</span>  <span class="mi">3</span>  <span class="mi">4</span>  <span class="mi">5</span>  <span class="mi">6</span>  <span class="mi">7</span>  <span class="mi">8</span>  <span class="mi">9</span>  <span class="mi">10</span>
<span class="mi">11</span> <span class="mi">12</span><span class="o">(</span><span class="mi">98</span><span class="o">)</span> <span class="mi">13</span> <span class="mi">14</span> <span class="mi">15</span> <span class="mi">16</span> <span class="mi">17</span> <span class="mi">18</span> <span class="mi">19</span> <span class="mi">20</span>
<span class="o">...</span>
<span class="mi">91</span> <span class="mi">92</span><span class="o">(</span><span class="mi">37</span><span class="o">)</span> <span class="mi">93</span> <span class="mi">94</span><span class="o">(</span><span class="mi">13</span><span class="o">)</span> <span class="mi">95</span> <span class="mi">96</span> <span class="mi">97</span><span class="o">(</span><span class="mi">25</span><span class="o">)</span> <span class="mi">98</span> <span class="mi">99</span> <span class="mi">100</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>인덱스가 12인 위치에 98을 삽입하는 방식으로 배열의 값을 입력받는다면, 12 위치에 도달했을 때 98 위치로 이동하도록 하면 된다.</p>

<p>다음으로는 주사위를 굴려 나온 횟수를 어떻게 저장할까?</p>

<p>BFS 탐색을 통해 주사위를 굴리면서 보드판을 탐색해야 하니, 1부터 6까지 큐에 삽입하고 방문 여부 체크를 한다.</p>

<blockquote>
  <p>만약, 1이 나왔다면 다음엔 2부터 7까지 이동할 수 있다. 이때, 2부터 6까지는 1번만 던져 갈 수 있도록 처리했으니(방문 여부 체크) 7에는 한 번 더 던져야 하는 횟수인 2를 기록하면 된다. 그렇게 주사위를 던져나가면서 주사위 던진 횟수를 방문 배열에 기록하는데 사다리 위치가 나올 경우 12 위치에서 98 위치로 탐색을 건너뛰기 때문에 98 위치부터는 주사위 던진 횟수를 2부터 기록하게 된다. 결국, 99, 100까지는 주사위 3번만 던지면 이동할 수 있기 때문에 3을 출력하면 된다.</p>
</blockquote>

<p>설명이 좀 길었지만 문제 풀이를 위한 아이디어는 다음과 같다.</p>

<ol>
  <li>보드판을 1차원 배열을 활용해 1부터 100까지 채우기</li>
  <li>보드에 사다리 값을 갱신한다. - 사다리[0]에는 사다리[1] 값을 삽입</li>
  <li>보드에 뱀 값을 갱신한다. - 뱀[0]에는 뱀[1] 값을 갱신한다.</li>
  <li>1부터 BFS 탐색을 시작한다.</li>
  <li>주사위를 굴려 100번째 칸을 벗어날 경우 탐색을 스킵하고, <strong>방문하지 않은 칸이라면 주사위 굴린 횟수를 1 증가</strong>시켜 갱신해나간다.</li>
  <li>BFS 탐색 종료 후, 100번째 칸에 기록한 주사위 굴린 횟수를 출력한다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dx</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>

    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">board</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">visited</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
            
                <span class="c1">// 1. 보드판을 1차원 배열을 활용해 1부터 100까지 채우기</span>
                <span class="c1">// 2. 보드에 사다리 값을 갱신한다. - 사다리[0]에는 사다리[1] 값을 삽입</span>
                <span class="c1">// 3. 보드에 뱀 값을 갱신한다. - 뱀[0]에는 뱀[1] 값을 갱신한다.</span>
                <span class="c1">// 4. 1부터 BFS 탐색을 시작한다.</span>
                <span class="c1">// 5. BFS 탐색을 통해 100번째 칸에 도달할 때까지 주사위를 굴린다.</span>
                <span class="c1">// 6. 100번째 칸을 방문하면 주사위 굴린 횟수를 출력한다.</span>

                <span class="c1">// 보드판의 크기 1~100만큼 초기화</span>
                <span class="n">board</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">101</span><span class="o">];</span>
                <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">101</span><span class="o">];</span>

                <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

                <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                <span class="kt">int</span> <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

                <span class="c1">// 1차원 배열인 게임 보드판을 1부터 100까지 채운다.</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="mi">100</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="c1">// 사다리와 뱀의 위치를 보드판의 기록한다.</span>
                <span class="k">while</span><span class="o">(</span><span class="no">N</span> <span class="o">--&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                    <span class="kt">int</span> <span class="n">ladder1</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="kt">int</span> <span class="n">ladder2</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="n">board</span><span class="o">[</span><span class="n">ladder1</span><span class="o">]</span> <span class="o">=</span> <span class="n">ladder2</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">while</span><span class="o">(</span><span class="no">M</span> <span class="o">--&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                    <span class="kt">int</span> <span class="n">snake1</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="kt">int</span> <span class="n">snake2</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="n">board</span><span class="o">[</span><span class="n">snake1</span><span class="o">]</span> <span class="o">=</span> <span class="n">snake2</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="c1">// 1부처 BFS 함수를 통해 탐색을 진행한다.</span>
                <span class="no">BFS</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>

                <span class="c1">// BFS 탐색 종료 후, 100번째 칸 방문시 주사위를 굴린 횟수를 출력한다.</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="mi">100</span><span class="o">]+</span><span class="s">"\n"</span><span class="o">);</span>

        <span class="o">}</span>

    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">BFS</span><span class="o">(</span><span class="kt">int</span> <span class="n">node</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">node</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="k">while</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">now</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>

            <span class="c1">// 100번째 칸에 도달하면 순회 종료</span>
            <span class="k">if</span><span class="o">(</span><span class="n">now</span> <span class="o">==</span> <span class="mi">100</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>

            <span class="c1">// 큐가 빌때까지 주사위를 굴려 나오는 경우를 탐색하기 (1~6)</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="mi">6</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                
                <span class="c1">// 주사위 굴려서 이동할 수 있는 칸</span>
                <span class="kt">int</span> <span class="n">next</span> <span class="o">=</span> <span class="n">now</span> <span class="o">+</span> <span class="n">i</span><span class="o">;</span>

                <span class="cm">/**
                 * 주사위를 굴려서 보드판의 범위를 벗어나면 안된다.
                 * 이때, 던진 주사위 이동을 무시한다.
                 */</span>
                <span class="k">if</span><span class="o">(</span><span class="n">next</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">continue</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="cm">/*
                 * 주사위를 굴려 이동한 보드판 위치가 방문하지 않았다면,
                 * 해당 위치를 큐에 삽입하여 BFS의 탐색 대상이 될 수있도록 한다.
                 * 또한, 방문 배열에 주사위 굴린 횟수를 갱신한다.
                 */</span>
                <span class="k">if</span><span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">board</span><span class="o">[</span><span class="n">next</span><span class="o">]]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">next</span><span class="o">]);</span>
                    <span class="n">visited</span><span class="o">[</span><span class="n">board</span><span class="o">[</span><span class="n">next</span><span class="o">]]</span> <span class="o">=</span> <span class="n">visited</span><span class="o">[</span><span class="n">now</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
            
        <span class="o">}</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/16928">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[16928번 - 뱀과 사다리 게임]]></summary></entry><entry><title type="html">[Java] 백준(실버-2) 21736번 - 헌내기는 친구가 필요해</title><link href="http://localhost:4000/java/244-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-2) 21736번 - 헌내기는 친구가 필요해" /><published>2023-08-07T00:00:00+09:00</published><updated>2023-08-07T00:00:00+09:00</updated><id>http://localhost:4000/java/244-post</id><content type="html" xml:base="http://localhost:4000/java/244-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 <strong>너비 우선 탐색 BFS</strong>를 이용해 간단하게 풀 수 있다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>너비 우선 탐색인 BFS를 잘 숙지하고 있다면 쉽게 도연이가 사람들과 만난 횟수를 구할 수 있을 것이다.</p>

<p>문제풀이를 위한 아이디어는 다음과 같다.</p>

<ol>
  <li>지도를 입력받고 BFS 탐색을 수행한다.</li>
  <li>BFS로 탐색하면서 벽(X)이 아닌 빈공간(0)과 사람(P)일 경우만 상,하,좌,우 탐색을 이어나간다.</li>
  <li>사람(P)을 만날 경우 만난 횟수를 1 증가시킨다.</li>
  <li>BFS 탐색 종료후, 만난 룃수가 1 이상이라면 만난 횟수를, 사람을 만나지 못했다면 “TT”를 출력한다.</li>
</ol>

<p>유의할 점은 다음과 같다.</p>
<blockquote>
  <p>지도의 (0,0) 위치부터 탐색을 하는 것이 아니라, <strong>도연이의 위치부터 탐색을 시작</strong>해야 벽을 고려하여 사람들과의 만난 횟수를 구할 수 있다.</p>
</blockquote>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dx</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">};</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">dy</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">};</span>

    <span class="kd">static</span> <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">visited</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">char</span><span class="o">[][]</span> <span class="n">map</span><span class="o">;</span>

    <span class="kd">static</span> <span class="kt">int</span> <span class="no">N</span><span class="o">,</span> <span class="no">M</span><span class="o">;</span>

    <span class="kd">static</span> <span class="kt">int</span> <span class="n">result</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
            
            <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

            <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
            <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

            <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">M</span><span class="o">];</span>
            <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">M</span><span class="o">];</span>

            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="nc">String</span> <span class="n">input</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="no">M</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
                    <span class="c1">// 도연이의 위치를 x와 y에 담는다.</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'I'</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                        <span class="n">y</span> <span class="o">=</span> <span class="n">j</span><span class="o">;</span>  
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
            
            <span class="c1">// 만난 횟수를 담을 변수 초기화</span>
            <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

            <span class="c1">// 도연이의 위치부터 BFS를 수행한다.</span>
            <span class="no">BFS</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
            
            <span class="c1">// 만난 횟수가 1번 이상이라면 횟수를, 아니라면 "TT"를 출력한다.</span>
            <span class="k">if</span><span class="o">(</span><span class="n">result</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"TT"</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>
            <span class="o">}</span>
            
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="cm">/**
     * BFS 탐색 함수
     * 벽(X)아닌 위치로 상,하,좌,우 탐색을 한다.
     * 탐색 중, 사람(P)의 위치일 경우 result를 1 증가시킨다.
     */</span>
    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">BFS</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">[]&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">});</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">while</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span><span class="o">[]</span> <span class="n">now</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">dir</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">dir</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">;</span> <span class="n">dir</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">now</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">dx</span><span class="o">[</span><span class="n">dir</span><span class="o">];</span>
                <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">now</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">dy</span><span class="o">[</span><span class="n">dir</span><span class="o">];</span>
                <span class="k">if</span><span class="o">(</span><span class="n">isRange</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">))</span> <span class="o">{</span>
                    <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">!=</span> <span class="sc">'X'</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'P'</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">result</span><span class="o">++;</span>
                        <span class="o">}</span>
                        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="kt">int</span><span class="o">[]{</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">});</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    
    <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">isRange</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span><span class="o">(</span><span class="mi">0</span><span class="o">&lt;=</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="n">x</span><span class="o">&lt;</span><span class="no">N</span> <span class="o">&amp;&amp;</span> <span class="n">y</span><span class="o">&lt;</span><span class="no">M</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/21736">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[21736번 - 헌내기는 친구가 필요해]]></summary></entry><entry><title type="html">[Java] 백준(실버-3) 9375번 - 패션왕 신해빈</title><link href="http://localhost:4000/java/241-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-3) 9375번 - 패션왕 신해빈" /><published>2023-08-04T00:00:00+09:00</published><updated>2023-08-04T00:00:00+09:00</updated><id>http://localhost:4000/java/241-post</id><content type="html" xml:base="http://localhost:4000/java/241-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 <strong>조합</strong>과 관련된 문제로 <strong>HashMap</strong>을 이용해 간단히 풀 수 있다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>문제의 예시만 잘 살펴봐도 어떻게 풀어야 할지 쉽게 파악할 수 있다. 예시를 보자.</p>

<p>문제의 요구사항을 보면 위에서 두어진 2 종류와 3개의 옷가지를 통해 <strong>알몸이 되지 않는 경우의 수</strong>를 구해야 한다고 한다.</p>

<p>경우의 수를 바로 구해보자. 이때, 같은 종류의 옷은 입지 못하는 것을 유의하자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="n">한</span> <span class="n">개만</span> <span class="n">입을</span> <span class="n">경우</span> <span class="o">:</span> <span class="o">{</span><span class="n">hat</span><span class="o">},</span> <span class="o">{</span><span class="n">turban</span><span class="o">},</span> <span class="o">{</span><span class="n">sunglasses</span><span class="o">}</span>
<span class="n">두</span> <span class="n">개씩</span> <span class="n">조합하여</span> <span class="n">입을</span> <span class="n">경우</span> <span class="o">:</span> <span class="o">{</span><span class="n">hat</span><span class="o">,</span> <span class="n">sunglasses</span><span class="o">},</span> <span class="o">{</span><span class="n">turban</span><span class="o">,</span> <span class="n">sunglasses</span><span class="o">}</span>

<span class="n">총</span> <span class="mi">5</span><span class="n">가지</span> <span class="n">경우의</span> <span class="n">수</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>이렇게 5가지 경우의 수를 구하면 되는데, 조합 공식을 통해 구하는 방법을 알아보자.</p>

<blockquote>
  <p><strong>[headgear]</strong> <br />
hat <br />
turban</p>
</blockquote>

<blockquote>
  <p><strong>[eyewear]</strong> <br />
sunglasses</p>
</blockquote>

<p>위와 같이 두 종류의 옷마다 1개를 선택하는 경우의 수를 구해야 한다. 그런데 위의 종류의 옷은 저것으로 끝이 아니다! 바로 <strong>아무 것도 입지 않는 경우도 포함</strong>시켜야 한다.</p>

<blockquote>
  <p><strong>[headgear]</strong> <br />
hat <br />
turban <br />
null</p>
</blockquote>

<blockquote>
  <p><strong>[eyewear]</strong> <br />
sunglasses <br />
null</p>
</blockquote>

<p>위와 같이 알몸의 아무 것도 입지 않은 경우를 두 종류에 포함시켜서 조합 공식을 적용해야 한다. 그렇게 <strong>headgear에서는 3C1</strong>을, <strong>eyewear에서는 2C1</strong>을 구한다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="mi">3</span><span class="no">C1</span> <span class="o">=</span> <span class="mi">3</span>
<span class="mi">2</span><span class="no">C1</span> <span class="o">=</span> <span class="mi">2</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>이 둘을 곱하면 6으로 모든 종류의 옷을 통해 구한 경우의 수가 된다. 그리고 한 가지 더 유의할 점은 옷의 종류마다 안 입는 경우도 포함시켰기 때문에 모든 경우의 수에는 알몸인 상태가 포함되어 있다. 그래서 <code class="language-plaintext highlighter-rouge">(3C1 * 2C1) - 1</code>과 같이 <strong>1가지 경우의 수를 차감시켜 알몸인 경우를 제외</strong>해야 한다.</p>

<p>이를 통해 문제를 풀기 위해 정리한 아이디어는 다음과 같다.</p>

<ol>
  <li>T(테스트케이스)마다 HashMap에 옷의 종류와 옷의 종류의 갯수를 담는다. (이때, 옷 이름은 필요없다.)</li>
  <li>같은 옷의 종류가 나온다면 갯수를 1 증가시키고, 같은 종류의 옷이 아니라면 1을 삽입하여 카운트할 수 있도록 한다.</li>
  <li>HashMap을 순회하며, 옷의 종류마다 알몸의 경우를 고려해(+1) 곱해나가면, 알몸이 아닌 옷의 종류별 모든 경우의 수를 구할 수 있다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
        <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">));</span>
        
        <span class="kt">int</span> <span class="no">T</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

        <span class="k">while</span><span class="o">(</span><span class="no">T</span> <span class="o">--&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
            
            <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">hm</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
            <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

            <span class="k">while</span><span class="o">(</span><span class="no">N</span> <span class="o">--&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
                <span class="nc">String</span> <span class="n">cloth_type</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">)[</span><span class="mi">1</span><span class="o">];</span>

                <span class="cm">/**
                 * 같은 종류의 옷이 hashMap에 존재한다면, 해당 종류의 값을 1씩 증가시킨다.
                 * 같은 종류의 옷이 없다면 값에 1을 삽입한다.
                 */</span>
                <span class="k">if</span><span class="o">(</span><span class="n">hm</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">cloth_type</span><span class="o">))</span> <span class="o">{</span>
                    <span class="n">hm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">cloth_type</span><span class="o">,</span> <span class="n">hm</span><span class="o">.</span><span class="na">getOrDefault</span><span class="o">(</span><span class="n">cloth_type</span><span class="o">,</span> <span class="mi">0</span><span class="o">)+</span><span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                    <span class="n">hm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">cloth_type</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
                <span class="o">}</span>

            <span class="o">}</span>
            
            <span class="c1">// 조합을 구할 변수</span>
            <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

            <span class="c1">// 안 입는 경ㅜ를 고해 종류별로 경우의 수ㄹ 1씩 더해야 한다.</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span> <span class="o">:</span> <span class="n">hm</span><span class="o">.</span><span class="na">values</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">result</span> <span class="o">*=</span> <span class="o">(</span><span class="n">value</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>
            
            <span class="c1">// 모두 안입은 경우의 수 1가지를 감소시킨다.</span>
            <span class="n">result</span> <span class="o">-=</span> <span class="mi">1</span><span class="o">;</span>

            <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>

        <span class="o">}</span>
        
        <span class="n">bw</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
        <span class="n">br</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/9375">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[9375번 - 패션왕 신해빈]]></summary></entry><entry><title type="html">[Java] 백준(실버-4) 17219번 - 비밀번호 찾기</title><link href="http://localhost:4000/java/242-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-4) 17219번 - 비밀번호 찾기" /><published>2023-08-04T00:00:00+09:00</published><updated>2023-08-04T00:00:00+09:00</updated><id>http://localhost:4000/java/242-post</id><content type="html" xml:base="http://localhost:4000/java/242-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 자료구조 중 하나인 <strong>HashMap</strong>을 이용해 간단히 풀 수 있다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<blockquote>
  <p>문제에서 요구한 대로 입출력 속도 향상을 위해 Scanner가 아닌 BufferedReader와 BufferedWriter를 사용하여 입출력 처리를 하였다.</p>
</blockquote>

<p>문제 자체는 굉장히 쉽다.</p>

<ol>
  <li>N만큼의 입력을 받으며 HashMap에 사이트와 비밀번호를 담는다.</li>
  <li>M만큼의 찾고자 하는 사이트 입력을 받으며 해당 사이트가 HashMap에 있는지 찾아 사이트의 값인 비밀번호를 출력한다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>

            <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
        
            <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
            <span class="kt">int</span> <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

            <span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">hm</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>

            <span class="c1">// HashMap에 사이트와 비밀번호를 담는다.</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
                <span class="n">hm</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">str</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">)[</span><span class="mi">0</span><span class="o">],</span> <span class="n">str</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">" "</span><span class="o">)[</span><span class="mi">1</span><span class="o">]);</span>
            <span class="o">}</span>
            
            <span class="c1">// 해당 사이트의 문자열 값을 key로 HashMap의 value인 비밀번호를 조회한다.</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">M</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="nc">String</span> <span class="n">find</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">hm</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">find</span><span class="o">)+</span><span class="s">"\n"</span><span class="o">);</span>
            <span class="o">}</span>

        <span class="o">}</span>

    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/17219">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[17219번 - 비밀번호 찾기]]></summary></entry></feed>