<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-08-24T23:52:56+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">lango’s DevLog</title><subtitle>developer</subtitle><author><name>lango</name></author><entry><title type="html">[Java] 백준(골드-5) 14719번 - 빗물</title><link href="http://localhost:4000/java/260-post/" rel="alternate" type="text/html" title="[Java] 백준(골드-5) 14719번 - 빗물" /><published>2023-08-24T00:00:00+09:00</published><updated>2023-08-24T00:00:00+09:00</updated><id>http://localhost:4000/java/260-post</id><content type="html" xml:base="http://localhost:4000/java/260-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 요구사항대로 잘 <strong>구현</strong>하면 된다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/14719">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[14719번 - 빗물]]></summary></entry><entry><title type="html">[Java] 백준(골드-4) 9019번 - DSLR</title><link href="http://localhost:4000/java/259-post/" rel="alternate" type="text/html" title="[Java] 백준(골드-4) 9019번 - DSLR" /><published>2023-08-23T00:00:00+09:00</published><updated>2023-08-23T00:00:00+09:00</updated><id>http://localhost:4000/java/259-post</id><content type="html" xml:base="http://localhost:4000/java/259-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 <strong>너비 우선 탐색 BFS</strong>을 응용하여 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>여태 BFS를 이용하며, 지도 배열에서 상,하,좌,우를 탐색할 dx, dy 배열을 이용했지만, 이번 문제는 D,S,L,R이라는 특수 명령마다 탐색해가며 누적되는 문자열을 반환해야 하는 문제이기에 별도의 레지스터 값과 문자열을 담을 클래스를 이용하게 되었다.</p>

<p>그렇게, A라는 수를 B로 표현할 수 있는 최소한의 방법인 <strong>수행할 명령을 나열한 문자열</strong>을 출력하는 방법을 살펴보자.</p>

<ol>
  <li>BFS를 통해 A라는 수를 D,S,L,R 명령을 통해 변환한다.</li>
  <li>문제의 요구사항을 잘 살펴서 D, S, L, R 명령을 수행한다.(자세한 내용은 아래에서 확인!)</li>
  <li>D,S,L,R 명령을 수행하며 변환된 레지스터 값이 B가 된다면 탐색을 종료한다.</li>
  <li>변환 과정에서 수행한 명령을 문자열로 출력하면 된다.</li>
</ol>

<blockquote>
  <p>D,S,L,R 명령 수행</p>
  <ul>
    <li>D: 수를 2배로 바꾸고 10000으로 나눈 나머지로 갱신한다.</li>
    <li>S: 수를 0일 때, 9999, 아니면 1을 빼준다</li>
    <li>L: 왼쪽으로 자리수를 바꾼다. <br /> <code class="language-plaintext highlighter-rouge">1234 -&gt; 2341, 1234를 1000으로 나눈 나머지(234)에 10을 곱함=2340, 1234를 1000으로 나누면 1, 2340+1=2341</code></li>
    <li>R: 오른쪽으로 자리수를 바꾼다. <br /><code class="language-plaintext highlighter-rouge">1234 -&gt; 4123, 1234를 10으로 나눈 나머지에 1000 곱합 = 4000, 1234를 10으로 나누면 123, 4000+123=4123</code></li>
  </ul>
</blockquote>

<p>이때, <strong>현재까지의 레지스터값과 수행한 명령어를 담을 Register라는 클래스를 사용</strong>하였다.</p>

<p>그렇게 모든 경우에서 4가지 명령어를 실행하고 각각의 실행한 경우에서 또 명령어를 실행하도록 반복하였고 결국, 변환된 값이 B가 되었을때 누적된 문자열(명령어)를 반환하도록 구현했다.</p>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// 방문 배열 선언</span>
    <span class="kd">static</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span><span class="o">;</span>
    
    <span class="c1">// D,S,L,R 명령을 담을 배열 선언</span>
    <span class="kd">static</span> <span class="kt">char</span><span class="o">[]</span> <span class="n">cmds</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[]{</span><span class="sc">'D'</span><span class="o">,</span> <span class="sc">'S'</span><span class="o">,</span> <span class="sc">'L'</span><span class="o">,</span> <span class="sc">'R'</span><span class="o">};</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
                
                <span class="kt">int</span> <span class="no">T</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                <span class="k">while</span><span class="o">(</span><span class="no">T</span> <span class="o">--&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    
                    <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                    <span class="kt">int</span> <span class="no">A</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="kt">int</span> <span class="no">B</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

                    <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="mi">10000</span><span class="o">];</span>
                    
                    <span class="nc">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">bfs</span><span class="o">(</span><span class="no">A</span><span class="o">,</span> <span class="no">B</span><span class="o">);</span>
                    <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>

                <span class="o">}</span>

        <span class="o">}</span>

    <span class="o">}</span>

    <span class="c1">// D,S,L,R 만큼 너비우번 탐색을 진행할 bfs 함수</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span> <span class="nf">bfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="nc">Queue</span><span class="o">&lt;</span><span class="nc">Register</span><span class="o">&gt;</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedList</span><span class="o">&lt;&gt;();</span>
        <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">Register</span><span class="o">(</span><span class="n">start</span><span class="o">,</span> <span class="s">""</span><span class="o">));</span>
        <span class="n">visited</span><span class="o">[</span><span class="n">start</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>

        <span class="k">while</span><span class="o">(!</span><span class="n">q</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            
            <span class="nc">Register</span> <span class="n">now</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
        
            <span class="c1">// 만약 A와 B가 같다면 변환이 성공한 것이니 탐색을 종료한다.</span>
            <span class="k">if</span><span class="o">(</span><span class="n">now</span><span class="o">.</span><span class="na">num</span> <span class="o">==</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span> <span class="n">now</span><span class="o">.</span><span class="na">command</span><span class="o">;</span>
            <span class="o">}</span>
            
            <span class="c1">// D,S,L,R 4번을 반복한다.</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">change</span> <span class="o">=</span> <span class="n">changeRegister</span><span class="o">(</span><span class="n">now</span><span class="o">.</span><span class="na">num</span><span class="o">,</span> <span class="n">cmds</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
                <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">change</span><span class="o">])</span> <span class="o">{</span>
                    <span class="n">visited</span><span class="o">[</span><span class="n">change</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                    <span class="n">q</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="k">new</span> <span class="nc">Register</span><span class="o">(</span><span class="n">change</span><span class="o">,</span> <span class="n">now</span><span class="o">.</span><span class="na">command</span> <span class="o">+</span> <span class="n">cmds</span><span class="o">[</span><span class="n">i</span><span class="o">]));</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="s">""</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="cm">/**
     * D,S,L,R 명령별 기능을 수행할 함수
     * D: 수를 2배로 바꾸고 10000으로 나눈 나머지로 갱신한다.
     * S: 수를 0일 때, 9999, 아니면 1을 빼준다 
     * L: 왼쪽으로 자리수를 바꾼다.
     * R: 오른쪽으로 자리수를 바꾼다.
     */</span>  
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">changeRegister</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">,</span> <span class="kt">char</span> <span class="n">cmd</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">switch</span><span class="o">(</span><span class="n">cmd</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">case</span> <span class="sc">'D'</span><span class="o">:</span>
                <span class="n">num</span> <span class="o">*=</span> <span class="mi">2</span><span class="o">;</span>
                <span class="k">if</span><span class="o">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="mi">9999</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">num</span> <span class="o">%=</span> <span class="mi">10000</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="sc">'S'</span><span class="o">:</span>
                <span class="n">num</span> <span class="o">-=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="k">if</span><span class="o">(</span><span class="n">num</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">num</span> <span class="o">=</span> <span class="mi">9999</span><span class="o">;</span>
                <span class="o">}</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="sc">'L'</span><span class="o">:</span>
                <span class="kt">int</span> <span class="n">tmp_l1</span> <span class="o">=</span> <span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="mi">1000</span><span class="o">)</span> <span class="o">*</span> <span class="mi">10</span><span class="o">;</span>
                <span class="kt">int</span> <span class="n">tmp_l2</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="mi">1000</span><span class="o">;</span>
                <span class="n">num</span> <span class="o">=</span> <span class="n">tmp_l1</span> <span class="o">+</span> <span class="n">tmp_l2</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">case</span> <span class="sc">'R'</span><span class="o">:</span>
                <span class="kt">int</span> <span class="n">tmp_r1</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="mi">10</span><span class="o">;</span>
                <span class="kt">int</span> <span class="n">tmp_r2</span> <span class="o">=</span> <span class="o">(</span><span class="n">num</span> <span class="o">%</span> <span class="mi">10</span><span class="o">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="o">;</span>
                <span class="n">num</span> <span class="o">=</span> <span class="n">tmp_r1</span> <span class="o">+</span> <span class="n">tmp_r2</span><span class="o">;</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="k">default</span><span class="o">:</span>
                <span class="k">break</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">num</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// register값과 수행한 명령을 담을 Register 클래스</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Register</span> <span class="o">{</span>
        
        <span class="kt">int</span> <span class="n">num</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">command</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">Register</span><span class="o">(</span><span class="kt">int</span> <span class="n">num</span><span class="o">,</span> <span class="nc">String</span> <span class="n">command</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">num</span> <span class="o">=</span> <span class="n">num</span><span class="o">;</span>
            <span class="k">this</span><span class="o">.</span><span class="na">command</span> <span class="o">=</span> <span class="n">command</span><span class="o">;</span>
        <span class="o">}</span>
        
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/9019">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[9019번 - DSLR]]></summary></entry><entry><title type="html">[Java] 백준(실버-1) 5525번 - IOIOI</title><link href="http://localhost:4000/java/258-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-1) 5525번 - IOIOI" /><published>2023-08-22T00:00:00+09:00</published><updated>2023-08-22T00:00:00+09:00</updated><id>http://localhost:4000/java/258-post</id><content type="html" xml:base="http://localhost:4000/java/258-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 <strong>문자열</strong> 문제로 문제의 서브테스크를 모두 충족해야 100점을 받을 수 있다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>처음에는 단순히 이중 for문으로 Pn 만큼 추가로 순회하며 IOI를 체크했지만, 시간초과가 발생하였다. 그래서 시간복잡도를 O(n)으로 줄이기 위해 DP 테이블을 이용하였다.</p>

<p>문제 풀이를 위한 아이디어는 다음과 같다.</p>

<ol>
  <li>Pn에 해당하는 문자열인지 확인하기 위해 S의 <strong>2번째 원소부터 순회를 시작</strong>한다.</li>
  <li>S를 순회하면서, 현재 위치까지 Pn만큼의 문자열을 만들어 Pn과 같다면, <strong>DP 테이블 위치에 1씩 카운트를 누적하도록 갱신</strong>한다.</li>
  <li>이후, <strong>DP 테이블의 현재값이 N보다 크거나 같다면, Pn이 포함되어 있는 것이기에 카운트를 1씩 증가</strong>시킨다.</li>
</ol>

<blockquote>
  <p>Pn이 S에 포함되어 있는지를 DP 테이블의 값을 보고 판단하기에 시간복잡도를 O(n)으로 줄일 수 있었다.</p>
</blockquote>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
                
                <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                <span class="kt">int</span> <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                
                <span class="nc">String</span> <span class="no">S</span> <span class="o">=</span> <span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">();</span>
                
                <span class="c1">// M만큼의 길이를 가지는 DP 테이블 선언</span>
                <span class="kt">int</span><span class="o">[]</span> <span class="no">D</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">M</span><span class="o">];</span>
                
                <span class="c1">// 결과 갯수를 담을 변수</span>
                <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

                <span class="c1">// M의 최소 길이는 IOI인 3부터 시작하기에 </span>
                <span class="c1">// 2번째 위치부터 Pn이 포함되는지를 확인하기 위해 순회한다.</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">M</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    
                    <span class="c1">// 현재 위치까지 Pn(IOI)만큼 길이가 3인 문자열을 만든다.</span>
                    <span class="nc">String</span> <span class="n">temp</span> <span class="o">=</span> <span class="no">S</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
                    
                    <span class="c1">// 만든 temp가 "IOI"와 같다면 DP 테이블에 카운트를 1씩 갱신한다.  </span>
                    <span class="k">if</span><span class="o">(</span><span class="n">temp</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"IOI"</span><span class="o">))</span> <span class="o">{</span>
                        <span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="o">}</span>

                    <span class="c1">// DP 테이블의 값이 N보다 크거나 같다면 Pn이 포함되어 있는 것이기에 result를 1씩 증가시킨다.</span>
                    <span class="k">if</span><span class="o">(</span><span class="no">D</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&gt;=</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">result</span><span class="o">++;</span>
                    <span class="o">}</span>

                <span class="o">}</span>
                                
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>

        <span class="o">}</span>

    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/5525">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[5525번 - IOIOI]]></summary></entry><entry><title type="html">[Java] 백준(실버-1) 11403번 - 경로 찾기</title><link href="http://localhost:4000/java/256-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-1) 11403번 - 경로 찾기" /><published>2023-08-21T00:00:00+09:00</published><updated>2023-08-21T00:00:00+09:00</updated><id>http://localhost:4000/java/256-post</id><content type="html" xml:base="http://localhost:4000/java/256-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이 문제는 <strong>플로이드 워셜</strong> 알고리즘을 이용해 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>플로이드 워셜 알고리즘은 모든 정점에서 모든 정점으로의 최단거리를 구하는 알고리즘이다. 문제에서 요구하는 경로 확인을 위해서는 플로이드 워셜 알고리즘을 이용해 <strong>거쳐가는 정점</strong>을 확인해야 한다.</p>

<p>이 거쳐 가는 정점을 기준으로 최단 거리를 구할 수 있다. 이 말은 즉, <strong>i에서 j까지 가는 길이 있는지 확인하려면 i에서 k로 가고, k에서 j로 가는 길이 있으면 된다</strong>라고 볼 수 있다.</p>

<p>이는 문제에서 i에서 j로 갈 수 있는 경로가 있는지 판단해야하는 것과 완전히 부합한다. 이제 문제 풀이를 위한 아이디어를 생각해보자.</p>

<ol>
  <li>그래프를 입력받는다.</li>
  <li>3중 반복문을 통해 거쳐가는 정점을 확인(k가 0, 1, … , N - 1일 때까지 설정)해가며, <strong>i에서 k로 가는길과 k에서 j로 가는길이 있는지(==1) 확인</strong>한다.</li>
  <li>i -&gt; k, k -&gt; j로 가는 길이 있다면 <strong>i에서 j로 가는길이 있는 것이기에 해당 위치를 1로 갱신</strong>한다.</li>
  <li>위 갱신 작업을 마친 후의 그래프를 출력한다.</li>
</ol>

<blockquote>
  <p>이번 문제에서는 단순히 i에서 j로 갈 수 있는지만 체크하면 되기에 쉽게 풀 수 있다.</p>
</blockquote>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
            
            <span class="kt">int</span> <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

            <span class="kt">int</span><span class="o">[][]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">N</span><span class="o">];</span>

            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="cm">/**
             * 플로이드 워셜을 통해 거쳐가는 정점 확인
             * i에서 j까지 갈 수 있는지는 i에서 k로, k에서 j로 갈 수 있는지를 확인한다.
             * 갈 수 있다면, 해당 위치를 1로 갱신한다.
             */</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                        <span class="k">if</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="k">for</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">a</span> <span class="o">:</span> <span class="n">arr</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">:</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">n</span><span class="o">+</span> <span class="s">" "</span><span class="o">);</span>
                <span class="o">}</span>
                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="s">"\n"</span><span class="o">);</span>
            <span class="o">}</span>

        <span class="o">}</span>

    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/11403">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[11403번 - 경로 찾기]]></summary></entry><entry><title type="html">[Java] 백준(실버-1) 1389번 - 케빈 베이컨의 6단계 법칙</title><link href="http://localhost:4000/java/257-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-1) 1389번 - 케빈 베이컨의 6단계 법칙" /><published>2023-08-21T00:00:00+09:00</published><updated>2023-08-21T00:00:00+09:00</updated><id>http://localhost:4000/java/257-post</id><content type="html" xml:base="http://localhost:4000/java/257-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이 문제는 <strong>플로이드 워셜</strong> 알고리즘을 이용해 풀 수 있는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>이전에 풀어봤던 문제에서는 정점사이의 경로 여부만 체크했다면, 이번 문제에서는 모든 정점 사이의 최단거리를 구해주어야 한다.</p>

<blockquote>
  <p>이전에 풀었던 <a href="https://langoustinee.github.io/java/256-post/">경로 찾기</a> 문제에서의 조건은 단순히 거쳐가는 정점의 경로가 존재하는지 체크하는 것이었지만, 이번에는 최단 경로를 나타내야하기 때문에 arr[i][j] &gt; arr[i][k] + arr[k][j] 일 경우, arr[i][j] = arr[j][k] + arr[k][j]로 초기화해야 한다.</p>
</blockquote>

<p>이를 고려하여 문제 풀이를 위한 아이디어를 생각해보자.</p>

<ol>
  <li>먼저, 2차원 배열의 모든 값을 5001로 초기화한 뒤, i와 j과 같은 위치인 (1, 1), (2, 2), … (i, i)인 값은 모두 0으로 초기화 해준다.
    <blockquote>
      <p>플로이드 워셜 알고리즘은 i번째 정점에서 j번째 정점이 연결되어있지 않을 경우 무한대를 나타내는 값을 넣어줘야 하는데, 이 때, 필자는 M의 최대 범위인 5001를 넣어줬다.</p>
    </blockquote>
  </li>
  <li>문제에서 입력으로 주어지는 간선을 양방향으로 1로 초기화 해준다.</li>
  <li>플로이드 워셜 알고리즘을 수행하여, 모든 정점에서 모든 정점 사이의 최단 거리가 담긴 <strong>arr 배열을 탐색하며 최솟값이 되는 케빈 베이컨 수를 찾으면 된다.</strong></li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// 입력 배열</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">arr</span><span class="o">;</span> 

    <span class="kd">static</span> <span class="kt">int</span> <span class="no">N</span><span class="o">,</span> <span class="no">M</span><span class="o">;</span>

    <span class="kd">static</span> <span class="kt">int</span> <span class="n">result</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
                
                <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

                <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

                <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="no">N</span><span class="o">+</span><span class="mi">1</span><span class="o">];</span>

                <span class="c1">// 배열 초기화</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="no">N</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                        <span class="k">if</span><span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
                            <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                            <span class="k">continue</span><span class="o">;</span>
                        <span class="o">}</span>
                        <span class="c1">// i와 j가 연결되어 있지 않다면, 최대 수인 5001을 삽입한다.</span>
                        <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="mi">5001</span><span class="o">;</span>
                    <span class="o">}</span>
                    
                <span class="o">}</span>

                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">M</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                    <span class="kt">int</span> <span class="no">A</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="kt">int</span> <span class="no">B</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="c1">// 양방향 그래프이기에, 양방향 모두 1로 초기화한다.</span>
                    <span class="n">arr</span><span class="o">[</span><span class="no">A</span><span class="o">][</span><span class="no">B</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="n">arr</span><span class="o">[</span><span class="no">B</span><span class="o">][</span><span class="no">A</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
                <span class="o">}</span>

                <span class="cm">/**
                 * 플로이드 워셜 알고리즘을 이용해 최단경로를 갱신한다.
                 * k: 거쳐가는 노드
                 * i: 출발 노드
                 * j: 도착 노드
                 */</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">k</span><span class="o">&lt;=</span><span class="no">N</span><span class="o">;</span> <span class="n">k</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="no">N</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                            <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">],</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span> <span class="o">+</span> <span class="n">arr</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">j</span><span class="o">]);</span>
                        <span class="o">}</span>
                    <span class="o">}</span>
                <span class="o">}</span>

                <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

                <span class="c1">// 가장 작은 케빈 베이컨 수를 찾는다.</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="kt">int</span> <span class="n">baconNumber</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;=</span><span class="no">N</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                        <span class="n">baconNumber</span> <span class="o">+=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                    <span class="o">}</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">min</span> <span class="o">&gt;</span> <span class="n">baconNumber</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
                        <span class="n">min</span> <span class="o">=</span> <span class="n">baconNumber</span><span class="o">;</span>
                    <span class="o">}</span>
                <span class="o">}</span>

                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>

        <span class="o">}</span>

    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/1389">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[1389번 - 케빈 베이컨의 6단계 법칙]]></summary></entry><entry><title type="html">[Java] 백준(실버-2) 1182번 - 부분수열의 합</title><link href="http://localhost:4000/java/255-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-2) 1182번 - 부분수열의 합" /><published>2023-08-18T00:00:00+09:00</published><updated>2023-08-18T00:00:00+09:00</updated><id>http://localhost:4000/java/255-post</id><content type="html" xml:base="http://localhost:4000/java/255-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이 문제는 재귀를 통한 <strong>백트래킹</strong> 유형으로 풀 수 있는 문제 중 하나이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>이 문제에서는 수열에 담긴 <strong>배열의 원소를 선택하는 경우와 선택하지 않는 경우를 구분</strong>하는 것이 핵심이다.</p>

<p>생각해낸 아이디어를 먼저 살펴보자.</p>

<ol>
  <li>dfs로 배열을 탐색하며, 배열의 모든 원소로 포함시켜 만드는 부분수열과, 포함시키지 않는 부분수열을 만들어간다.</li>
  <li>dfs의 깊이가 N(수열의 길이의 끝)이 된다면, 부분 수열의 합이 S가 되는지 확인하고 경우의 수를 1 증가시킨 후, 재귀를 종료한다.</li>
</ol>

<p>위와 같이 dfs를 통해 탐색하는데, <strong>배열의 현재 원소를 포함(선택)시켜 만드는 부분 수열과, 포함시키지 않고 만드는 부분 수열</strong>을 만들어가며, 그 부분수열들의 합이 S가 되는지 확인해야 한다.</p>

<blockquote>
  <p>특히, S가 0인경우 모든 값의 경우가 0일 때인 공집합일 때를 고려해야 하기에 경우의 수를 출력하기 전 1을 차감해줘야 한다.</p>
</blockquote>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// N개의 수열을 담을 배열 선언</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">;</span>
    
    <span class="c1">// 수열의 개수 N과 양수인 부분 수열의 개수 S 선언</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="no">N</span><span class="o">,</span> <span class="no">S</span><span class="o">;</span>

    <span class="c1">// 경우의 수를 담을 변수 선언</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">result</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
            
                <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                
                <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                <span class="no">S</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>

                <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>

                <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                <span class="o">}</span>

                <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

                <span class="c1">// dfs 호출하여 탐색을 시작한다.</span>
                <span class="n">dfs</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>

                <span class="c1">// 공집합일 경우를 고려해야 하기 때문에 S==0인 경우 경우의 수를 1개 차감한다.</span>
                <span class="k">if</span><span class="o">(</span><span class="no">S</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">result</span><span class="o">--;</span>
                <span class="o">}</span>

                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>

        <span class="o">}</span>

    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">depth</span><span class="o">,</span> <span class="kt">int</span> <span class="n">sum</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="c1">// 재귀의 깊이가 N이 된다면 종료한다. </span>
        <span class="k">if</span><span class="o">(</span><span class="n">depth</span> <span class="o">==</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
            
            <span class="c1">// 이때, 부분 수열의 합이 S가 된다면 result를 1 증가시킨다.</span>
            <span class="k">if</span><span class="o">(</span><span class="n">sum</span> <span class="o">==</span> <span class="no">S</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">result</span><span class="o">++;</span>
            <span class="o">}</span>

            <span class="k">return</span><span class="o">;</span>

        <span class="o">}</span>
        
        <span class="c1">// 원소를 선택했을 경우 sum에 더해여 재귀 호출한다.</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">arr</span><span class="o">[</span><span class="n">depth</span><span class="o">]);</span>

        <span class="c1">// 원소를 선택하지 않았을 경우 sum을 그대로 재귀 호출한다.</span>
        <span class="n">dfs</span><span class="o">(</span><span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">sum</span><span class="o">);</span>

    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/1182">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[1182번 - 부분수열의 합]]></summary></entry><entry><title type="html">[Java] 백준(실버-2) 14889번 - 스타트와 링크</title><link href="http://localhost:4000/java/254-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-2) 14889번 - 스타트와 링크" /><published>2023-08-17T00:00:00+09:00</published><updated>2023-08-17T00:00:00+09:00</updated><id>http://localhost:4000/java/254-post</id><content type="html" xml:base="http://localhost:4000/java/254-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이 문제는 재귀를 통한 <strong>백트래킹</strong> 유형으로 풀 수 있는 문제 중 하나이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>N이 4일 때, 즉 4명의 사람이 있을 경우 2팀으로 나누어 조합을 톨해 경우의 수를 구해야 한다. 그 경우의 수는 다음과 같다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="o">[(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)],</span>
<span class="o">[(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">),</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">)],</span>
<span class="o">[(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">),</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)]</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>이를 통해 구할 수 있는 스타트 팀과 링크 팀의 능력치를 다음과 같이 구할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="o">[</span><span class="mi">5</span><span class="o">(</span><span class="no">S12</span> <span class="o">+</span> <span class="no">S21</span><span class="o">),</span> <span class="mi">7</span><span class="o">(</span><span class="no">S34</span><span class="o">,</span> <span class="no">S43</span><span class="o">)]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">,</span>
<span class="o">[</span><span class="mi">9</span><span class="o">(</span><span class="no">S13</span><span class="o">,</span> <span class="no">S31</span><span class="o">),</span> <span class="mi">10</span><span class="o">(</span><span class="no">S24</span><span class="o">,</span> <span class="no">S42</span><span class="o">)]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">,</span>
<span class="o">[</span><span class="mi">6</span><span class="o">(</span><span class="no">S14</span><span class="o">,</span> <span class="no">S41</span><span class="o">),</span> <span class="mi">6</span><span class="o">(</span><span class="no">S23</span><span class="o">,</span> <span class="no">S32</span><span class="o">)]</span> <span class="o">=</span> <span class="mi">0</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>위 조합에서 팀 간의 점수 차가 가장 낮은 방법은 1번과 4번이 한 팀, 2번과 3번이 한 팀이었을 때이다! 이와 같이 모든 조합의 경우의 수를 탐색해가며 <strong>두 팀 간 능력치의 차가 최솟값이 되는 조합</strong> 방법을 찾으면 된다.</p>

<p>문제풀이를 위한 아이디어는 다음과 같다.</p>

<ol>
  <li>N/2 만큼 사람을 구분하여 팀을 나누기 때문에, 재귀 호출을 하며 재귀의 깊이가 N/2가 되면 종료한다.</li>
  <li>방문 배열에 방문한 노드의 페어로 같은 팀을 구분하여 스타트팀과 링크 팀의 점수를 구한다.</li>
  <li>두 팀의 점수차의 절댓값을 구한 후 출력한다.</li>
</ol>

<blockquote>
  <p>두 팀의 점수차가 0점이라면 이미 최소이기에 탐색을 더 진행할 필요가 없다.</p>
</blockquote>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// 방문배열과 입력배열 선언</span>
    <span class="kd">static</span> <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">arr</span><span class="o">;</span>    

    <span class="c1">// 배열의 크기 N 선언</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="no">N</span><span class="o">;</span>

    <span class="c1">// 최솟값을 담을 변수 선언</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">min</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
            
                <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>

                <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">][</span><span class="no">N</span><span class="o">];</span>
                <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>

                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                    <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                        <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                    <span class="o">}</span>
                <span class="o">}</span>

                <span class="c1">// 최솟값 갱신을 위한 min 초기화.</span>
                <span class="n">min</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">;</span>

                <span class="c1">// dfs 함수 호출</span>
                <span class="n">dfs</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>

                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">min</span><span class="o">+</span><span class="s">"\n"</span><span class="o">);</span>

        <span class="o">}</span>

    <span class="o">}</span>

    <span class="cm">/**
     * idx: 인덱스
     * depth: 재귀의 깊이, 조합 개수
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">idx</span><span class="o">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// N/2 번만큼 반복후 종료한다.</span>
        <span class="k">if</span><span class="o">(</span><span class="n">depth</span> <span class="o">==</span> <span class="no">N</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
            
            <span class="c1">// 스타트 팀과 링크 팀의 점수를 구하기 위한 초기화.</span>
            <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">link</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

            <span class="c1">// 방문한 팀과 방문하지 않은 팀을 나누어 팀의 점수를 구하고 최솟값을 찾는다.</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>

                    <span class="c1">// i번째와 j번째 사람이 true라면, start team이다.</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="kc">true</span> <span class="o">&amp;&amp;</span> <span class="n">visited</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">start</span> <span class="o">+=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                        <span class="n">start</span> <span class="o">+=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">i</span><span class="o">];</span>
                    <span class="o">}</span>
                    <span class="c1">// i번째와 j번째 사람이 fals라면, link team이다.</span>
                    <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="kc">false</span> <span class="o">&amp;&amp;</span> <span class="n">visited</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="kc">false</span><span class="o">)</span> <span class="o">{</span>
                        <span class="n">link</span> <span class="o">+=</span> <span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">];</span>
                        <span class="n">link</span> <span class="o">+=</span> <span class="n">arr</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">i</span><span class="o">];</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>

            <span class="c1">// 두 팀의 점수 차이 절댓값을 구한다.</span>
            <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">start</span> <span class="o">-</span> <span class="n">link</span><span class="o">);</span>

            <span class="c1">// 만약 두 팀의 점수 차가 0이라면 가장 최솟값이기에 바로 죵료한다.</span>
            <span class="k">if</span><span class="o">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">min</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
            
            <span class="n">min</span> <span class="o">=</span> <span class="nc">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">min</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>

        <span class="o">}</span>

        <span class="c1">// N까지 반복해가며 방문하지 않았다면 아래 내용 수행</span>
        <span class="c1">// 방문 처리 -&gt; 재귀 호출 -&gt; 방문 처리 해제</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">idx</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span><span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                <span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">,</span> <span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
                <span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>

    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/14889">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[14889번 - 스타트와 링크]]></summary></entry><entry><title type="html">[Java] 프로그래머스(level-2) - 프렌즈4블록</title><link href="http://localhost:4000/java/253-post/" rel="alternate" type="text/html" title="[Java] 프로그래머스(level-2) - 프렌즈4블록" /><published>2023-08-14T00:00:00+09:00</published><updated>2023-08-14T00:00:00+09:00</updated><id>http://localhost:4000/java/253-post</id><content type="html" xml:base="http://localhost:4000/java/253-post/"><![CDATA[<p><br /></p>

<center><img src="/assets/images/programmers/" width="100%" /></center>

<p><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>
<hr />

<p>이번 문제는 문제에서 요구한 대로 구현하기만 하면 되는 문제이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>문제의 요구사항대로 정리하면 아이디어는 간단하다.</p>

<ol>
  <li>2X2 블록을 체크한다.</li>
  <li>체크된 2x2 블록을 제거한다. <strong>블록의 제거는 ‘#’으로 치환</strong>하는 것으로 한다.</li>
  <li>블록을 떨어뜨린다.</li>
  <li>제거할 블록이 없을 때까지 1-3번 과정을 반복한다.</li>
</ol>

<p>2X2 블록을 체크하고 제거하는 것은 크게 어렵지 않았지만, 블록을 떨어뜨리는(윗블록과 아랫블록을 교체하는) 작업에서 배열을 잘 다룰 수 있어야 함을 느꼈다.</p>

<blockquote>
  <p>블록을 떨어뜨릴 때는 board를 탐색하면서 3중 for문을 이용해 세로 열로 제거된 블록과 제거되지 않은 블록을 교체하도록 구현하였다.</p>
</blockquote>

<p><br /></p>

<p>다음으로 문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<p><br /><br /></p>

<h3 id="작성-코드">작성 코드</h3>
<hr />
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
</pre></td><td class="rouge-code"><pre>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Solution</span> <span class="o">{</span>

    <span class="c1">// 1. 2X2 블록을 체크한다.</span>
    <span class="c1">// 2. 체크된 2x2 블록을 제거한다. 블록의 제거는 '#'으로 치환하는 것으로 한다.</span>
    <span class="c1">// 3. 블록을 떨어뜨린다.</span>
    <span class="c1">// 4. 제거할 블록이 없을 때까지 1-3번 과정을 반복한다.</span>

    <span class="kd">static</span> <span class="kt">boolean</span><span class="o">[][]</span> <span class="n">visited</span><span class="o">;</span>
    <span class="kd">static</span> <span class="kt">char</span><span class="o">[][]</span> <span class="n">map</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">,</span> <span class="nc">String</span><span class="o">[]</span> <span class="n">board</span><span class="o">)</span> <span class="o">{</span>

        <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">input</span> <span class="o">=</span> <span class="n">board</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">input</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="c1">// 제거된 블록의 수를 담기 위해 0으로 초기화</span>
        <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        
        <span class="k">while</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
            
            <span class="kt">boolean</span> <span class="n">isContinue</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
            <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>

            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">++</span> <span class="o">)</span> <span class="o">{</span>
                    
                    <span class="c1">// 이미 지워진 블록은 체크할 필요가 없다.</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'#'</span><span class="o">)</span> <span class="o">{</span>
                        <span class="k">continue</span><span class="o">;</span>
                    <span class="o">}</span>

                    <span class="c1">// 현재 위치부터 2X2 블록이 같다면 체크해둔다.</span>
                    <span class="k">if</span><span class="o">(</span><span class="n">checkBlock</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">))</span> <span class="o">{</span>
                        <span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
                        <span class="n">isContinue</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
                    <span class="o">}</span>

                <span class="o">}</span>
            <span class="o">}</span>

            <span class="c1">// 종료조건: 제거할 블록이 없다면 종료한다.</span>
            <span class="k">if</span><span class="o">(</span><span class="n">isContinue</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">break</span><span class="o">;</span>
            <span class="o">}</span>
            
            <span class="c1">// 지워진 블록의 수를 담는다.</span>
            <span class="n">answer</span> <span class="o">+=</span> <span class="n">removeBlock</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>
            
            <span class="c1">// 블록 제거 후 위에 있는 블록을 떨어뜨린다.</span>
            <span class="n">dropBlock</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">);</span>

        <span class="o">}</span>


        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">answer</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">answer</span><span class="o">;</span>

    <span class="o">}</span>

    <span class="c1">// 현재 위치의 블록으로부터 오른쪽, 아래, 오른쪽 아래 블록이 같은 블록인지 확인하는 함수</span>
    <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">checkBlock</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">char</span> <span class="n">block</span> <span class="o">=</span> <span class="n">map</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">];</span>
        <span class="k">if</span><span class="o">(</span><span class="n">block</span> <span class="o">==</span> <span class="n">map</span><span class="o">[</span><span class="n">x</span><span class="o">][</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">block</span> <span class="o">==</span> <span class="n">map</span><span class="o">[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">y</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="n">block</span> <span class="o">==</span> <span class="n">map</span><span class="o">[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="o">][</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 블록을 '#'으로 치환해 제거한다.</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="nf">removeBlock</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>

        <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

        <span class="c1">// 블록을 제거하면서 제거된 블록의 수 카운트</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
                <span class="k">if</span><span class="o">(</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
                    <span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'#'</span><span class="o">;</span>
                    <span class="n">cnt</span><span class="o">++;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">cnt</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">dropBlock</span><span class="o">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">,</span> <span class="kt">int</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">;</span> <span class="n">j</span><span class="o">--)</span> <span class="o">{</span>
                
                <span class="c1">// '#' 로 제거된 블록만 위로 올린다.</span>
                <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'#'</span><span class="o">)</span> <span class="o">{</span>
                    
                    <span class="c1">// 세로로 탐색하며 제거된 블록을 스왑하여 위의 블록을 아래로 내린다.</span>
                    <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">;</span> <span class="n">k</span><span class="o">&gt;=</span><span class="mi">0</span><span class="o">;</span> <span class="n">k</span><span class="o">--)</span> <span class="o">{</span>
                        
                        <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="sc">'#'</span><span class="o">)</span> <span class="o">{</span>
                            <span class="k">continue</span><span class="o">;</span>
                        <span class="o">}</span>

                        <span class="n">map</span><span class="o">[</span><span class="n">j</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">map</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">i</span><span class="o">];</span>
                        <span class="n">map</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="sc">'#'</span><span class="o">;</span>
                        <span class="k">break</span><span class="o">;</span>

                    <span class="o">}</span>

                <span class="o">}</span>
                
            <span class="o">}</span>

        <span class="o">}</span>

    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="nc">Solution</span> <span class="n">sol</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Solution</span><span class="o">();</span>
        
        <span class="c1">// int m = 6;</span>
        <span class="c1">// int n = 6;</span>
        <span class="c1">// String[] board = new String[]{"TTTANT", "RRFACC", "RRRFCC", "TRRRAA", "TTMMMF", "TMMTTJ"};</span>

        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">4</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span><span class="o">;</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">board</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[]{</span><span class="s">"CCBDE"</span><span class="o">,</span> <span class="s">"AAADE"</span><span class="o">,</span> <span class="s">"AAABF"</span><span class="o">,</span> <span class="s">"CCBBF"</span><span class="o">};</span>

        <span class="n">sol</span><span class="o">.</span><span class="na">solution</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span> <span class="o">,</span> <span class="n">board</span><span class="o">);</span>

    <span class="o">}</span>

<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="회고">회고</h3>
<p>-</p>

<hr />

<p><br /></p>

<h3 id="출처">출처</h3>
<p>-</p>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://school.programmers.co.kr/learn/courses/30/lessons/17679">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="programmers" /><summary type="html"><![CDATA[level 2 - 프렌즈4블록]]></summary></entry><entry><title type="html">[Java] 백준(골드-4) 9663번 - N-Queen</title><link href="http://localhost:4000/java/251-post/" rel="alternate" type="text/html" title="[Java] 백준(골드-4) 9663번 - N-Queen" /><published>2023-08-11T00:00:00+09:00</published><updated>2023-08-11T00:00:00+09:00</updated><id>http://localhost:4000/java/251-post</id><content type="html" xml:base="http://localhost:4000/java/251-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이 문제는 <strong>백트래킹</strong> 유형의 대표 문제 중 하나이다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>이 문제에서는 아래 두가지를 유심히 살펴봐야 한다.</p>

<ol>
  <li>재귀함수를 어떻게 호출할까?</li>
  <li>퀸을 놓을 수 있는지 어떻게 확인할까?</li>
</ol>

<p>예시를 살펴보자.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="c1">// N = 4일 때 경우의 수는 2가지</span>

<span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span>
<span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span>
<span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span>
<span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span>
<span class="o">=&gt;</span> <span class="o">[</span><span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">1</span><span class="o">]</span>

<span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span>
<span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span>
<span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span>
<span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span>
<span class="o">=&gt;</span> <span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">]</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>잘 보면 <strong>각 원소의 값을 행</strong>이라고 하고, <strong>각 원소의 인덱스를 열</strong>이라고 하면 1차원 배열로 표현할 수 있다는 것을 알 수 있다.</p>

<p>위 예시의 첫번째 경우를 보면 <code class="language-plaintext highlighter-rouge">[2, 0, 3, 1]</code> 으로 원소의 값을 행, 인덱스를 열이라 생각하면 이해하기 쉽다.</p>

<p><br /></p>

<h4 id="재귀-호출-아이디어">재귀 호출 아이디어</h4>
<p>그러면 재귀호출을 어떻게 해야할지 어느정도 그림이 그려진다.</p>

<p><strong>첫 번째 열부터 퀸을 놓을 수 있는 위치라면 퀸을 놓아가면서 재귀호출을 하며 마지막 열까지 채웠을 때 N개의 퀸을 놓았으면 재귀 호출을 종료</strong>하면 된다.</p>

<h4 id="퀸-검증-아이디어">퀸 검증 아이디어</h4>
<p>재귀 호출 중 맵의 위치를 탐색해가며 현재 위치에 퀸을 놓을 수 있는지 어떻게 알 수 있을까? 다음 2가지 조건을 고려해야 한다.</p>

<ol>
  <li>해당 열, 같은 행에 다른 퀸이 놓여있을 경우, <strong>해당 열의 행과 i열의 행이 일치할 경우 같은 행에 놓여있다</strong>는 의미이다.</li>
  <li>대각선상에 다른 퀸이 놓여있을 경우, <strong>행의 차와 열의 차가 같다면 대각선에 놓여있다</strong>는 의미이다.</li>
</ol>

<p>위 2가지 조건 중 하나라도 걸린다면 현재 위치에 퀸을 놓지 못한다고 보면 된다.</p>

<p><br /></p>

<p>자 위 내용들을 통해 정리한 문제 풀이 아이디어를 보자.</p>

<ol>
  <li>0번째 열부터 DFS를 호출해가며 퀸을 놓을 수 있는 위치인지 확인하여 퀸을 놓는다.</li>
  <li>퀸을 놓을 수 있는 위치인지 확인할 때, 현재 열의 다른 행에 퀸이 이미 놓여있는지, 현재 위치 기준 대각선 상에 이미 퀸이 놓여있는지를 검사한다.</li>
  <li>위 과정을 반복하며 N-1번째 열까지 탐색했을 때 N개의 퀸을 놓았다면 경우의 수의 카운트를 1 증가시키고 재귀를 종료한다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// 퀸이 서로 공격할 수 없도록 배치하는 모든 경우의 수를 구해야 한다.</span>

    <span class="c1">// 게임판의 크기</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="no">N</span><span class="o">;</span>

    <span class="c1">// 퀸을 놓을 배열</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">map</span><span class="o">;</span>

    <span class="c1">// 경우의 수를 담을 변수</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="n">result</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
            
                <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">N</span><span class="o">];</span>
                
                <span class="c1">// 재귀함수 호출</span>
                <span class="n">dfs</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>

                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">result</span> <span class="o">+</span> <span class="s">"\n"</span><span class="o">);</span>
                
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">depth</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="c1">// 깊이가 N이 되면 즉 행을 다 채우면 카운트 1 증가시키고 재귀 종료</span>
        <span class="k">if</span><span class="o">(</span><span class="n">depth</span> <span class="o">==</span> <span class="no">N</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">result</span><span class="o">++;</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="c1">// 1부터 N까지의 열을 탐색하며 i번째 행에 퀸을 놓는다.</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            
            <span class="c1">// i열 depth행에 퀸을 놓는다.</span>
            <span class="n">map</span><span class="o">[</span><span class="n">depth</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>

            <span class="c1">// 현재 열에서 i번째 행에 퀸을 놓을 수 있는지 확인하여 재귀 호출한다.</span>
            <span class="k">if</span><span class="o">(</span><span class="n">checkQueen</span><span class="o">(</span><span class="n">depth</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">dfs</span><span class="o">(</span><span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="o">);</span>
            <span class="o">}</span>

        <span class="o">}</span>

    <span class="o">}</span>

    <span class="c1">// 현재 위치가 퀸을 놓을 수 있는지 확인할 함수</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">checkQueen</span><span class="o">(</span><span class="kt">int</span> <span class="n">col</span><span class="o">)</span> <span class="o">{</span>
        
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">col</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            
            <span class="c1">// 해당 열의 행과 i열의 행이 일치할 경우</span>
            <span class="c1">// 즉, 같은 행에 퀸이 놓여있을 경우는 퀸을 놓을 수 없기에 false</span>
            <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">col</span><span class="o">]</span> <span class="o">==</span> <span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="c1">// 대각선 상에 퀸이 놓여있을 경우 불가하기에 false</span>
            <span class="c1">// 열의 차와 행의 차가 같은 경우는 대각선에 놓여 있다는 뜻이다.</span>
            <span class="c1">// col - i: 열의 차</span>
            <span class="c1">// map[col] - map[i]: 행의 차</span>
            <span class="k">else</span> <span class="nf">if</span><span class="o">(</span><span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">col</span> <span class="o">-</span> <span class="n">i</span><span class="o">)</span> <span class="o">==</span> <span class="nc">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">map</span><span class="o">[</span><span class="n">col</span><span class="o">]</span> <span class="o">-</span> <span class="n">map</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="o">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/9663">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[9663번 - N-Queen]]></summary></entry><entry><title type="html">[Java] 백준(실버-3) 15652번 - N과 M (4)</title><link href="http://localhost:4000/java/250-post/" rel="alternate" type="text/html" title="[Java] 백준(실버-3) 15652번 - N과 M (4)" /><published>2023-08-11T00:00:00+09:00</published><updated>2023-08-11T00:00:00+09:00</updated><id>http://localhost:4000/java/250-post</id><content type="html" xml:base="http://localhost:4000/java/250-post/"><![CDATA[<p><br /><br /></p>

<h3 id="문제-풀이">문제 풀이</h3>

<hr />

<p>이번 문제는 유사한 유형인 <a href="https://langoustinee.github.io/java/194-post/">N과 M (2)</a> 문제처럼 <strong>백트래킹</strong>을 이용해 풀 수 있다.</p>

<p><br /></p>

<h4 id="아이디어-도출">아이디어 도출</h4>

<p>오름차순 수열을 유지해야 하는 N과 M (2) 문제와 유사해보이지만, 이번 문제에서는 <strong>비내림차순으로 중복 여부가 허용</strong>됨을 고려해야 한다.</p>

<p>재귀함수를 어떻게 짜야 할까?</p>

<p>여기서도 깊이를 의미하는 depth와 함께 현재 위치를 의미하는 at을 함께 사용해야 한다. <strong>비내림차순으로 중복 여부가 허용</strong>되기에 1부터 N까지 탐색하며 다음 재귀를 호출할 때 <strong>i값을 at으로 넘겨 재귀호출</strong>하면 된다.</p>

<blockquote>
  <p>N과 M (2) 문제처럼 오름차순으로 수열을 담기 위해 i+1 값을 at으로 넘겨주는 것이 아니라, <strong>비내림차순으로 현재 위츼 i값도 허용</strong>되기에 i+1값이 아닌 i값을 at으로 넘겨준다.</p>
</blockquote>

<p>문제 풀이를 위한 아이디어는 다음과 같다.</p>

<ol>
  <li>DFS 재귀함수를 통해 1부터 N까지 탐색한다.</li>
  <li>탐색하며 재귀 호출할 때 현재 위치를 의히마는 at 변수와 깊이인 depth 변수 2가지를 인자로 호출한다.</li>
  <li>비내림차순의 수열을 유지하기 위해 중복이 허용되도록 <strong>1 ~ N까지 탐색할 때, at 변수를 현재 위치 i값으로 다음 재귀를 호출</strong>하며 수열을 갱신한다.</li>
  <li>수열의 길이(재귀함수의 깊이)가 M이 된다면 배열에 담아둔 수열을 저장하고 종료한다.</li>
</ol>

<p><br /></p>

<p>문제 풀이를 위해 작성한 코드는 아래와 같다.</p>

<h3 id="작성코드">작성코드</h3>

<hr />

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">java.io.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.*</span><span class="o">;</span>

<span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>    

    <span class="c1">// 1. 1~N까지 길이가 M인 수열을 선택해야 한다.</span>
    <span class="c1">// 2. 선택한 수열은 비내림차순이어야 한다. (비내림차순 != 오름차순)</span>
    <span class="c1">// 3. 중복 여부를 고려하지 않으므로 중복이 허용된다.</span>

    <span class="c1">// 수열 배열 선언</span>
    <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">arr</span><span class="o">;</span>

    <span class="c1">// 입력 N, M 선언</span>
    <span class="kd">static</span> <span class="kt">int</span> <span class="no">N</span><span class="o">,</span> <span class="no">M</span><span class="o">;</span>

    <span class="c1">// 출력할 수열을 담을 StringBuilder 선언</span>
    <span class="kd">static</span> <span class="nc">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span><span class="o">();</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">IOException</span> <span class="o">{</span>

        <span class="k">try</span> <span class="o">(</span><span class="nc">BufferedReader</span> <span class="n">br</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">InputStreamReader</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">in</span><span class="o">));</span>
            <span class="nc">BufferedWriter</span> <span class="n">bw</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">BufferedWriter</span><span class="o">(</span><span class="k">new</span> <span class="nc">OutputStreamWriter</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">)))</span> <span class="o">{</span>
            
                <span class="nc">StringTokenizer</span> <span class="n">st</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">StringTokenizer</span><span class="o">(</span><span class="n">br</span><span class="o">.</span><span class="na">readLine</span><span class="o">());</span>
                
                <span class="no">N</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                <span class="no">M</span> <span class="o">=</span> <span class="nc">Integer</span><span class="o">.</span><span class="na">parseInt</span><span class="o">(</span><span class="n">st</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
                
                <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="no">M</span><span class="o">];</span>

                <span class="n">dfs</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>

                <span class="n">bw</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">sb</span> <span class="o">+</span> <span class="s">"\n"</span><span class="o">);</span>
                
        <span class="o">}</span>

    <span class="o">}</span>

    <span class="cm">/**
     * 백트래킹 DFS 재귀함수
     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">dfs</span><span class="o">(</span><span class="kt">int</span> <span class="n">at</span><span class="o">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="o">)</span> <span class="o">{</span>

        <span class="c1">// 재귀 인덱스가 마지막 위치인 M이 된다면 수열을 sb에 담은 후 종료</span>
        <span class="k">if</span><span class="o">(</span><span class="n">depth</span> <span class="o">==</span> <span class="no">M</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="no">M</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]).</span><span class="na">append</span><span class="o">(</span><span class="s">" "</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">"\n"</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="cm">/**
         * 1부터 N까지 깊이를 1씩 증가시키며 DFS를 재귀호출한다.
         * arr 배열에 M 길이만큼의 조합을 담아나간다.
         * 오름차순과는 다르게 비내림차순으로 중복이 허용되기에 동일한 i값을 at으로 넘겨준다.
         */</span>
        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">at</span><span class="o">;</span> <span class="n">i</span><span class="o">&lt;=</span><span class="no">N</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">arr</span><span class="o">[</span><span class="n">depth</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
            <span class="n">dfs</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>

    <span class="o">}</span>

<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="출처">출처</h3>

<hr />

<ul>
  <li>해당 문제의 저작권은 문제를 만든이에게 있으며 자세한 내용은 <a href="https://www.acmicpc.net/problem/15652">문제 링크</a>에서 참조바랍니다.</li>
</ul>]]></content><author><name>lango</name></author><category term="Java" /><category term="blog" /><category term="algorithm" /><category term="study" /><category term="java" /><category term="baekjoon" /><summary type="html"><![CDATA[15652번 - N과 M (4)]]></summary></entry></feed>